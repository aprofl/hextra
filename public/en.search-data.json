{"/docflow/about/about/":{"data":{"":"","개요#개요":"이 카테고리는 Obsidian이라는 강력한 노트 앱을 활용하여 문서를 작성, 관리 및 출판하는 방법을 돕기 위해 만들어졌습니다. Obsidian에서 콘텐츠를 작성하고, 정적 사이트를 빌드하며, 다양한 용도로 배포하는 방법을 다룹니다. 문서 작성부터 출판까지의 원활한 워크플로우를 제공하는 것이 목표입니다.","소개#소개":"Obsidian을 이용한 문서 작성, 정적 사이트 빌드 및 웹 배포에 대한 종합 가이드에 오신 것을 환영합니다. 이 카테고리는 웹 매뉴얼, 블로그, 오프라인 매뉴얼 앱을 만들기 위한 전체 과정을 안내합니다.","이-방법을-사용하는-이유#이 방법을 사용하는 이유":" 유연성과 제어: Obsidian을 사용한 콘텐츠 작성은 문서에 대한 완전한 제어를 제공합니다. Markdown으로 작성하고, 노트를 링크하며, 다양한 콘텐츠 간의 연결을 시각화할 수 있습니다.\n효율성: Obsidian 노트에서 정적 사이트를 빌드하는 것은 매우 효율적인 콘텐츠 관리 및 출판 방법입니다. 정적 사이트는 빠르고, 안전하며, 배포가 쉽습니다.\n다양성: 웹 매뉴얼, 블로그, 오프라인 가이드 등 다양한 용도로 활용할 수 있는 유연한 솔루션을 제공합니다. 처음부터 다시 시작할 필요 없이 다양한 출판 형식에 워크플로우를 적응시킬 수 있습니다.","학습-내용#학습 내용":" Obsidian에서 문서 작성 및 관리: Obsidian의 기본 사용법부터 시작하여, 노트와 문서를 효과적으로 작성하고 조직하는 방법을 소개합니다. Obsidian의 강력한 기능인 백링크, 그래프 뷰 및 플러그인에 대해 배웁니다.\n정적 사이트 빌드: Obsidian에서 준비된 콘텐츠를 정적 사이트로 변환하는 방법을 설명합니다. 이를 위해 빠르고 유연한 정적 사이트 생성기인 Hugo와 같은 도구를 사용합니다. Hugo를 설정하고, 필요에 맞게 구성하며, Obsidian과 통합하는 방법을 배웁니다.\n사이트 배포: 정적 사이트를 빌드한 후, 배포 과정을 안내합니다. GitHub Pages, Netlify 등의 호스팅 서비스에 사이트를 호스팅하는 방법을 다룹니다. 사이트를 라이브로 만들고, 청중이 접근할 수 있도록 단계별 지침을 제공합니다.\n오프라인 매뉴얼 생성: 오프라인에서도 문서를 접근할 수 있도록 사이트를 앱으로 패키징하는 방법을 살펴봅니다. 이는 오프라인 매뉴얼이나 가이드 작성에 특히 유용합니다.","활용-예시#활용 예시":" 개인 블로그 운영: 쉽게 콘텐츠를 작성하고 관리할 수 있어 블로그 운영이 더욱 간편해집니다. 기술 문서 작성: 소프트웨어 개발자나 엔지니어들이 기술 문서를 작성하고 배포하는데 유용합니다. 제품 매뉴얼 제작: 제품 매뉴얼을 작성하고 업데이트하여 사용자들에게 제공할 수 있습니다. 팀 협업 도구: 팀원들과의 협업을 통해 프로젝트 문서를 공유하고 수정할 수 있습니다. 강의 자료 관리: 강의 노트, 슬라이드, 참고 자료 등을 체계적으로 관리하고 공유할 수 있습니다.- 학생과 연구자: 학습 노트, 연구 자료, 논문 등을 정리하고 공유할 수 있습니다.- "},"title":"About"},"/docflow/about/learning/":{"data":{"test#test":"","학습-과정-소개#학습 과정 소개":"test학습 과정 소개\r이 사이트는 옵시디언을 활용하여 문서를 작성하고, 정적 사이트로 빌드하여 웹으로 배포하거나 앱으로 빌드하는 과정을 단계별로 안내합니다. 각 단계는 이해하기 쉽게 나뉘어 있으며, 필요한 기술과 도구를 효과적으로 활용할 수 있도록 돕습니다.\n1. 옵시디언\r옵시디언은 마크다운 기반의 노트 작성 도구로, 간편한 사용법과 강력한 기능을 제공합니다. 이 섹션에서는 옵시디언의 기본 개념과 주요 기능을 소개합니다.\n작성: 옵시디언을 사용하여 효율적으로 노트를 작성하는 방법을 다룹니다. 기본적인 마크다운 문법과 템플릿 사용법을 배웁니다. 설정 및 관리: 옵시디언의 설정을 최적화하고, 플러그인을 활용하여 생산성을 높이는 방법을 안내합니다. 활용: 옵시디언을 활용하여 개인 프로젝트부터 협업 프로젝트까지 다양한 용도로 사용할 수 있는 팁과 트릭을 제공합니다. 2. 정적 사이트\r정적 사이트는 서버 측 처리 없이 정적인 HTML, CSS, JavaScript 파일로만 구성된 웹사이트를 의미합니다. 이 섹션에서는 정적 사이트의 개념과 장점을 소개합니다.\nHugo: 정적 사이트 생성 도구 중 하나인 휴고(Hugo)를 사용하여 웹사이트를 구축하는 방법을 배웁니다. mkdocs: 문서화를 위한 정적 사이트 생성 도구인 mkdocs를 활용하여 웹사이트를 만드는 방법을 안내합니다. Docusaurus: Docusaurus를 사용하여 기술 문서 및 블로그를 작성하고 배포하는 방법을 학습합니다. Astro: 최신 정적 사이트 생성 도구인 Astro를 활용하여 빠르고 최적화된 웹사이트를 구축하는 방법을 다룹니다. 3. 웹 게시\r작성된 정적 사이트를 웹에 배포하는 방법을 안내합니다. 배포 시 고려해야 할 사항과 다양한 배포 플랫폼에 대해 다룹니다.\n4. 앱 빌드\r작성한 정적 사이트를 데스크탑 또는 모바일 앱으로 빌드하여 오프라인에서도 사용할 수 있도록 만드는 방법을 소개합니다.\n일렉트론(Electron)을 사용하여 웹 기술로 데스크탑 애플리케이션을 만드는 방법을 학습합니다. 타우리(Tauri)를 활용하여 경량화된 데스크탑 애플리케이션을 구축하는 방법을 안내합니다. "},"title":"Learning"},"/docflow/deployment/about/blog-%EA%B0%9C%EC%9A%94/":{"data":{"":"","기본-전략#기본 전략":"기본 전략\rObsidian으로 글 작성 및 관리\r마크다운 기반의 노트 작성 및 관리 애플리케이션을 사용하여 글을 작성하고 관리합니다. 이를 통해 모든 글을 체계적으로 관리하고 연결할 수 있습니다. 동기화\rNextCloud를 이용한 동기화 작성한 글을 여러 디바이스에서 접근하고 편집할 수 있도록 NextCloud를 사용하여 동기화합니다. 정적사이트로 빌드\rHugo: 고성능 정적 사이트 생성기를 사용하여 Obsidian에서 작성한 글을 정적 사이트로 빌드합니다. Git에 푸시\r작성된 정적 사이트 파일을 Git 리포지토리에 푸시하여 버전 관리를 수행합니다. Git을 사용하면 협업과 버전 관리를 쉽게 할 수 있습니다.git add ., git commit -m \"message\", git push origin main 명령어를 사용하여 변경 사항을 푸시합니다. CloudFlare로 배포\rCloudFlare Pages: CloudFlare의 정적 사이트 호스팅 서비스를 사용하여 빌드된 사이트를 배포합니다. Git 리포지토리와 연동하여 자동으로 사이트를 빌드하고 배포합니다. CloudFlare 대시보드에서 Pages 설정을 통해 Git 리포지토리를 연결하고 빌드 설정을 완료합니다. "},"title":"Blog 개요"},"/docflow/deployment/about/blog-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EC%84%A0%ED%83%9D/":{"data":{"":"","요구사항#요구사항":"","플랫폼-조사#플랫폼 조사":"요구사항\rmd 기반으로 작성 가능할 것. Obsidian을 잘 쓰고 있으니, 가능한 옵시디언에서 작성하고 최소한의 작업으로 블로그에 게시 가능할 것 wiki 스타일로 내부링크가 쉬울 것. 옵시디언에서 작성한 글의 내부 링크도 유지될 것 유지 관리가 간편할 것 구글 애드센스 게시가 가능할 것 플랫폼 조사\r이용가능한 플랫폼을 찾아보고, 하나씩 소거\n워드프레스\r플러그인 쓰면 md 기반 작성 가능하지.. wiki 스타일 구축도 가능은 하지.. 유지관리는 누가 하나.. Velog\r기본 md 기반 작성은 좋지.. 깔끔하지.. 애드센스가 안된다고? 근데 사이트에서 광고를 붙인다고? 티스토리\r무난무난하지만.. 내가 쓴 글이 내것이 아니라고? Obsidian\r이건 마지막 선택지로 보류 StaticSite 생성기\r이건 추가 조사 "},"title":"Blog 플랫폼 선택"},"/docflow/deployment/about/blog-%ED%94%8C%EB%9E%AB%ED%8F%BC-%EC%A2%85%EB%A5%98/":{"data":{"":"","obsidian#Obsidian":"","tistory#Tistory":"","velog#Velog":"","wordpress#WordPress":"","정적-사이트-블로그static-site-blogstaticsite20blog20종류md#\u003ca href=\"StaticSite%20Blog%20%EC%A2%85%EB%A5%98.md\"\u003e정적 사이트 블로그(Static Site Blog)\u003c/a\u003e":"WordPress\r특징\r세계에서 가장 널리 사용되는 오픈 소스 콘텐츠 관리 시스템(CMS)입니다. 장점\r사용자 친화적 인터페이스 : 설치와 사용이 간편하고, 비개발자도 쉽게 블로그를 운영할 수 있습니다. 확장성 : 다양한 플러그인과 테마를 통해 기능을 쉽게 확장하고 커스터마이징할 수 있습니다. 커뮤니티와 지원 : 방대한 사용자 커뮤니티와 많은 온라인 리소스가 있어 문제 해결과 새로운 기능 구현이 용이합니다. 단점:\r지속적 관리 : 각종 플러그인과 테마의 업데이트, 지원 종료 등에 대한 지속적 관리 필요 보안 취약성 : 플러그인이나 테마의 보안 취약점으로 인해 해킹의 위험이 있습니다. 성능 문제 : 많은 플러그인 사용 시 로딩 속도가 느려질 수 있으며, 트래픽이 많은 경우 서버 부하가 증가합니다. 비용 : 호스팅 비용과 유료 플러그인, 테마 사용 시 추가 비용이 발생할 수 있습니다.- Velog\r특징\r개발자 중심의 블로그 플랫폼으로, 마크다운을 사용하여 블로그 글을 작성하고 게시할 수 있습니다. 장점\r간편한 사용 : 마크다운을 사용하여 쉽게 글을 작성하고 게시할 수 있습니다. 개발자 친화적 : 코드 하이라이트 및 다양한 개발 관련 기능을 지원합니다. 무료 사용 : 무료로 블로그를 운영할 수 있습니다. 단점\r제한된 커스터마이징: 블로그의 디자인과 기능을 자유롭게 변경하기 어렵습니다. 플랫폼 종속성 : Velog의 서비스 정책에 따라 블로그 운영이 영향을 받을 수 있습니다. 광고 게시 어려움 : Google Adsense 게시를 지원하지 않습니다. Obsidian\r특징\r강력한 노트 작성 및 개인 지식 관리 도구로, 마크다운을 사용하여 노트를 작성할 수 있습니다. 플러그인이나 외부 도구를 통해 블로그로 게시할 수 있습니다. 장점\r연결된 사고 : 노트 간의 링크를 통해 지식을 유기적으로 연결할 수 있습니다. 로컬 저장 : 모든 데이터가 로컬에 저장되어 보안성이 높습니다. 확장성 : 다양한 플러그인을 통해 기능을 확장할 수 있습니다. 단점\r비용 : 블로그로 게시하기 위해 유료 서비스를 이용해야 합니다. 커스터마이징이나 광고 게시 등이 제한적입니다. Tistory\r특징\r국내에서 많이 사용되는 블로그 플랫폼으로, 네이버 블로그와 비슷한 방식의 서비스입니다. 장점\r간편한 사용: 복잡한 설정 없이 쉽게 블로그를 시작하고 운영할 수 있습니다. 무료 제공 : 호스팅 비용 없이 블로그를 무료로 운영할 수 있습니다. 다양한 스킨 제공 : 여러 가지 스킨을 제공하여 블로그를 쉽게 꾸밀 수 있습니다. 단점\r제한된 커스터마이징 : 커스터마이징 가능성이 제한적이며, 고급 기능 구현이 어려울 수 있습니다. 소유권 문제: 플랫폼이 제공하는 서비스에 의존하기 때문에, 서비스 정책 변경에 영향을 받을 수 있습니다. SEO 제한: 검색 엔진 최적화(SEO) 기능이 제한적일 수 있습니다. 정적 사이트 블로그(Static Site Blog)\r특징\r정적 사이트 생성기(Static Site Generator)를 사용하여 HTML, CSS, JavaScript 파일로 구성된 블로그를 미리 생성하여 배포합니다. 장점\r빠른 로딩 속도 : 미리 생성된 페이지를 제공하기 때문에 로딩 속도가 매우 빠릅니다. 높은 보안성 : 서버 측 스크립트나 데이터베이스가 없어 해킹의 위험이 낮습니다. 저렴한 호스팅 비용 : 서버 자원을 거의 사용하지 않기 때문에 저렴한 비용으로 호스팅할 수 있습니다. 쉬운 배포 및 관리: 파일을 간단히 업로드하는 방식으로 배포하며, Git을 통한 버전 관리와 협업이 용이합니다. 확장성: 서버 부하가 적어 트래픽이 급증해도 문제 없이 대응할 수 있습니다. 단점\r동적 콘텐츠 구현 어려움 : 실시간 데이터 업데이트나 사용자 상호작용이 필요한 동적 콘텐츠 구현이 어렵습니다. 초기 설정 복잡성 : 개발 지식이 필요하며 초기 설정이 복잡할 수 있습니다. 사이트 규모에 따른 빌드 시간 증가 : 사이트 규모가 커지면 모든 페이지를 다시 생성하는 데 시간이 많이 걸릴 수 있습니다. "},"title":"Blog 플랫폼 종류"},"/docflow/deployment/about/staticsite-%EB%B0%B0%ED%8F%AC%ED%94%8C%EB%9E%AB%ED%8F%BC-%EC%84%A0%ED%83%9D/":{"data":{"":"","비용-안정성#비용 안정성":"비용 안정성\r비용을 고려해야 한다면, Cloudflare Pages의 무료 플랜이 비용 안전성이 매우 높습니다. Cloudflare Pages의 무료 플랜을 선택하고 추가 기능을 사용하지 않는 경우, 기본적으로 발생하는 트래픽에 대해 비용이 추가로 청구되지 않습니다.\nCloudflare Pages 무료 플랜의 장점\r고정 비용 없음: 무료 플랜은 정적 사이트 호스팅, 자동 배포, SSL 등 기본 기능을 무료로 제공합니다. DDoS 보호 포함: 기본적으로 Cloudflare의 DDoS 방어 기능이 포함되어 있어, 갑작스러운 트래픽 증가에도 추가 비용이 발생하지 않습니다. 대규모 트래픽 처리: Cloudflare의 글로벌 CDN을 통해 대규모 트래픽도 효율적으로 처리할 수 있습니다. 비용 발생에 대한 보장\r무료 플랜의 확실성 무료 플랜 내에서 제공되는 리소스와 기능을 사용하면 비용이 발생하지 않습니다. Cloudflare는 무료 플랜의 제한을 명확히 하고 있으며, 사용자가 선택하지 않는 한 추가 비용이 발생하지 않습니다. 추가 기능 사용 시 주의 Cloudflare Workers, Workers KV 등의 추가 기능을 사용하면 사용량에 따라 비용이 발생할 수 있습니다. 그러나 사용자가 명시적으로 이러한 기능을 활성화하지 않는 한, 추가 비용은 발생하지 않습니다. Netlify 및 Vercel의 우려점\r자동 증가 비용 Netlify와 Vercel의 무료 플랜은 사용량에 제한이 있으며, 이를 초과하면 자동으로 비용이 발생할 수 있습니다. 예를 들어, 빌드 시간 초과, 서버리스 함수 호출 수 초과 등이 이에 해당합니다. 예상치 못한 비용 트래픽 급증 시 추가 리소스 사용으로 인해 예기치 않은 비용이 발생할 수 있습니다. 이 때문에 트래픽 관리가 중요한 사이트 운영자에게는 부담이 될 수 있습니다. "},"title":"StaticSite 배포플랫폼 선택"},"/docflow/deployment/about/staticsite-%EB%B0%B0%ED%8F%AC%ED%94%8C%EB%9E%AB%ED%8F%BC-%EC%A2%85%EB%A5%98/":{"data":{"":"","cloudflare-pages#Cloudflare Pages":"요약\r플랫폼 기반 배포는 과정이 간단하고, 정적 사이트에 최적화된 기능을 제공합니다.\nNetlify나 Vercel : 사용하기 쉽고 강력한 기능을 제공하며, 특히 CDN 및 서버리스 기능이 필요하다면 추천합니다. GitHub Pages: 무료로 사용하기 좋으며, 간단한 프로젝트에 적합합니다. Cloudflare Pages: 빠른 CDN을 제공하여, 기본적인 정적 사이트 배포에 적합하며, 비용안정성이 높습니다. Netlify\r장점\r쉬운 설정: GitHub, GitLab, Bitbucket과 통합하여 간편하게 배포할 수 있습니다. 자동 빌드 및 배포: 푸시할 때마다 자동으로 빌드 및 배포가 이루어집니다. CDN 제공: 전 세계에 분산된 CDN을 통해 빠른 사이트 로딩 속도를 제공합니다. SSL 지원: 무료 SSL 인증서를 자동으로 발급하고 갱신해 줍니다. 폼 처리, 서버리스 함수: 정적 사이트에 동적 기능을 쉽게 추가할 수 있습니다. 단점\r요금제 제한: 무료 요금제의 경우 일부 기능에 제한이 있을 수 있습니다. 무료 요금제의 경우도 트래픽이 무료 한도를 넘어서면 유료로 전환됩니다. 요금제\r무료 플랜\r기본 제공: 무료 플랜에서 정적 사이트 호스팅, SSL, 자동 배포 기능을 제공합니다. 기본 보호: DDoS 공격에 대한 기본 보호가 있지만, Cloudflare만큼 강력하지 않을 수 있습니다. 제한 사항: 빌드 시간, 서버리스 함수 호출 수, 폼 제출 횟수 등에 제한이 있습니다. 유료 플랜\rPro Plan: 월 $19, 더 많은 빌드 시간과 폼 제출 수, 서버리스 함수 호출 수 제공. Business Plan: 월 $99, 팀 기능 및 고급 설정, 더 많은 자원 제공. Enterprise Plan: 맞춤형 요금, 모든 기능과 최고 수준의 성능 및 지원 제공. Vercel\r장점\rNetlify 와 거의 동일 단점\rNetlify 와 거의 동일 요금제\r무료 플랜\rNetlify 와 거의 동일 유료 플랜\rPro Plan: 월 $20, 더 많은 빌드 시간과 서버리스 함수 호출 수 제공. Enterprise Plan: 맞춤형 요금, 모든 기능과 최고 수준의 성능 및 지원 제공. GitHub Pages\r장점\r무료 제공: GitHub 계정만 있으면 무료로 사용할 수 있습니다. 간편한 설정: GitHub 리포지토리 설정에서 간편하게 Pages를 활성화할 수 있습니다. 지속적인 통합: GitHub Actions를 사용하여 자동으로 빌드 및 배포할 수 있습니다. 단점\r기능 제한: Netlify나 Vercel과 같은 고급 기능(예: 서버리스 함수, 폼 처리 등)이 부족합니다. 빌드 시간 제한: 큰 프로젝트의 경우 빌드 시간이 오래 걸릴 수 있습니다. Cloudflare Pages\r장점\r무료 제공: 기본적으로 무료로 사용할 수 있으며, 유료 플랜도 제공됩니다. 고속 CDN: Cloudflare의 글로벌 네트워크를 통해 빠른 사이트 로딩 속도를 제공합니다. 자동 빌드 및 배포: GitHub, GitLab과 통합하여 자동으로 빌드 및 배포가 이루어집니다. SSL 지원: 무료 SSL 인증서를 자동으로 발급합니다. 단점\r제한된 서버리스 기능: Netlify나 Vercel과 비교하여 서버리스 기능이 제한적입니다. 요금제\r무료 플랜\r기본 제공: 무료 플랜에서도 정적 사이트 호스팅과 SSL, 자동 배포 기능을 제공합니다. DDoS 보호: Cloudflare는 기본적으로 무료 플랜에서도 DDoS 공격 방어 기능을 제공합니다. 갑작스러운 트래픽 폭증에 대해 추가 비용이 발생하지 않습니다. 제한 사항: Workers KV, Durable Objects 등 고급 기능은 사용 제한이 있습니다. 유료 플랜\rPro Plan: 월 $20, 더 높은 성능 및 우선 지원 제공. Business Plan: 월 $200, 더 많은 기능 및 성능 최적화, 고급 DDoS 보호 제공. Enterprise Plan: 맞춤형 요금, 모든 기능과 최고 수준의 성능 및 지원 제공. ","github-pages#GitHub Pages":"","netlify#Netlify":"","vercel#Vercel":"","요약#요약":""},"title":"StaticSite 배포플랫폼 종류"},"/docflow/deployment/about/staticsite-%EB%B0%B0%ED%8F%AC-%EB%B0%A9%EC%8B%9D/":{"data":{"":"","요약#요약":"","전통적인-호스팅-서비스#전통적인 호스팅 서비스":"요약\r플랫폼 기반 배포는 자동화된 빌드 및 배포, CDN 제공, 서버리스 기능 지원, 무료 SSL 등의 장점을 통해 손쉽게 정적 사이트를 배포하고 관리할 수 있게 해줌. 이는 빠른 설정과 쉬운 관리를 원하는 사용자에게 특히 유리함. 전통적인 호스팅 서비스는 유연성과 확장성을 제공하지만, 더 많은 설정과 관리가 필요함. 서버에 대한 완전한 제어가 필요하고, 맞춤형 설정을 원할 경우 적합함. 대부분의 경우, Netlify, Vercel, GitHub Pages, Cloudflare Pages와 같은 플랫폼을 사용하는 것이 더 간편하고 효율적임. 특히 정적 사이트의 경우, 이러한 플랫폼이 제공하는 기능이 매우 강력하고 사용자 친화적이기 때문에 더욱 추천할 만함. 플랫폼 기반 배포\rNetlify, Vercel, GitHub Pages, Cloudflare Pages 등 장점\r자동화된 빌드 및 배포 Git 리포지토리와 연동되어 코드 푸시 시 자동으로 빌드 및 배포가 이루어짐. CI/CD(Continuous Integration/Continuous Deployment)를 쉽게 구현할 수 있음. CDN 포함 전 세계에 분산된 CDN(Content Delivery Network)을 통해 빠른 사이트 로딩 속도를 제공. 이는 사용자 경험을 향상시키고, SEO에도 긍정적인 영향을 미침. 무료 SSL 지원 무료 SSL 인증서를 제공하여 HTTPS를 쉽게 설정할 수 있음. 서버리스 기능 Netlify와 Vercel은 서버리스 함수(Function as a Service)를 제공하여 동적 기능을 쉽게 추가할 수 있음. 이는 서버리스 API 엔드포인트를 생성하거나, 폼 처리, 사용자 인증 등을 구현하는 데 유용함. 자동화된 성능 최적화 빌드 과정에서 이미지 최적화, 코드 스플리팅 등 성능 최적화를 자동으로 처리해줌. 쉬운 설정 및 관리 웹 인터페이스를 통해 손쉽게 설정 및 관리할 수 있으며, 다양한 설정 옵션을 제공. 단점\r사용량 제한 무료 요금제의 경우 사용량에 제한이 있을 수 있으며, 트래픽이나 빌드 시간 등에서 제한이 발생할 수 있음. 요금 제한 어려움 일정 구간 무료 후 구간 위로 트래픽이 증가하는 경우 유료화가 되는데, 대부분의 플랫폼이 유료 요금 제한을 둘 수 없음 제한된 서버 액세스 플랫폼이 제공하는 기능 외의 커스텀 서버 설정이 어려움. 전통적인 호스팅 서비스\r장점\r유연성 서버에 대한 완전한 액세스를 통해 커스텀 설정과 다양한 서버 애플리케이션을 자유롭게 설치할 수 있음. 확장성 필요에 따라 서버 자원을 확장하거나, 서버를 업그레이드할 수 있음. 더 많은 제어가 가능하므로 맞춤형 솔루션을 구현할 수 있음. 가격 대량 트래픽이나 고성능이 필요한 경우, 적절한 호스팅 플랜을 선택하여 비용 효율적으로 운영할 수 있음. 단점\r복잡한 설정 및 관리 서버 설정, 보안, 백업, 성능 최적화 등 모든 것을 직접 관리해야 함. 이는 기술적인 노하우와 시간이 필요함. CDN 및 SSL 설정 CDN과 SSL을 별도로 설정해야 하며, 이를 직접 관리해야 함. 자동화 부족 CI/CD 파이프라인을 직접 설정해야 하며, 빌드 및 배포 자동화가 기본 제공되지 않음. ","플랫폼-기반-배포#플랫폼 기반 배포":""},"title":"StaticSite 배포 방식"},"/docflow/deployment/about/staticsite-blog-%EC%84%A0%ED%83%9D/":{"data":{"":"","google-adsense-비교#Google Adsense 비교":"고려사항\r선택 시 고려한 사항은 순서대로 다음과 같습니다.\nObsidian 과의 호환성 내부 링크 유지 폴더 구조 유지 이미지 유지 플러그인 호환 SEO 최적화 CloudFlare 와의 호환성 Google Adsense 호환 및 최적화 디자인 유지관리 편의성 다국어 지원 디자인이 제일 중요했지만, 어느정도 상향 평준화 되어 있고 취향이나 유행에 민감하기도 하여 순위가 많이 밀렸습니다. 옵시디언으로 폴더 및 노트를 관리하고 추가 작업 없이 그대로 블로그로 빌드하는 것을 최우선 순위로 두었으며, SEO 최적화 이후 항목은 대부분의 툴이 비슷한 기능을 비슷한 성능으로 제공하여 크게 의미가 없었습니다. Jekyll 과 Docusaurus 는 호환성 문제로 우선 배제되었으며, Hugo의 성숙한 생태계로 인해 문제 발생 시의 대응이나 개선이 용의 할 것이라 판단되어 Hugo 를 1순위, Astro를 2순위로 진행해 보기로 하였습니다. 호환성 및 성능 비교\rHugo\r장점\r호환성 다양한 플러그인과 템플릿 옵션을 통해 Obsidian의 폴더 구조와 내부 링크를 쉽게 유지할 수 있습니다. Cloudflare Pages와의 호환성이 뛰어납니다. 빌드 속도 매우 빠른 빌드 속도를 자랑합니다. 대규모 사이트에서도 성능 저하 없이 빌드할 수 있습니다. 다국어 지원\\ 다국어 사이트를 쉽게 구축할 수 있는 기능을 제공합니다. 문서화 풍부한 문서화와 커뮤니티 지원으로 설정 및 사용이 비교적 용이합니다. 유연성 다양한 템플릿 엔진과 테마를 지원하여 디자인 커스터마이징이 용이합니다. 단점\r템플릿 언어 템플릿 언어가 다소 복잡할 수 있어 처음 사용자에게는 학습 곡선이 있을 수 있습니다. 초기 설정 초기 설정이 복잡할 수 있으며, 모든 기능을 활용하기 위해서는 상당한 설정이 필요할 수 있습니다. Astro\r장점\r호환성 Astro는 다양한 프레임워크(React, Vue, Svelte 등)를 함께 사용할 수 있습니다. Obsidian의 폴더 구조와 내부 링크를 유지하는 데 유연합니다. Cloudflare Pages와의 호환성도 매우 좋습니다. 성능 최적화 필요한 부분만 JavaScript를 로드하여 성능이 매우 뛰어납니다. 유연성 다양한 프레임워크를 혼합하여 사용할 수 있어 디자인 커스터마이징이 용이합니다. 간단한 설정 초기 설정이 비교적 간단하며, 빠르게 시작할 수 있습니다. 단점\r커뮤니티와 자료 상대적으로 새로운 도구이기 때문에 커뮤니티와 자료가 다른 도구들에 비해 부족할 수 있습니다. 기능 제한 일부 고급 기능이 부족할 수 있으며, 특정 기능은 추가 설정이 필요할 수 있습니다. SEO 최적화 비교\r공통적 특징\r정적 사이트 특성상 검색 엔진에서 빠르게 인덱싱되고, 메타 태그와 사이트맵 생성을 쉽게 설정할 수 있어 SEO 관리가 간편하다는 장점이 있습니다. 동적 SEO 최적화 기능(예: A/B 테스트, 실시간 분석 등)은 제한적이라는 단점이 있습니다. Hugo와 Astro 모두 SEO 최적화를 지원하지만 접근 방식과 기능에는 차이가 있습니다. Hugo\rSEO 최적화 장점\r빠른 페이지 빌드 시간 Hugo는 정적 사이트 생성기 중에서도 매우 빠른 빌드 속도를 자랑합니다. 빠른 빌드 속도 자체는 SEO에 직접적인 영향을 미치지 않지만, 다음과 같은 방식으로 간접적으로 영향을 줄 수 있습니다 더 빈번한 업데이트: 빌드 속도가 빠르기 때문에 사이트 콘텐츠를 자주 업데이트할 수 있으며, 이는 검색 엔진이 더 자주 사이트를 크롤링하고 인덱싱하는 데 도움이 됩니다. 개발자 효율성: 빠른 빌드 속도는 개발자와 콘텐츠 제작자의 작업 효율성을 높여 더 빠르게 변경 사항을 적용하고 배포할 수 있습니다. 이는 최신 콘텐츠를 유지하고 SEO에 유리한 최신 트렌드를 따르는 데 도움이 됩니다.\t- SEO 친화적 템플릿 많은 Hugo 테마가 기본적으로 SEO를 고려하여 설계되었습니다. 메타 태그, 구조화된 데이터, Open Graph 메타데이터 등이 포함됩니다. 쉽게 커스터마이즈 가능한 SEO 설정 Hugo는 기본 설정 파일에서 메타 태그, 사이트맵 생성, Canonical URL 등을 쉽게 설정할 수 있습니다. 다국어 지원 다국어 사이트를 쉽게 구축할 수 있어, 국제적인 SEO 최적화에 유리합니다. Astro\rSEO 최적화 장점\r빠른 페이지 로드 시간 필요한 부분만 JavaScript를 로드하는 방식으로 성능을 최적화하여 페이지 로드 시간이 매우 빠릅니다. 유연한 프레임워크 지원 다양한 프레임워크(React, Vue, Svelte 등)를 혼합하여 사용할 수 있어, 각 프레임워크의 SEO 최적화 기능을 활용할 수 있습니다. 모던 웹 기술 사용 최신 웹 기술을 사용하여 SEO를 최적화할 수 있습니다. 예를 들면, 최신 HTML, CSS, JavaScript 기능을 활용한 SEO 최적화 등이 있습니다. SEO 플러그인 및 도구 다양한 SEO 관련 플러그인과 도구를 쉽게 통합할 수 있습니다. SEO 최적화 단점\r새로운 생태계 Astro는 상대적으로 새로운 도구이기 때문에, Hugo에 비해 SEO 최적화에 대한 자료나 커뮤니티 지원이 부족할 수 있습니다. 구현 복잡성 다양한 프레임워크를 혼합하여 사용하는 경우, 각 프레임워크별로 SEO 최적화를 따로 신경 써야 할 수 있습니다. Google Adsense 비교\r공통적 특징\r정적 사이트 특성상 광고 로딩 속도가 빠르고 일관성 있게 유지(정적 페이지 안정성)된다는 장점이 있습니다. 동적 광고 최적화 기능이 제한적이라는 단점이 있습니다. Hugo\rGoogle AdSense 관리 장점\r쉬운 통합 Hugo의 템플릿 파일을 수정하여 Google AdSense 코드를 쉽게 삽입할 수 있습니다. 대부분의 Hugo 테마는 HTML 템플릿 파일을 포함하고 있어, 광고 코드를 추가하는 것이 비교적 간단합니다. SEO 최적화 Hugo의 빠른 페이지 로드 시간과 SEO 친화적인 템플릿은 광고 노출을 극대화하고 수익을 높이는 데 도움이 됩니다. 광고 최적화 플러그인 Hugo 커뮤니티에는 AdSense 광고 최적화와 관련된 다양한 플러그인과 스크립트가 있어 광고 관리를 용이하게 합니다. Google AdSense 관리 단점\r복잡한 광고 배치 다수의 광고 위치를 설정하고 최적화하는 과정이 다소 복잡할 수 있습니다. Astro\rGoogle AdSense 관리 장점\r유연한 통합 Astro는 다양한 프레임워크를 지원하므로, React, Vue, Svelte 등으로 작성된 컴포넌트 내에 Google AdSense 코드를 쉽게 삽입할 수 있습니다. 모던 웹 기술 최신 웹 기술을 활용하여 광고 로딩 속도를 최적화하고, 사용자 경험을 향상시킬 수 있습니다. 성능 최적화 필요한 부분만 JavaScript를 로드하는 Astro의 특성은 광고 로딩 성능에도 긍정적인 영향을 미칩니다. 광고 최적화 도구 통합 다양한 광고 최적화 도구와 쉽게 통합할 수 있습니다. Google AdSense 관리 단점\r커뮤니티와 자료 부족 Astro는 상대적으로 새로운 도구이기 때문에, AdSense 광고 최적화와 관련된 자료나 커뮤니티 지원이 부족할 수 있습니다. 복잡한 설정 다양한 프레임워크를 혼합하여 사용하는 경우, 광고 코드를 각 프레임워크별로 적절히 삽입하고 관리하는 것이 복잡할 수 있습니다. ","seo-최적화-비교#SEO 최적화 비교":"","고려사항#고려사항":"","호환성-및-성능-비교#호환성 및 성능 비교":""},"title":"StaticSite Blog 선택"},"/docflow/deployment/about/staticsite-blog-%EC%A2%85%EB%A5%98/":{"data":{"":"","staticsite-생성기staticsiteaboutstaticsite20생성기#\u003ca href=\"staticsite/about/staticsite%20%EC%83%9D%EC%84%B1%EA%B8%B0\"\u003eStaticSite 생성기\u003c/a\u003e":"정적 사이트 블로그(Static Site Blog)는 서버에서 동적으로 페이지를 생성하는 대신, 미리 생성된 HTML, CSS, JavaScript 파일을 사용하여 블로그를 제공하는 방식입니다. 정적 사이트 방식을 그대로 따르는 만큼, 장단점도 동일합니다. 관련 지식이 있다면 좋겠지만, 코드 작성에 거부감만 없다면 사전 지식 없이도 충분히 구현이 가능한 수준이며, 결과물은 꽤 만족스럽습니다.\nStaticSite 생성기"},"title":"StaticSite Blog 종류"},"/docflow/deployment/addsense/hugo-addsense-%EC%B6%94%EA%B0%80/":{"data":{"":"","1-구글-애드센스-계정-생성-및-광고-단위-만들기#1. 구글 애드센스 계정 생성 및 광고 단위 만들기":"","2-hugo-doks-테마에-애드센스-코드-추가하기#2. Hugo Doks 테마에 애드센스 코드 추가하기":"","3-hugo-사이트-재배포#3. Hugo 사이트 재배포":"1. 구글 애드센스 계정 생성 및 광고 단위 만들기\r구글 애드센스에 가입합니다. 이미 계정이 있다면 로그인합니다. 애드센스 대시보드에서 “광고 단위 만들기\"를 클릭하여 새 광고 단위를 만듭니다. 광고 단위의 설정을 완료하고 광고 코드를 복사합니다.\n2. Hugo Doks 테마에 애드센스 코드 추가하기\r2.1 헤더에 애드센스 스크립트 추가\rHugo 사이트의 루트 디렉토리에서 layouts/partials 폴더로 이동합니다. 만약 이 폴더가 없으면 생성합니다. head.html 파일을 열어 다음의 애드센스 스크립트를 추가합니다. 이 파일이 없다면 새로 만듭니다.\n\u003c!-- layouts/partials/head.html --\u003e \u003cscript async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js\"\u003e\u003c/script\u003e \u003cscript\u003e (adsbygoogle = window.adsbygoogle || []).push({ google_ad_client: \"YOUR_AD_CLIENT_ID\", enable_page_level_ads: true }); \u003c/script\u003e\r여기서 YOUR_AD_CLIENT_ID를 자신의 애드센스 계정에서 받은 ID로 교체합니다.\n2.2 본문에 광고 단위 삽입\r광고를 본문에 삽입하려면 적절한 위치에 광고 코드를 추가해야 합니다. 예를 들어, 블로그 포스트 본문에 광고를 넣으려면 single.html 파일을 수정해야 합니다.\nlayouts/_default/single.html 파일을 열어 원하는 위치에 광고 코드를 추가합니다. 보통 콘텐츠 중간이나 끝에 넣습니다.\n\u003c!-- layouts/_default/single.html --\u003e \u003carticle\u003e {{ .Content }} \u003c!-- 광고 코드 삽입 --\u003e \u003cins class=\"adsbygoogle\" style=\"display:block\" data-ad-client=\"YOUR_AD_CLIENT_ID\" data-ad-slot=\"YOUR_AD_SLOT_ID\" data-ad-format=\"auto\"\u003e\u003c/ins\u003e \u003cscript\u003e (adsbygoogle = window.adsbygoogle || []).push({}); \u003c/script\u003e \u003c/article\u003e\r여기서 YOUR_AD_CLIENT_ID와 YOUR_AD_SLOT_ID를 자신의 애드센스 계정에서 받은 ID로 교체합니다.\n3. Hugo 사이트 재배포\r변경 사항을 저장한 후 Hugo 사이트를 재배포합니다."},"title":"HUGO Addsense 추가"},"/docflow/deployment/guide/%EC%97%90%EB%9F%AC/":{"data":{"":"","mediatype-parsing#MediaType Parsing":"node.js 버전\rnpm WARN EBADENGINE Unsupported engine {\rnpm WARN EBADENGINE package: 'DocFlow_Hugo@0.0.0', npm WARN EBADENGINE required: { node: '\u003e=20.11.0' }, npm WARN EBADENGINE current: { node: 'v18.17.1', npm: '9.6.7' } npm WARN EBADENGINE } Cloudflare Pages에서 사용하는 Node.js 버전을 업그레이드해야 합니다. Cloudflare Pages에서는 .node-version 파일을 사용하여 Node.js 버전을 설정할 수 있습니다. 다음 단계에 따라 프로젝트의 루트 디렉토리에 .node-version 파일을 추가하고 필요한 Node.js 버전을 설정할 수 있습니다.\n1. .node-version 파일 추가\r프로젝트의 루트 디렉토리에 .node-version 파일을 생성합니다.\n파일 내용에 필요한 Node.js 버전을 지정합니다. 예를 들어, 20.11.0 버전을 사용하려면 파일 내용은 다음과 같습니다:\n20.11.0\r2. package.json 파일 업데이트\r이미 package.json 파일의 engines 섹션이 Node.js 버전을 요구하고 있으므로, 이 부분은 그대로 두면 됩니다. 하지만, 확인 차 다시 적어두겠습니다:\n\"engines\": { \"node\": \"\u003e=20.11.0\" }\r3. Cloudflare Pages 설정 업데이트\rCloudflare Pages 대시보드로 이동합니다. Environment variables 설정: Environment variables 탭을 선택합니다. Add variable 버튼을 클릭합니다. Name 필드에 NODE_VERSION을 입력하고, Value 필드에 20.11.0을 입력합니다. Save 버튼을 클릭하여 환경 변수를 저장합니다. 4. 로컬에서 빌드 테스트\r로컬 환경에서도 Node.js 버전을 업데이트하여 동일한 환경을 테스트합니다. 이를 위해 Node Version Manager (nvm)을 사용할 수 있습니다.\nnvm을 사용하여 Node.js 20.11.0 버전을 설치합니다: nvm install 20.11.0 nvm use 20.11.0\rnvm use 20.11.0을 통해 설치한 Node.js 버전을 사용하도록 설정합니다.\n프로젝트 디렉토리에서 종속성을 다시 설치하고 빌드를 테스트합니다:\nnpm install npm run build\r5. 변경 사항 푸시 및 배포\r위의 설정을 완료한 후 변경 사항을 GitHub 저장소에 푸시하고 Cloudflare Pages에서 자동으로 배포가 트리거되도록 합니다:\ngit add .node-version package.json git commit -m \"Update Node.js version to 20.11.0\" git push origin master\rNPM 패키지 문제\rnpm WARN deprecated inflight@1.0.6: This module is not supported, and leaks memory. Do not use it. Check out lru-cache if you want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.\rnpm WARN deprecated glob@7.2.3: Glob versions prior to v9 are no longer supported\r경고 메시지들은 오래된 NPM 패키지를 사용하고 있음을 나타내며, 이는 inflight 및 glob 패키지가 더 이상 지원되지 않거나 오래된 버전이라는 경고입니다. 이를 해결하기 위해서는 이러한 패키지를 업데이트하거나, 이를 사용하는 패키지를 업데이트하는 것이 좋습니다. 그러나 이는 실제 빌드 오류와는 무관할 수 있습니다. 하지만 장기적으로 안정성을 위해 업데이트를 고려하는 것이 좋습니다.\n1. inflight 패키지 경고 해결\rinflight 패키지는 더 이상 지원되지 않으며 메모리 누수를 일으킬 수 있으므로 대체 패키지로 전환하는 것이 좋습니다. 일반적으로 inflight를 직접 사용하지 않고, 다른 패키지의 종속성으로 포함되어 있을 수 있습니다.\n2. glob 패키지 경고 해결\rglob 패키지의 경우 v9 이전 버전은 더 이상 지원되지 않습니다. 따라서 glob 패키지의 최신 버전으로 업데이트하는 것이 좋습니다.\n종속성 업데이트 절차\r프로젝트의 종속성 업데이트: package.json 파일을 열어 사용 중인 패키지를 확인하고 업데이트합니다.\n패키지 업데이트: 종속성을 최신 버전으로 업데이트하기 위해 npm outdated 명령어를 사용하여 업데이트 가능한 패키지를 확인하고, npm update 또는 수동으로 버전을 수정합니다.\nnpm outdated npm update\r필요한 경우 직접 종속성 수정: package.json 파일에서 직접 오래된 패키지의 버전을 최신 버전으로 수정할 수도 있습니다.\n{ \"dependencies\": { \"glob\": \"^9.0.0\", \"inflight\": \"npm package로 교체하거나 직접 제거\" } }\r다시 설치: 종속성을 다시 설치합니다.\nrm -rf node_modules package-lock.json npm install\r파일 누락\rERROR render of \"taxonomy\" failed: \"/opt/buildhome/repo/node_modules/@hyas/core/layouts/_default/baseof.html:3:5\": execute of template failed: template: _default/terms.html:3:5: executing \"_default/terms.html\" at \u003cpartial \"head/head\" .\u003e: error calling partial: \"/opt/buildhome/repo/node_modules/@hyas/core/layouts/partials/head/head.html:15:8\": execute of template failed: template: partials/head/head.html:15:8: executing \"partials/head/head.html\" at \u003cpartial \"head/seo\" .\u003e: error calling partial: \"/opt/buildhome/repo/node_modules/@hyas/seo/layouts/partials/head/seo.html:1:4\": execute of template failed: template: partials/head/seo.html:1:4: executing \"partials/head/seo.html\" at \u003cpartial \"seo/_all\" .\u003e: error calling partial: \"/opt/buildhome/repo/node_modules/@hyas/seo/layouts/partials/seo/_all.html:9:4\": execute of template failed: template: partials/seo/_all.html:9:4: executing \"partials/seo/_all.html\" at \u003cpartial \"seo/opengraph\" .\u003e: error calling partial: \"/opt/buildhome/repo/node_modules/@hyas/seo/layouts/partials/seo/opengraph.html:7:15\": execute of template failed: template: partials/seo/opengraph.html:7:15: executing \"partials/seo/opengraph.html\" at \u003cpartial \"_funcs/get-page-images\" .\u003e: error calling partial: partial \"_funcs/get-page-images\" not found\r이 오류 메시지는 특정 템플릿 파일에서 사용되는 partial 파일이 누락되었거나 올바르게 설치되지 않았음을 나타냅니다.\n1. 누락된 partial 파일 확인 및 추가\rnode_modules/@hyas/seo/layouts/partials/seo/opengraph.html 파일에서 _funcs/get-page-images partial 파일을 찾을 수 없다고 합니다.\n_funcs/get-page-images.html 파일 추가\r다음과 같이 프로젝트의 layouts/partials/_funcs/get-page-images.html 경로에 파일을 추가해보세요:\n{{ $images := slice }} {{ if .Params.images }} {{ $images = .Params.images }} {{ end }} {{ return $images }}\rnode_modules/@hyas/seo/layouts/partials/seo/opengraph.html 파일의 참조 경로를 확인합니다.\n{{ $images = partial \"partials/_funcs/get-page-images\" . }}\r2. 템플릿 파일에서의 참조 수정\r필요한 partial 파일이 존재하지 않는다면, 템플릿 파일에서 해당 partial 파일의 참조를 주석 처리하거나 제거할 수 있습니다.\n예를 들어, node_modules/@hyas/seo/layouts/partials/seo/opengraph.html 파일을 수정할 수 있습니다:\n\u003c!-- node_modules/@hyas/seo/layouts/partials/seo/opengraph.html --\u003e {{/* partial \"_funcs/get-page-images\" . */}}\r3. 패키지 업데이트 및 재설치\rHyas 테마와 관련 패키지들을 최신 버전으로 업데이트하고 재설치합니다.\nrm -rf node_modules package-lock.json npm install\rMediaType Parsing\rError: error building site: \"/opt/buildhome/repo/content/docs/Deployment/Guide/Git 설정 기타.md:1:1\": \"/opt/buildhome/repo/node_modules/@hyas/images/layouts/_default/_markup/render-image.html:155:12\": execute of template failed: template: _default/_markup/render-image.html:155:12: executing \"_default/_markup/render-image.html\" at \u003c$r.MediaType.SubType\u003e: can't evaluate field MediaType in type string\rdoks theme - MediaType Parsing error 참조\nHUGO VERSION 에 대해 다음과 같이 설정 가능\n설정(Settings) 탭을 클릭합니다. 환경 변수 추가: 환경 변수(Environment variables) 섹션으로 이동합니다. 새로운 환경 변수를 추가하기 위해 “Add variable” 버튼을 클릭합니다. 다음과 같이 환경 변수를 설정합니다: Variable name: HUGO_VERSION Value: 0.127.0 빌드 재실행:\n환경 변수를 설정한 후, 변경 사항을 저장하고 빌드를 다시 실행합니다. ","nodejs-버전#node.js 버전":"","npm-패키지-문제#NPM 패키지 문제":""},"title":"에러"},"/docflow/deployment/guide/%EC%A4%84%EB%81%9D%EB%AC%B8%EC%9E%90-%EC%B2%98%EB%A6%AC%EA%B2%BD%EA%B3%A0/":{"data":{"":"","개요#개요":"","무시#무시":"개요\rgit add . 명령 시 다음과 같은 경고들이 발생할 수 있습니다.\nwarning: in the working copy of 'node_modules/@tabler/icons/icons/outline/building-factory.svg', LF will be replaced by CRLF the next time Git touches it warning: in the working copy of 'node_modules/@tabler/icons/icons/outline/building-fortress.svg', LF will be replaced by CRLF the next time Git touches it\r발생원인\rGit에서 발생하는 이 경고 메시지는 줄 끝 문자(Line Feed, LF)와 캐리지 리턴(Line Feed, CRLF)에 대한 차이로 인해 발생합니다. 다양한 운영 체제에서는 줄 끝 문자를 다르게 처리합니다.\nUnix 계열(OSX, Linux)에서는 줄 끝 문자가 LF(\\n)입니다. Windows에서는 줄 끝 문자가 CRLF(\\r\\n)입니다. 이 경고는 Git이 LF와 CRLF 사이의 변환을 수행할 것임을 나타냅니다. 이는 주로 core.autocrlf 설정에 의해 영향을 받습니다.\ncore.autocrlf 설정: true: 체크아웃 시 CRLF로 변환하고, 커밋 시 LF로 변환합니다. input: 체크아웃 시 변환하지 않지만, 커밋 시 LF로 변환합니다. false: 변환하지 않습니다. 해결방법\r전역 Git 설정 확인 및 변경: git config --global core.autocrlf true\r또는 LF를 유지하고 싶다면:\ngit config --global core.autocrlf input\r프로젝트별 Git 설정 변경: 프로젝트의 루트 디렉토리에서 설정을 변경할 수도 있습니다:\ngit config core.autocrlf true\r또는:\ngit config core.autocrlf input\r.gitattributes 파일 사용: 특정 파일에 대해 줄 끝 문자 변환을 제어할 수 있습니다. 프로젝트 루트에 .gitattributes 파일을 만들고 다음과 같이 설정할 수 있습니다:\n* text=auto *.svg text eol=lf\r이 방법을 통해 Git이 줄 끝 문자를 어떻게 처리할지 명확히 설정할 수 있으며, 경고 메시지를 피할 수 있습니다.\n무시\r경고 메시지를 무시하고 그대로 둬도 큰 문제가 발생하지는 않습니다. 그러나 몇 가지 주의사항이 있습니다:\n파일 일관성: 줄 끝 문자가 혼합된 파일을 여러 사람이 편집할 경우, 파일이 변경되지 않았더라도 줄 끝 문자가 변환되면서 파일이 변경된 것으로 인식될 수 있습니다. 이는 협업 시 혼란을 초래할 수 있습니다.\n빌드 및 테스트: 일부 빌드 도구나 테스트 도구는 줄 끝 문자의 일관성에 민감할 수 있습니다. 이 경우, 줄 끝 문자로 인해 빌드나 테스트가 실패할 수 있습니다.\n코드 리뷰: 코드 리뷰 시 변경된 줄 끝 문자로 인해 실제 코드 변경 사항을 파악하기 어려울 수 있습니다. 이는 코드 리뷰의 효율성을 떨어뜨릴 수 있습니다.\n하지만, 실질적으로 줄 끝 문자로 인해 코드의 기능에 직접적인 영향이 미치는 경우는 드뭅니다. 만약 프로젝트가 줄 끝 문자 변환으로 인한 문제를 겪지 않는다면, 경고 메시지를 무시하고 그대로 작업을 진행해도 괜찮습니다. 다만, 줄 끝 문자에 대한 일관된 정책을 세우고 이를 준수하는 것이 장기적으로는 더 바람직합니다.","발생원인#발생원인":"","해결방법#해결방법":""},"title":"줄끝문자 처리경고"},"/docflow/deployment/guide/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%B9%8C%EB%93%9C-%EC%84%A4%EC%A0%95-%EB%B3%80%EA%B2%BD/":{"data":{"":"","#":"Hugo 사이트를 로컬에서 빌드할 때와 클라우드에서 빌드할 때 서로 다른 설정을 사용하고 싶다면, hugo.toml 파일을 직접 수정하지 않고 환경 변수 또는 Hugo 플래그를 사용할 수 있습니다. 이를 통해 특정 설정을 동적으로 적용할 수 있습니다.\n방법 1: Hugo 환경 변수 사용\rHugo는 특정 환경 변수에 따라 동작을 변경할 수 있습니다. 로컬에서는 별도의 환경 변수를 설정하지 않고, 클라우드에서만 환경 변수를 설정하도록 합니다.\n1.1 로컬에서 Hugo 빌드\r로컬에서는 기존의 hugo.toml 설정을 그대로 사용하면 됩니다.\n1.2 클라우드플레어에서 환경 변수 설정\r클라우드플레어의 빌드 설정에서 환경 변수를 추가합니다.\n클라우드플레어 대시보드에서 Workers \u0026 Pages \u003e Pages로 이동합니다. 배포 설정에서 Environment variables 섹션으로 이동합니다. 필요한 환경 변수를 추가합니다. 예를 들어, HUGO_ENV 변수를 추가하여 클라우드에서 다른 설정을 적용할 수 있습니다. HUGO_ENV=production"},"title":"클라우드 빌드 설정 변경"},"/docflow/deployment/guide/%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%88%84%EB%9D%BD/":{"data":{"":"","개요#개요":"","발생-원인#발생 원인":"","서브모듈-관리#서브모듈 관리":"개요\r클라우드플레어 Pages에서 Hugo 사이트 빌드 시 일부 페이지가 누락되는 문제가 발생할 수 있습니다.\n발생 원인\r콘텐츠 디렉토리를 특정 경로에 마운트하여 사용하는 경우 발생합니다. 로컬 빌드시에는 마운트가 정상적으로 동작하므로 문제가 되지 않지만, GitHub에 푸시할 때 해당 콘텐츠 디렉토리는 비어있으므로 클라우드플레어 Pages에서 빌드할 때도 포함되지 않습니다.\n해결 방안\r콘텐츠 디렉토리를 Git 서브모듈로 추가 콘텐츠 디렉토리를 별도의 리포지토리로 관리하고 메인 리포지토리에 서브모듈로 포함시켜 관리 콘텐츠 디렉토리를 직접 복사하여 포함 로컬에서 콘텐츠 디렉토리를 메인 리포지토리에 복사하여 GitHub에 푸시 서브모듈 관리\r서브 모듈 추가\r콘텐츠 리포지토리를 별도로 생성 GitHub에서 새로운 리포지토리를 생성하여 콘텐츠를 관리합니다. 예를 들어, docflow라는 리포지토리를 생성합니다. 로컬에서 콘텐츠 리포지토리 초기화 및 푸시 로컬 콘텐츠 디렉토리를 콘텐츠 리포지토리로 초기화하고 푸시합니다. cd docflow git init git remote add origin https://github.com/aprofl/docflow.git git add . git commit -m \"Initial commit for content repository\" git push origin master\r메인 프로젝트에 서브모듈로 콘텐츠 리포지토리 추가 메인 프로젝트 디렉토리로 이동하여 콘텐츠 리포지토리를 서브모듈로 추가합니다 cd docflow_hugo # 기존 content 디렉토리 제거 rd /s /q content git rm -r --cached content git commit -m \"Remove existing content directory\" git push origin master # 서브모듈로 content 디렉토리 추가 git submodule add https://github.com/aprofl/docflow.git content git submodule init git submodule update git add .gitmodules content git commit -m \"Add content as a submodule\" git push origin master\r서브모듈 정보 커밋 및 푸시 서브모듈 정보를 포함하여 메인 프로젝트를 커밋하고 푸시합니다. git add .gitmodules content git commit -m \"Add content as a submodule\" git push origin master\r변경 사항 푸시 순서\r콘텐츠 리포지토리에 변경 사항이 있을 경우, 해당 리포지토리를 먼저 업데이트하고 푸시합니다. cd docflow git add . git commit -m \"Update content\" git push origin master\r메인 프로젝트 디렉토리로 이동하여 서브모듈을 최신화합니다. cd docflow_hugo git submodule update --remote content\r서브모듈 최신화를 반영하여 메인 프로젝트를 커밋하고 푸시합니다 git add content git commit -m \"Update submodule to latest version\" git push origin master\r푸시 자동화\r개요\rGitHub Actions을 이용한 푸시 자동화 방법입니다. 컨텐츠프로젝트가 푸시되면 깃 허브에서 메인프로젝트에 서브모듈을 업데이트 하고, 자동으로 푸시합니다. 깃허브 설정\r메인프로젝트의 다음 설정을 변경합니다. Settings \u003e Actions \u003e General 로 이동하여 다음 항목을 변경하고, Save 합니다. Workflow permissions Read and write permissions Access Accessible from repositories owned by the user ‘aprofl’ GitHub Personal Access Token 생성 및 시크릿 설정 방법\rPersonal Access Token 생성 GitHub 프로필 아이콘을 클릭하고 “Settings\"로 이동합니다. 좌측 사이드바에서 “Developer settings\"를 클릭합니다. “Personal access tokens” 메뉴에서 “Fine-grained personal access tokens\"를 클릭한 후 “Generate new token” 버튼을 클릭합니다. 토큰에 필요한 권한을 설정합니다. (예: repo, workflow) “Generate token” 버튼을 클릭하여 토큰을 생성하고, 생성된 토큰을 복사해 둡니다. 토큰 설정 Repository permissions: Contents: Read and write Metadata: Read-only Workflows: Read and write 유효 기간은 최대 1년까지 설정 가능합니다. “Generate token” 버튼을 클릭하여 토큰을 생성하고, 생성된 토큰을 복사합니다. 토큰을 시크릿으로 추가 GitHub 리포지토리 페이지에서 “Settings” 탭으로 이동합니다. 좌측 사이드바에서 “Secrets and variables\"을 클릭한 후 “Actions\"를 클릭합니다. “New repository secret” 버튼을 클릭합니다. Name에 PERSONAL_ACCESS_TOKEN을 입력하고, Secret에 복사한 토큰 값을 입력한 후 “Add secret” 버튼을 클릭합니다. GitHub Actions 설정\rGitHub Actions 워크플로우 파일 생성 컨텐츠 프로젝트 루트에 .github/workflows/deploy.yml 파일을 생성합니다. name: Update main project and trigger build on: push: branches: - master jobs: update_main_project: runs-on: ubuntu-latest steps: - name: Checkout content repository uses: actions/checkout@v2 - name: Print token (for debugging, remove after use) run: echo \"${{ secrets.PERSONAL_ACCESS_TOKEN }}\" - name: Checkout main project repository uses: actions/checkout@v2 with: repository: aprofl/aprofl token: ${{ secrets.PERSONAL_ACCESS_TOKEN }} path: docflow_hugo - name: Configure Git run: | git config --global user.email \"tjsufl@gmail.com\" git config --global user.name \"aprofl\" - name: Initialize submodules with token run: | cd docflow_hugo git submodule update --init --recursive git submodule foreach --recursive \"git config --global url.\\\"https://${{ secrets.PERSONAL_ACCESS_TOKEN }}@github.com\\\".insteadOf \\\"https://github.com\\\"\" - name: Update submodule URL to use token run: | cd docflow_hugo git config submodule.content.url https://${{ secrets.PERSONAL_ACCESS_TOKEN }}@github.com/aprofl/docflow.git - name: Update content submodule in main project env: GITHUB_TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }} run: | cd docflow_hugo git submodule update --remote content git add content git commit -m \"Update content submodule to latest version\" git push origin master 상세 설명\r이벤트 트리거 master 브랜치에 푸시가 발생하면 이 워크플로우가 트리거됩니다. 작업 설정 GitHub Actions가 ubuntu-latest 환경에서 실행됩니다. 단계별 설정 콘텐츠 리포지토리 체크아웃: actions/checkout@v2를 사용하여 콘텐츠 리포지토리를 체크아웃합니다. 메인 프로젝트 리포지토리 체크아웃: actions/checkout@v2를 사용하여 메인 프로젝트 리포지토리를 docflow_hugo 경로에 체크아웃합니다. 서브모듈 업데이트: docflow_hugo 디렉토리로 이동하여 서브모듈을 최신 버전으로 업데이트하고, 이를 커밋 및 푸시합니다. 클라우드플레어 설정 업데이트\rCloudflare Pages 설정에서 GITHUB_TOKEN을 사용하도록 설정합니다.\nCloudflare Pages 설정: Cloudflare Pages의 프로젝트 설정으로 이동합니다. Environment Variables 섹션에서 GITHUB_TOKEN 변수를 추가합니다. 변수 이름: GITHUB_TOKEN 변수 값: GitHub Personal Access Token\n서브모듈 URL 업데이트\r서브모듈의 URL을 인증 정보를 포함한 형태로 변경합니다.\n메인 프로젝트의 .gitmodules 파일 수정: [submodule \"content\"] path = content url = https://\u003cyour_token\u003e@github.com/aprofl/docflow.git\rGit 설정 파일 업데이트\rWindows 명령 프롬프트에서 서브모듈 URL을 인증 정보를 포함한 형태로 설정합니다.\ncd docflow_hugo git submodule deinit -f --all git submodule update --init --recursive git submodule foreach --recursive \"git config submodule.$name.url https://\u003cyour_token\u003e@github.com/aprofl/$name.git\" git submodule update --init --recursive\r점검 사항\rGitHub Actions 워크플로우가 올바르게 트리거되지 않거나, 메인 프로젝트가 제대로 푸시되지 않는 경우 다음의 내용을 확인합니다.\nGitHub Actions 로그 확인\nGitHub 리포지토리의 “Actions” 탭에서 워크플로우가 제대로 실행되었는지 확인합니다. 오류 메시지나 실패한 단계가 있는지 확인합니다. 서브모듈 설정 확인: 메인 프로젝트에서 서브모듈이 올바르게 설정되어 있는지 확인합니다.\nGitHub Actions 파일 위치 확인: .github/workflows/deploy.yml 파일이 올바른 위치에 있는지 확인합니다.\n권한 확인: GITHUB_TOKEN이 제대로 작동하고 있는지, 리포지토리에 대한 쓰기 권한이 있는지 확인합니다.","해결-방안#해결 방안":""},"title":"페이지 누락"},"/docflow/deployment/guide/api-%ED%86%A0%ED%81%B0/":{"data":{"":"클라우드플레어의 API 토큰은 클라우드플레어 대시보드에서 생성하고 관리할 수 있습니다. 다음은 클라우드플레어 API 토큰을 생성하고 확인하는 방법입니다.\n프로필로 이동: 화면 오른쪽 상단의 계정 아이콘을 클릭하고, “My Profile\"을 선택합니다. API Tokens 탭 선택: 프로필 페이지에서 “API Tokens” 탭을 클릭합니다. API 토큰 생성: “Create Token” 버튼을 클릭하여 새로운 API 토큰을 생성합니다. API 토큰 템플릿 선택: 필요에 따라 “Edit Cloudflare Pages\"와 같은 적절한 템플릿을 선택하거나, “Custom Token\"을 선택하여 사용자 정의 설정을 구성할 수 있습니다. 권한 설정: Custom Token을 선택한 경우: Permissions: 권한을 설정합니다. 예를 들어, “Account\"에서 “Cloudflare Pages\"에 대한 “Edit” 권한을 부여합니다. Zone Resources: 특정 존에 대한 권한을 설정하거나 모든 존에 대한 권한을 부여합니다. API 토큰 생성:\n“Continue to summary” 버튼을 클릭하여 설정을 검토한 후, “Create Token” 버튼을 클릭하여 토큰을 생성합니다. API 토큰 확인 및 복사:\n생성된 API 토큰이 화면에 표시됩니다. 이 토큰을 복사하여 안전한 장소에 저장합니다. 한 번 생성된 후에는 다시 확인할 수 없으므로 반드시 복사해 두어야 합니다. "},"title":"api 토큰"},"/docflow/deployment/guide/baseurl-%ED%98%BC%EC%9A%A9/":{"data":{"":"","동적-설정#동적 설정":"첫 배포시 baseURL 문제로 page 참조가 안될 수 있습니다. config/_default/hugo.toml 파일의 다음 설정을 확인합니다.\nbaseURL = \"http://localhost\"\r위 항목을 CloudFlare page 주소로 변경합니다.\n동적 설정\rbaseURL 설정이 로컬과 배포 환경에서 다르면, 각각의 환경에서 URL을 다르게 설정해야 하는 문제가 발생합니다. 이를 해결하기 위해 Hugo는 여러 환경에 맞춰 baseURL을 동적으로 설정할 수 있는 방법을 제공합니다.\n1. 로컬 서버 실행 시 baseURL 설정\rconfig/_default/hugo.toml 파일의 다음 설정을 확인합니다.\nbaseURL = \"https://aprofl.pages.dev/\"\r로컬 빌드\r로컬빌드가 되지 않는 경우, 다음과 같이 baseURL 을 지정하여 실행합니다. hugo server --baseURL=\"localhost:1313\" --ignoreCache\r배포 빌드\r배포빌드 시에는 baseURL의 설정값을 따라갑니다.\n방법 2. 환경 변수 사용\rHugo는 환경 변수를 사용하여 baseURL을 설정할 수 있습니다. 이렇게 하면 로컬 환경과 배포 환경에서 다른 baseURL을 사용할 수 있습니다.\nconfig.toml 파일 수정\rconfig.toml 파일을 다음과 같이 수정합니다:\nbaseURL = \"{{ .Env.BASE_URL | default 'http://localhost:1313/' }}\"\r이제 로컬에서 Hugo를 실행할 때는 기본값이 http://localhost:1313/가 됩니다.\n로컬 빌드\r로컬에서 Hugo를 빌드하거나 서버를 실행할 때는 환경 변수를 설정하지 않고 다음과 같이 실행합니다\nhugo server\r배포 빌드\rCloudflare Pages에서 빌드할 때는 환경 변수를 설정합니다. Cloudflare Pages 대시보드에서 환경 변수를 설정할 수 있습니다:\nVariable name: BASE_URL Value: https://aprofl.pages.dev/ 이렇게 하면 Cloudflare Pages에서 빌드할 때 baseURL이 https://aprofl.pages.dev/로 설정됩니다.\n방법 3: Hugo의 구성 파일 분리\rHugo는 여러 구성 파일을 지원하므로, 환경별로 다른 구성 파일을 사용할 수 있습니다. 예를 들어, config.toml 외에 config.production.toml 파일을 추가할 수 있습니다.\n`config.production\rbaseURL = \"https://aprofl.pages.dev/\"\r로컬 빌드\r로컬에서 Hugo를 빌드하거나 서버를 실행할 때는 기본 구성 파일을 사용합니다:\nhugo server\r배포 빌드\rCloudflare Pages에서 배포할 때는 HUGO_ENV 환경 변수를 설정합니다:\nVariable name: HUGO_ENV Value: production Cloudflare Pages는 production 환경에서 자동으로 config.production.toml 파일을 사용하게 됩니다.\n방법 4: Hugo 플래그 사용\rHugo를 실행할 때 --baseURL 플래그를 사용하여 동적으로 baseURL을 설정할 수도 있습니다.\n로컬 빌드\r로컬에서 Hugo 서버를 실행할 때 기본값을 사용합니다:\nhugo server\r배포 빌드\rCloudflare Pages에서 빌드 명령어를 다음과 같이 설정합니다:\nhugo --baseURL https://aprofl.pages.dev/\r이 방법은 Cloudflare Pages 대시보드에서 Build command를 수정하여 설정할 수 있습니다."},"title":"baseURL 혼용"},"/docflow/deployment/guide/cloud-flare-%EA%B2%8C%EC%8B%9C/":{"data":{"":"","5-github-actions-설정-선택-사항#5. GitHub Actions 설정 (선택 사항)":"","cloudflare-pages-설정#Cloudflare Pages 설정":"","github-secrets-설정#GitHub Secrets 설정":"Cloudflare Pages 설정\rCloudflare 계정에 로그인: Cloudflare 계정에 로그인합니다. 계정이 없으면 여기서 계정을 만드세요. Cloudflare Pages로 이동: Cloudflare 대시보드에 로그인한 후, 왼쪽 사이드바에서 “Workers \u0026 Pages\"를 클릭합니다. Pages 탭을 선택합니다. Git 저장소 연결: “Connect to Git” 버튼을 클릭하여 GitHub 또는 GitLab 계정에 연결합니다. 이 과정에서 Cloudflare가 저장소에 접근할 수 있도록 권한을 부여해야 합니다. 저장소 선택: 연결된 Git 계정에서 배포할 저장소를 선택합니다. 해당 저장소를 선택하면 Cloudflare Pages가 자동으로 프로젝트를 설정합니다. 배포 설정\r브랜치 선택:\n배포할 브랜치를 선택합니다. 기본적으로 main 또는 master 브랜치를 선택할 수 있습니다. 빌드 설정:\n빌드 설정을 구성합니다. 이는 프로젝트의 빌드 명령어와 배포 디렉토리(예: npm run build 및 public 디렉토리)를 포함합니다. 일반적인 설정 예시는 다음과 같습습니다. Build command: npm run build 또는 프로젝트의 빌드 명령어를 입력합니다. Build output directory: public 또는 빌드된 파일이 위치할 디렉토리를 입력합니다. 환경 변수 설정 (선택 사항):\n필요한 경우, 환경 변수를 설정합니다. 예를 들어, API 키나 기타 설정 값을 추가할 수 있습니다. 배포 시작:\n설정이 완료되면 “Save and Deploy” 버튼을 클릭하여 배포를 시작합니다. 도메인 설정\rCloudflare에서 도메인을 설정하여 맞춤 도메인을 사용할 수 있습니다.\nCloudflare 계정에 도메인 추가: Cloudflare 계정에 로그인하여 도메인을 추가하고, 네임서버를 Cloudflare 네임서버로 변경합니다. DNS 설정: Cloudflare 대시보드에서 DNS 설정으로 이동하여 새로운 CNAME 레코드를 추가합니다. 이름은 www로, 값은 Cloudflare Pages의 서브도메인 (예: your-site.pages.dev)으로 설정합니다. SSL/TLS 설정: SSL/TLS 설정에서 “Full” 또는 “Full (strict)“을 선택하여 사이트가 HTTPS로 제공되도록 설정합니다. 5. GitHub Actions 설정 (선택 사항)\r매번 Hugo 사이트를 변경할 때 자동으로 Cloudflare Pages에 배포되도록 GitHub Actions를 설정할 수 있습니다.\n.github/workflows/deploy.yml 파일을 생성합니다.\nname: Deploy Hugo site to Cloudflare Pages on: push: branches: - master jobs: build: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v2 - name: Install Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' - name: Build site run: hugo - name: Deploy to Cloudflare Pages uses: cloudflare/pages-action@v1 with: apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }} accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }} projectName: your-project-name directory: ./public\r이 설정 파일은 GitHub Actions가 Hugo 사이트를 빌드하고, Cloudflare Pages에 배포합니다. Cloudflare API 토큰, 계정 ID, 프로젝트 이름을 GitHub Secrets에 저장해야 합니다.\nGitHub Secrets 설정\rGitHub 리포지토리 설정에서 Secrets를 추가합니다.\nCLOUDFLARE_API_TOKEN: Cloudflare에서 생성한 API 토큰 CLOUDFLARE_ACCOUNT_ID: Cloudflare 계정 ID CLOUDFLARE_PROJECT_NAME: Cloudflare Pages 프로젝트 이름 이 설정을 완료하면 GitHub Actions가 자동으로 Hugo 사이트를 빌드하고 Cloudflare Pages에 배포합니다.\n모든 설정이 완료되면, Hugo 사이트가 GitHub과 연동되어 Cloudflare에 성공적으로 게시됩니다.","도메인-설정#도메인 설정":""},"title":"Cloud Flare 게시"},"/docflow/deployment/guide/cloudflare-%EB%8B%A8%EC%A0%90%EC%97%90-%EB%8C%80%ED%95%B4/":{"data":{"":"","cloudflare와-서버리스-기능#Cloudflare와 서버리스 기능":"","서버리스-기능-사용-예시#서버리스 기능 사용 예시":"요약\r단순 블로그 배포 시에는 서버리스 기능이 많이 필요하지 않습니다. Cloudflare Pages는 정적 사이트를 배포하는 데 매우 적합하며, 필요한 경우 Cloudflare Workers를 사용하여 서버리스 기능을 확장할 수 있습니다. 로그인 기능이 없고, 댓글 시스템을 고려하고 있다면 외부 서비스나 간단한 Cloudflare Workers 기능으로 충분히 구현할 수 있습니다. 따라서, Cloudflare Pages를 통해 블로그를 배포하는 것은 매우 효율적이고, 추가 서버리스 기능이 필요할 때는 Cloudflare Workers를 통해 보완할 수 있습니다.\nCloudflare와 서버리스 기능\rCloudflare는 기본적으로 정적 사이트 배포에 최적화되어 있습니다. 서버리스 기능이 부족하다는 점이 언급되었지만, Cloudflare Workers를 통해 서버리스 기능을 추가할 수 있습니다.\nCloudflare Workers\r기능\rCloudflare Workers는 Cloudflare의 서버리스 컴퓨팅 플랫폼으로, JavaScript, Rust, C, C++, Python 등의 언어를 사용하여 서버리스 코드를 작성할 수 있습니다. 사용\r간단한 API를 만들거나, 댓글 기능, 데이터 처리 등 다양한 서버리스 작업을 처리할 수 있습니다. 통합\rCloudflare Pages와 쉽게 통합되어 추가 서버리스 기능을 제공할 수 있습니다. 서버리스 기능 사용 예시\r댓글 시스템\r댓글 시스템을 구현하는 방법에는 여러 가지가 있습니다:\n외부 서비스 사용: Disqus, Commento, Staticman 같은 외부 댓글 시스템을 사용하면 별도의 서버리스 기능이 필요 없습니다. 이들은 위젯을 통해 쉽게 블로그에 통합할 수 있습니다. Custom Serverless Function: Cloudflare Workers를 사용하여 자체 댓글 시스템을 구현할 수도 있습니다. 이 경우, Workers KV 등을 이용하여 데이터를 저장하고 처리할 수 있습니다. 폼 처리\r독자들이 이메일 구독, 연락처 폼 등을 제출할 수 있게 하려면 서버리스 함수가 필요합니다.\n폼 서비스: Formspree, Netlify Forms 등의 외부 서비스를 사용하여 폼 데이터를 처리할 수 있습니다. Cloudflare Workers: 폼 데이터를 받아 처리하는 서버리스 함수를 작성하여 Cloudflare Workers에 배포할 수 있습니다. ","요약#요약":""},"title":"cloudflare 단점에 대해"},"/docflow/deployment/guide/git-%EC%84%A4%EC%A0%95-%EA%B8%B0%ED%83%80/":{"data":{"":"","public-폴더-포함#Public 폴더 포함":"Public 폴더 포함\rCloudflare Pages는 소스 코드를 GitHub 저장소에서 직접 가져와 빌드 및 배포를 수행합니다. public 폴더는 일반적으로 Hugo와 같은 정적 사이트 생성기에서 생성된 빌드 출력물로, 로컬 빌드 결과를 포함하고 있습니다. 그러나 Cloudflare Pages는 자체적으로 소스를 빌드하기 때문에, 일반적으로 public 폴더를 GitHub에 푸시할 필요가 없습니다.\nPublic 폴더 제외\r.gitignore 파일 생성 또는 수정\r터미널(예: Command Prompt, PowerShell) 또는 파일 탐색기에서 로컬 리포지토리 디렉토리로 이동합니다. .gitignore 파일 열기 또는 생성: 텍스트 편집기(예: Notepad)를 사용하여 .gitignore 파일을 엽니다. 파일이 없는 경우 새로 생성합니다. 확장자는 없습니다. notepad .gitignore\rpublic 폴더 추가: .gitignore 파일에 public/을 추가하여 public 폴더와 그 안의 모든 파일을 무시하도록 설정합니다. public/\r변경 사항을 저장하고 파일을 닫습니다. 이미 추적 중인 public 폴더 무시하기\r만약 public 폴더가 이미 Git에 의해 추적되고 있는 경우, .gitignore 파일을 수정하는 것만으로는 충분하지 않습니다. 기존의 추적 정보를 제거해야 합니다.\n# `public` 폴더 캐시에서 제거: git rm -r --cached public/ # 변경 사항 커밋 git add .gitignore git commit -m \"Update .gitignore to exclude public folder\" # 원격 리포지토리에 푸시 git push origin master"},"title":"Git 설정 기타"},"/docflow/deployment/guide/git-%EC%84%A4%EC%A0%95/":{"data":{"":"","github-리포지토리-생성-및-hugo-사이트-푸시#GitHub 리포지토리 생성 및 Hugo 사이트 푸시":"","로컬-git-저장소-설정#로컬 Git 저장소 설정":"","인증#인증":"로컬 Git 저장소 설정\rHugo 사이트 디렉토리에서 Git 저장소를 초기화하고 첫 번째 커밋을 만듭니다.\n# Git 저장소 초기화 git init # 모든 파일을 스테이지에 추가 git add . # 초기 커밋 git commit -m \"Initial commit\"\rGitHub 리포지토리 생성 및 Hugo 사이트 푸시\rGitHub에 새 리포지토리를 생성합니다. 그런 다음, 로컬 Hugo 사이트를 해당 리포지토리에 푸시합니다.\n# 원격 저장소 추가 git remote add origin https://github.com/YOUR_USERNAME/YOUR_REPOSITORY_NAME.git # 원격 저장소로 푸시 git push -u origin master\r인증\rgit push -u origin master warning: could not find UI helper 'GitHub.UI' Select an authentication method for 'https://github.com/': 1. Web browser (default) 2. Device code 3. Personal access token option (enter for default):\r이 경고 메시지는 GitHub에서 인증을 요구하는 경우 발생합니다. 아래 단계에 따라 인증을 완료할 수 있습니다:\nWeb Browser (기본 옵션): 기본 옵션은 웹 브라우저를 통해 인증하는 것입니다. 브라우저가 열리면 GitHub 계정에 로그인하고 인증 절차를 따르세요. 인증이 완료되면 GitHub로부터 터미널로 돌아와서 푸시가 완료됩니다. Device Code: GitHub는 인증에 사용할 기기 코드를 제공합니다. 브라우저에서 GitHub 기기 코드 인증 페이지(예: https://github.com/login/device)로%EB%A1%9C) 이동하여 기기 코드를 입력하고 인증 절차를 따르세요. 인증이 완료되면 터미널로 돌아와서 푸시가 완료됩니다. Personal Access Token: GitHub에서 생성한 개인 액세스 토큰(Personal Access Token)을 입력하세요. 토큰을 생성하려면 GitHub 설정에서 Developer settings \u003e Personal access tokens으로 이동하세요. 새로운 토큰을 생성하고, repo 권한을 포함한 필요한 권한을 부여하세요. 생성된 토큰을 복사하여 터미널에 입력하고 Enter 키를 누르세요. "},"title":"Git 설정"},"/docflow/deployment/guide/git-%EC%97%90%EB%9F%AC/":{"data":{"":"\n이 오류 메시지는 Git이 현재 디렉토리의 소유자가 신뢰할 수 없는 사용자라고 인식했기 때문에 발생합니다. 이는 보안상의 이유로 발생하는 경고입니다. 이를 해결하려면 해당 디렉토리를 신뢰할 수 있는 디렉토리로 설정해야 합니다.\n오류 메시지에 제시된 명령어를 사용하여 디렉토리를 안전한 디렉토리로 추가하면 됩니다:\ngit config --global --add safe.directory D![git_sefe_directory.png](/Resources/git_sefe_directory.png) 작업을 계속 진행할 수 있습니다."},"title":"Git 에러"},"/docflow/deployment/guide/github-pages/%EB%B0%B0%ED%8F%AC-%EB%B0%A9%EC%8B%9D/":{"data":{"":"","docs-디렉토리-방식#\u003ccode\u003edocs\u003c/code\u003e 디렉토리 방식":"배포 방법 선택\rGitHub Pages로 배포하기 위해 두 가지 방법 중 하나를 선택할 수 있습니다: gh-pages 브랜치를 사용하는 방법과 docs 디렉토리를 사용하는 방법입니다. 배포 방법을 선택할 때 고려할 사항을 요약하면 다음과 같습니다.\n독립된 브랜치 관리 gh-pages 브랜치를 사용하면 빌드 결과물과 소스 코드를 분리하여 관리할 수 있습니다. 이는 대규모 프로젝트나 복잡한 배포 파이프라인을 사용하는 경우 유용합니다. 간편한 설정 docs 폴더를 사용하는 방법은 설정이 간단하며, 작은 규모의 프로젝트나 개인 블로그와 같은 단순한 사이트에 적합합니다. 이 방법은 별도의 브랜치를 관리할 필요가 없습니다. gh-pages 브랜치 방식\rgh-pages 브랜치의 의미\rgh-pages 브랜치는 GitHub Pages에서 제공하는 기능 중 하나로, 브랜치를 사용하여 웹사이트를 호스팅할 수 있습니다. 이 브랜치를 사용하면 Hugo나 다른 정적 사이트 생성기로 생성된 사이트를 별도의 브랜치로 관리할 수 있습니다.\n주요 특징\r독립된 브랜치 gh-pages 브랜치는 사이트의 빌드 결과물만을 포함하는 독립된 브랜치입니다. 주 브랜치(master 또는 main)와 분리되어 있어, 원본 소스코드와 빌드 결과물을 명확히 구분할 수 있습니다. 자동 배포 이 브랜치에 푸시된 내용은 GitHub Pages에서 자동으로 인식하여 배포합니다. 별도의 설정 없이 웹사이트가 호스팅됩니다. 정리된 파일 구조 주 브랜치에는 소스 코드만 남기고, 빌드된 파일은 gh-pages 브랜치로 푸시하여 파일 구조를 깔끔하게 유지할 수 있습니다. gh-pages 브랜치 사용\rGit 초기화\rGit을 초기화하고, 원격 저장소를 설정합니다. # 새로운 Git 저장소 초기화 git init # 원격 저장소 추가 git remote add origin https://github.com/USER_NAME/USER_NAME.github.io.git 필요한 파일들을 커밋하고 원격 저장소에 푸시합니다. git add . git commit -m \"Initial commit\" git push -u origin master\rgh-pages 브랜치 초기화\r최초 1회만 실행합니다. gh-pages 브랜치를 생성합니다. 이 단계에서는 public 디렉토리를 비워두는게 좋습니다. # gh-pages 브랜치 생성 git checkout --orphan gh-pages # `.git` 폴더를 제외한 모든 파일 제거 Get-ChildItem -Exclude \".git\" | Remove-Item -Recurse -Force # 빈 커밋 생성 git commit --allow-empty -m \"Initialize new gh-pages branch\" git push origin gh-pages git checkout master\rGitHub Actions를 사용한 자동 배포\r자동으로 Hugo 사이트를 빌드하고 GitHub Pages로 배포하려면 GitHub Actions를 사용할 수 있습니다.\n.github/workflows 디렉토리를 생성하고, deploy.yml 파일을 추가합니다. deploy.yml 파일에 다음 내용을 추가합니다. name: Deploy Hugo site to GitHub Pages on: push: branches: - master jobs: build: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v2 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: '0.127.0' # 로컬에서 사용하는 Hugo 버전으로 설정 - name: Build run: hugo --minify --ignoreCache - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public publish_branch: gh-pages\rmaster 브랜치에 커밋이 푸시될 때마다 Hugo 사이트를 빌드하고, 빌드된 결과물을 gh-pages 브랜치에 푸시하는 역할을 수행합니다.\n저장소의 코드를 체크아웃합니다. 최신 버전의 Hugo를 설정합니다. Hugo를 사용하여 사이트를 빌드하고 결과물을 public 디렉토리에 저장합니다. public 디렉토리의 내용을 gh-pages 브랜치에 푸시하여 GitHub Pages에 배포합니다. 이 파일을 커밋하고 푸시합니다.\ngit add .github/workflows/deploy.yml git commit -m \"Add GitHub Actions workflow for deploying to GitHub Pages\" git push origin master\rGitHub Pages 설정\rGitHub 저장소의 설정(Settings)에서 GitHub Pages 섹션으로 이동하여, Source를 gh-pages 브랜치로 설정합니다. 저장소의 Settings로 이동합니다. 왼쪽 사이드바에서 Pages를 클릭합니다. Source 드롭다운 메뉴에서 Deply from a branch 를 선택합니다. Branch 메뉴에서 gh-pages를 선택합니다. Save 버튼을 클릭하여 설정을 저장합니다. docs 디렉토리 방식\rdocs 폴더의 의미와 커밋의 의미\rdocs 폴더를 사용하여 GitHub Pages로 배포하는 방법은 GitHub 저장소의 루트 디렉토리에 빌드된 파일을 포함하지 않으면서도 GitHub Pages 기능을 활용할 수 있는 방법입니다.\n주요 특징\r루트 디렉토리 외부에 배포 docs 폴더는 저장소의 루트 디렉토리에 위치하지만, GitHub Pages는 이 폴더 내의 파일을 배포합니다. 이는 주 브랜치(master 또는 main) 내에서 빌드 결과물을 포함할 수 있는 방법입니다. 간단한 설정 config.toml 파일에서 publishDir 설정을 통해 Hugo가 빌드된 파일을 docs 폴더에 저장하도록 할 수 있습니다. 이를 통해 GitHub Pages 설정에서 docs 폴더를 지정하면 별도의 브랜치를 사용하지 않고도 사이트를 배포할 수 있습니다. 커밋의 의미 docs 폴더에 빌드된 파일을 커밋하고 푸시하면, GitHub Pages는 이 폴더의 내용을 인식하여 웹사이트를 업데이트합니다. 이는 gh-pages 브랜치를 사용하는 것과 동일한 효과를 가집니다. docs 디렉토리 사용\rHugo 사이트를 docs 디렉토리에 빌드하도록 설정합니다. config.toml 파일을 수정하여 다음과 같이 설정합니다. publishDir = \"docs\"\rHugo 사이트를 다시 빌드합니다. hugo\rdocs 디렉토리를 커밋하고 푸시합니다. git add docs git commit -m \"Deploy to GitHub Pages using docs directory\" git push origin master\rGitHub 저장소 설정에서 GitHub Pages 설정을 docs 디렉토리로 지정합니다. GitHub Actions를 사용한 자동 배포\r자동으로 Hugo 사이트를 빌드하고 GitHub Pages로 배포하려면 GitHub Actions를 사용할 수 있습니다.\n.github/workflows 디렉토리를 생성하고, gh-pages.yml 파일을 추가합니다. mkdir -p .github/workflows touch .github/workflows/gh-pages.yml\rgh-pages.yml 파일에 다음 내용을 추가합니다. name: Deploy Hugo site to GitHub Pages on: push: branches: - master # 또는 메인 브랜치 이름이 다른 경우, 해당 브랜치 이름을 사용하세요 jobs: build: runs-on: ubuntu-latest steps: - name: Checkout repository uses: actions/checkout@v2 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' - name: Build run: hugo --destination docs - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./docs publish_branch: master\r이 파일을 커밋하고 푸시합니다. git add .github/workflows/deploy.yml git commit -m \"Add GitHub Actions workflow for deploying to GitHub Pages\" git push origin master","gh-pages-브랜치-방식#\u003ccode\u003egh-pages\u003c/code\u003e 브랜치 방식":"","배포-방법-선택#배포 방법 선택":""},"title":"배포 방식"},"/docflow/deployment/guide/github-pages/preperation/":{"data":{"":"","#":"Hugo 사이트를 빌드합니다. 기본적으로 public 디렉토리에 빌드 결과가 생성됩니다.\n2. GitHub Pages 설정\rGitHub Pages를 사용하여 사이트를 호스팅하기 위해서는 GitHub에 저장소를 만들어야 합니다.\nGitHub에서 새로운 저장소를 생성합니다. 저장소 이름을 username.github.io로 설정합니다. 여기서 username은 GitHub 사용자 이름입니다. 사용자 페이지 vs 프로젝트 페이지\r사용자 페이지\r사용자 페이지는 GitHub 사용자 이름에 따라 고유한 도메인을 갖게 됩니다. 이는 하나의 고유한 웹사이트로 사용되며, 저장소 이름은 다음과 같은 형식을 따라야 합니다:\n형식: username.github.io 예시: 사용자가 aprofl인 경우, 저장소 이름은 aprofl.github.io 프로젝트 페이지\r프로젝트 페이지는 특정 프로젝트에 대한 웹사이트를 제공할 때 사용됩니다. 프로젝트 페이지는 여러 개 만들 수 있으며, 저장소 이름은 자유롭게 설정할 수 있습니다. 그러나 프로젝트 페이지를 사용하기 위해서는 gh-pages 브랜치를 설정해야 합니다."},"title":"Preperation"},"/docflow/distribution/about/%EB%A7%A4%EB%89%B4%EC%96%BC-%EC%A2%85%EB%A5%98/":{"data":{"":"","1-html-파일#1. HTML 파일":"","2-epub#2. ePub":"","3-전자책-ebook#3. 전자책 (eBook)":"","4-설치-가능한-데스크톱-애플리케이션-staticsite-manualstaticsite20manualmd#4. 설치 가능한 데스크톱 애플리케이션 (\u003ca href=\"StaticSite%20Manual.md\"\u003eStaticSite Manual\u003c/a\u003e)":"","5-chm-파일-html-help#5. CHM 파일 (HTML Help)":"","요약#요약":"1. HTML 파일\r장점\r웹 형식 유지: 사용자가 웹에서 보는 것과 동일한 형태로 문서를 볼 수 있습니다. 다양한 디바이스 호환: 대부분의 디바이스에서 쉽게 열람 가능. 단점\r상호작용성 제한: 네트워크가 없을 경우 일부 상호작용 기능 제한. 구현 방법\rMkDocs 또는 Sphinx를 사용하여 HTML 파일로 빌드. 모든 HTML 파일과 리소스를 압축(zip) 파일로 배포. 2. ePub\r장점\r전자책 형식: 전자책 리더기에서 쉽게 열람 가능. 가변 레이아웃: 글자 크기 조절 등 사용자가 읽기 편한 형식으로 조정 가능. 단점\r복잡한 형식 변환: 일부 레이아웃이나 스타일이 제한될 수 있음. 구현 방법\rSphinx를 사용하여 ePub 형식으로 빌드. 3. 전자책 (eBook)\r장점\r다양한 플랫폼 지원: Kindle, iBooks 등 다양한 전자책 플랫폼에서 사용 가능. 오프라인 접근성: 전자책 리더기에서 언제든지 접근 가능. 단점\r변환 과정 필요: 다른 형식으로 변환하는 과정 필요. 구현 방법\rMarkdown이나 reStructuredText 파일을 eBook 형식으로 변환하기 위해 Pandoc 같은 도구 사용. 4. 설치 가능한 데스크톱 애플리케이션 (StaticSite Manual)\r장점\r독립 실행형: 설치 후 네트워크 없이도 모든 기능 사용 가능. 풍부한 인터페이스: 상호작용이 필요한 매뉴얼에 적합. 단점\r설치 필요: 사용자가 애플리케이션을 설치해야 함. Portable로 빌드 가능 용량 증가: 애플리케이션 크기 증가. 구현 방법\rElectron을 사용하여 데스크톱 애플리케이션으로 패키징. 5. CHM 파일 (HTML Help)\r장점\r윈도우 네이티브 지원: Windows Help Viewer에서 직접 열람 가능. 인터랙티브 콘텐츠 지원: HTML 기반으로 링크 및 멀티미디어 지원. 단점\r플랫폼 제한: 주로 Windows에서만 사용 가능. 구현 방법\rSphinx를 사용하여 CHM 형식으로 빌드. 요약\rHTML 파일: 웹 형식을 유지한 채로 오프라인에서 열람 가능. ePub: 전자책 형식으로 다양한 디바이스에서 읽기 편리. 전자책 (eBook): 전자책 리더기에서 활용 가능. 데스크톱 애플리케이션: 설치 후 네트워크 없이 모든 기능 사용 가능. CHM 파일: Windows에서 네이티브로 지원되는 도움말 파일 형식. "},"title":"매뉴얼 종류"},"/docflow/distribution/about/%EC%A0%95%EC%A0%81-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EB%B0%A9%EC%8B%9D-%EB%A7%A4%EB%89%B4%EC%96%BC/":{"data":{"":"","종류#종류":"종류\r1. MkDocs\r장점\r쉬운 설정: Markdown 파일 기반으로 간단하게 설정할 수 있습니다. 빠른 빌드: 빌드 속도가 빠르고, 문서 작성과 유지보수가 간편합니다. 테마: Material Design을 포함한 다양한 테마를 지원합니다. 플러그인: 다양한 플러그인을 통해 기능을 확장할 수 있습니다. 단점\r고급 기능 제한: 매우 복잡하거나 맞춤형 문서를 작성할 때는 기능이 제한될 수 있습니다. 확장성: Sphinx에 비해 확장성과 유연성이 다소 부족합니다. 2. Sphinx\r장점\r강력한 기능: 매우 유연하고 강력한 기능을 제공하며, 복잡한 문서 구조와 형식을 지원합니다. 확장성: 다양한 확장 모듈과 플러그인을 통해 기능을 확장할 수 있습니다. 출력 형식: HTML, LaTeX, ePub 등 다양한 형식으로 출력할 수 있습니다. 자동화된 문서화: Python 프로젝트의 자동 문서화 도구로 많이 사용됩니다. 단점\r설정 복잡성: 설정과 초기 설정이 복잡할 수 있습니다. Markdown 지원: 기본적으로 reStructuredText(reST)를 사용하며, Markdown 지원은 확장을 통해 가능합니다. 3. Docusaurus\r장점\rReact 기반: React로 작성된 문서로 인터랙티브한 문서 작성이 가능합니다. Markdown 파일: 문서 작성에 Markdown을 사용하여 쉽게 작성할 수 있습니다. 버전 관리: 문서의 버전 관리를 손쉽게 할 수 있습니다. SEO 최적화: SEO에 최적화되어 있으며, 검색 엔진에서 쉽게 색인될 수 있습니다. 단점\rReact 지식 필요: 커스터마이징을 위해서는 React에 대한 지식이 필요합니다. 기능 제한: 일부 복잡한 문서화 요구사항을 충족하기에 기능이 제한될 수 있습니다. 3. Hugo\r장점\r빠른 빌드: 매우 빠른 빌드 속도를 자랑합니다. 유연성: 다양한 테마와 템플릿을 통해 유연한 문서 작성이 가능합니다. Markdown 기반: 문서 작성에 Markdown을 사용합니다. 단점\rGo 기반: Go 언어로 작성되어 있으며, 설정과 확장에 Go 언어 지식이 필요할 수 있습니다. 4 Jekyll\r장점\rGitHub Pages 통합: GitHub Pages와 원활하게 통합되어 무료로 호스팅할 수 있습니다. Markdown 지원: Markdown을 사용하여 쉽게 문서를 작성할 수 있습니다. 플러그인: 다양한 플러그인을 통해 기능을 확장할 수 있습니다. 단점\r속도: 빌드 속도가 상대적으로 느릴 수 있습니다. Ruby 기반: Ruby 언어로 작성되어 있으며, 설정과 확장에 Ruby 지식이 필요할 수 있습니다. 5 GitBook\r장점\r클라우드 기반: GitBook 클라우드에서 문서를 호스팅할 수 있습니다. 인터페이스: 직관적인 인터페이스와 협업 도구를 제공합니다. 버전 관리: 문서의 버전 관리를 쉽게 할 수 있습니다. 단점\r유료 플랜: 무료 플랜이 제한적이며, 고급 기능을 사용하려면 유료 플랜이 필요합니다.- 클라우드 종속: 클라우드 서비스에 종속되어 오프라인 사용에 제약이 있을 수 있습니다. 요약\rMkDocs: 사용하기 쉽고, 빠른 빌드, 간단한 설정을 원할 때 적합합니다. Sphinx: 복잡한 문서 구조와 다양한 출력 형식이 필요할 때 적합합니다. Docusaurus: React 기반의 인터랙티브 문서와 버전 관리를 원할 때 적합합니다. Hugo: 빠른 빌드 속도와 유연한 템플릿이 필요할 때 적합합니다. Jekyll: GitHub Pages 통합 및 간단한 Markdown 기반 문서 작성에 적합합니다. GitBook: 클라우드 기반의 협업 도구와 버전 관리가 필요할 때 적합합니다. "},"title":"정적 사이트 방식 매뉴얼"},"/docflow/distribution/about/staticsite-manual/":{"data":{"":"","개요#개요":"","대표적인-도구들#대표적인 도구들":"개요\r정적 사이트 방식의 매뉴얼은 미리 생성된 HTML, CSS, JavaScript 파일로 구성된 문서화 시스템입니다. 이러한 매뉴얼은 서버 측에서 동적으로 페이지를 생성하지 않고, 미리 만들어진 파일들을 사용자가 요청할 때 그대로 제공하는 형태로 동작합니다. 이는 빠른 로딩 속도와 높은 보안성을 제공하며, 유지보수가 간편한 것이 특징입니다.\n장점\r정적 사이트 방식의 매뉴얼을 통한 효율적인 문서화\r현대의 디지털 환경에서, 빠르고 신뢰할 수 있는 문서화 시스템은 매우 중요합니다. 정적 사이트 방식의 매뉴얼은 이러한 요구를 충족시키는 최적의 솔루션입니다. 이 방식은 미리 생성된 페이지를 제공하여 빠른 로딩 속도를 보장하며, 서버 자원을 최소화하여 비용을 절감합니다.\n빠른 로딩 속도와 높은 성능\r정적 사이트 방식의 매뉴얼은 서버에서 매번 페이지를 생성하는 것이 아니라, 이미 생성된 HTML 파일을 그대로 제공하기 때문에 로딩 속도가 매우 빠릅니다. 사용자는 즉각적인 반응을 경험하게 되며, 이는 사용자 만족도를 크게 향상시킵니다. 특히, 대규모의 문서가 포함된 매뉴얼에서도 뛰어난 성능을 유지할 수 있습니다.\n높은 보안성과 안정성\r정적 사이트는 서버 측 스크립트나 데이터베이스에 접근할 필요가 없으므로, 해킹의 위험이 크게 줄어듭니다. 단순히 파일을 제공하는 형태이기 때문에 보안 문제가 발생할 가능성이 매우 낮습니다. 또한, 정적 사이트는 외부 의존성이 적어 안정성이 높아, 예기치 않은 서버 다운타임 없이 안정적으로 운영할 수 있습니다.\n유지보수의 용이성\r정적 사이트 방식의 매뉴얼은 Git과 같은 버전 관리 시스템과 잘 통합됩니다. 이를 통해 문서 변경 이력을 쉽게 관리하고, 팀원 간의 협업이 용이합니다. 문서의 업데이트나 수정도 간편하여, 항상 최신 정보를 사용자에게 제공할 수 있습니다. 또한, 다양한 호스팅 옵션을 통해 비용 효율적으로 매뉴얼을 배포할 수 있습니다.\n대표적인 도구들\rMkDocs\r파이썬으로 작성된 정적 사이트 생성기로, 마크다운 파일을 사용하여 문서를 작성하고 정적 HTML 사이트로 변환합니다. Docusaurus\rFacebook에서 개발한 정적 사이트 생성기로, 주로 프로젝트 문서화와 블로그 작성에 사용됩니다. Hugo\rGo 언어로 작성된 정적 사이트 생성기로, 매우 빠른 빌드 속도와 다양한 기능을 제공합니다. ","장점#장점":""},"title":"StaticSite Manual"},"/docflow/distribution/guide/electron%EA%B3%BC-tauri/":{"data":{"":"","#":"정적 사이트를 오프라인으로 배포할 때 Electron과 Tauri를 비교해보면, 각 프레임워크는 고유한 장점과 단점을 가지고 있습니다. Tauri가 더 작고 빠른 애플리케이션을 만들 수 있는 반면, Electron은 몇 가지 중요한 이점 때문에 여전히 많은 개발자들에게 선호되고 있습니다. 아래는 Electron이 Tauri보다 나은 몇 가지 이유를 정리했습니다.\nElectron의 장점\r광범위한 생태계 및 커뮤니티 지원\nElectron은 2013년에 처음 출시된 이후로 널리 사용되어 왔습니다. 따라서 많은 개발자들이 Electron을 사용하고 있으며, 다양한 오픈 소스 프로젝트, 튜토리얼, 라이브러리, 플러그인 등이 풍부하게 존재합니다. 문제 해결이나 기능 구현에 필요한 리소스를 쉽게 찾을 수 있습니다. 강력한 기능 및 풍부한 API\nElectron은 Node.js와 Chromium을 기반으로 하여, 데스크탑 애플리케이션에 필요한 거의 모든 기능을 제공합니다. 파일 시스템 접근, 네이티브 모듈 사용, OS 통합 기능 등 다양한 고급 기능을 쉽게 구현할 수 있습니다. 이러한 기능들은 정적 사이트를 배포할 때도 유용하게 활용될 수 있습니다. 성숙도와 안정성\nElectron은 오랜 기간 동안 많은 프로젝트에 사용되면서 높은 안정성과 성숙도를 자랑합니다. 이는 특히 대규모 프로젝트나 안정성이 중요한 애플리케이션에서 큰 장점으로 작용합니다. Electron은 Slack, Visual Studio Code, Discord 등 유명 애플리케이션에서 사용될 만큼 신뢰할 수 있는 플랫폼입니다. 플랫폼 간 일관성\nElectron은 모든 주요 운영 체제(Windows, macOS, Linux)에서 일관된 사용자 경험을 제공하는 데 초점을 맞추고 있습니다. Tauri도 멀티 플랫폼을 지원하지만, Electron은 더 오랜 기간 동안 이 목표를 달성해왔기 때문에 플랫폼 간 호환성과 일관성 면에서 더욱 검증된 솔루션입니다. 광범위한 라이브러리 및 도구\nElectron은 Node.js 에코시스템의 모든 라이브러리와 도구를 사용할 수 있습니다. 이는 개발자가 이미 익숙한 도구와 패키지를 그대로 사용할 수 있다는 것을 의미합니다. 예를 들어, 웹팩(Webpack), 바벨(Babel), ESLint 등 인기 있는 빌드 및 개발 도구를 쉽게 통합할 수 있습니다. Tauri의 장점\r그러나 Tauri도 많은 장점을 가지고 있으며, 이는 Electron과 비교할 때 중요한 고려사항이 될 수 있습니다.\n작은 설치 크기와 낮은 메모리 사용량\nTauri는 매우 가볍고 작은 설치 크기를 가지고 있으며, 메모리 사용량도 낮습니다. 이는 특히 리소스가 제한된 환경이나 배포 파일 크기를 최소화해야 하는 상황에서 큰 장점입니다. 보안\nTauri는 보안에 중점을 두고 설계되었습니다. Tauri 애플리케이션은 기본적으로 웹 기술을 사용하면서도 웹 엔진을 더 안전하게 사용할 수 있도록 지원합니다. 빠른 성능\nTauri는 Rust로 작성되었기 때문에 매우 빠릅니다. Rust의 성능과 안전성을 그대로 활용할 수 있어 고성능 애플리케이션을 만들 수 있습니다. 결론\r결론적으로, Electron은 풍부한 생태계, 광범위한 기능, 성숙도 및 안정성, 그리고 플랫폼 간 일관성을 제공하기 때문에 여전히 많은 개발자들에게 선호되고 있습니다. 반면, Tauri는 경량화, 보안 및 성능 면에서 강점을 가지고 있어, 애플리케이션의 특성과 요구사항에 따라 적합한 선택을 하는 것이 중요합니다. 각 프레임워크의 장단점을 잘 고려하여 프로젝트에 가장 적합한 솔루션을 선택하는 것이 좋습니다."},"title":"Electron과 Tauri"},"/docflow/distribution/guide/electron/%EB%8B%A4%EA%B5%AD%EC%96%B4-%EC%A7%80%EC%9B%90/":{"data":{"":"","languagesdefault-주의#Languages.default 주의":"폴더 구조 주의\rindex.md 파일과 spec/spec.md 파일을 만들고 싶은 경우 docs/ ㄴ index.md ㄴ spec/ ㄴ spec.md 이런 구조로 만들면 site 폴더에는 이렇게 생김\ndocs/ ㄴ index.md ㄴ spec/ ㄴ spec/ ㄴ index.md docs_structure 가 suffix 든 folder 든 최종 site 는 위와 같다.\nLanguages.default 주의\r```yml plugins: - search - i18n: docs_structure: folder languages: - locale: en name: English default: true build: true site_name: \"Manual\" nav: - Home: en/index.md - Spec: en/Spec/index.md\ren 이 default 로 설정되는 경우, site 폴더에 /en 폴더는 생성되지 않는다. 따라서 main.js 파일에 다음 부분이 수정된다.\n//const indexPath = path.join(__dirname, 'site', language, 'index.html'); const indexPath = language === 'en' ? path.join(__dirname, 'site', 'index.html') : path.join(__dirname, 'site', language, 'index.html');\r최종 파일은 다음과 같다.\nconst { app, BrowserWindow } = require('electron'); const path = require('path'); const fs = require('fs'); function createWindow() { const mainWindow = new BrowserWindow({ width: 1024, height: 768, webPreferences: { nodeIntegration: true, contextIsolation: false, enableRemoteModule: false } }); mainWindow.webContents.on('did-finish-load', () =\u003e { //mainWindow.webContents.openDevTools(); }); let language = 'en'; const args = process.argv.slice(2); if (args.includes('--lang=ko')) { language = 'ko'; } else if (args.includes('--lang=zh')) { language = 'zh'; } else if (args.includes('--lang=ja')) { language = 'ja'; } const indexPath = language === 'en' ? path.join(__dirname, 'site', 'index.html') : path.join(__dirname, 'site', language, 'index.html'); console.log('Loading file from:', indexPath); if (fs.existsSync(indexPath)) { mainWindow.loadFile(indexPath).catch(err =\u003e { console.error('Failed to load file:', err); }); } else { console.error('File does not exist:', indexPath); } mainWindow.webContents.on('new-window', (event, url) =\u003e { event.preventDefault(); const parsedUrl = new URL(url); const newPath = path.join(__dirname, 'site', parsedUrl.pathname); if (fs.existsSync(newPath)) { mainWindow.loadFile(newPath).catch(err =\u003e { console.error('Failed to load file:', err); }); } else { console.error('File does not exist:', newPath); } }); } app.on('ready', createWindow); app.on('window-all-closed', () =\u003e { if (process.platform !== 'darwin') { app.quit(); } }); app.on('activate', () =\u003e { if (BrowserWindow.getAllWindows().length === 0) { createWindow(); } });","폴더-구조-주의#폴더 구조 주의":""},"title":"다국어 지원"},"/docflow/distribution/guide/electron/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%BA%90%EC%8B%B1/":{"data":{"":"","#":"잘안됨\n1. 애플리케이션 데이터 캐싱\r일렉트론 애플리케이션에서 로컬 파일 시스템에 캐시 데이터를 저장하고 이를 활용하는 방법을 설명합니다.\n1.1. 사용자 데이터 경로 설정\r일렉트론에서는 app.getPath('userData') 메서드를 사용하여 사용자 데이터 경로를 가져올 수 있습니다. 이 경로를 사용하여 캐시 데이터를 저장할 수 있습니다.\n1.2. 캐시 데이터 저장\r애플리케이션이 처음 실행될 때, 필요한 데이터를 로드하여 캐시 파일로 저장합니다. 이후 실행에서는 이 캐시 파일을 사용하여 데이터를 빠르게 로드할 수 있습니다.\nconst { app, BrowserWindow } = require('electron'); const path = require('path'); const fs = require('fs'); function createWindow() { const mainWindow = new BrowserWindow({ width: 800, height: 600, webPreferences: { preload: path.join(__dirname, 'preload.js'), nodeIntegration: true, contextIsolation: false } }); const userDataPath = app.getPath('userData'); const cacheFilePath = path.join(userDataPath, 'cache.html'); // 캐시 파일이 존재하는지 확인 if (fs.existsSync(cacheFilePath)) { // 캐시 파일이 존재하면 캐시된 데이터를 로드 mainWindow.loadFile(cacheFilePath); } else { // 캐시 파일이 존재하지 않으면 기본 HTML 파일 로드 mainWindow.loadFile('index.html'); // 웹 페이지가 로드된 후 캐시 파일로 저장 mainWindow.webContents.on('did-finish-load', () =\u003e { mainWindow.webContents.executeJavaScript('document.documentElement.outerHTML', (html) =\u003e { fs.writeFileSync(cacheFilePath, html); }); }); } mainWindow.on('closed', function () { mainWindow = null; }); } app.on('ready', createWindow); app.on('window-all-closed', function () { if (process.platform !== 'darwin') { app.quit(); } }); app.on('activate', function () { if (BrowserWindow.getAllWindows().length === 0) { createWindow(); } });\r이 예제에서는 다음을 수행합니다:\n사용자 데이터 경로 설정: app.getPath('userData')를 사용하여 사용자 데이터 경로를 가져옵니다. 캐시 파일 경로 설정: 캐시 파일을 저장할 경로를 설정합니다. 캐시 파일 확인 및 로드: 캐시 파일이 존재하면 해당 파일을 로드하고, 그렇지 않으면 기본 HTML 파일을 로드합니다. 캐시 파일 저장: 웹 페이지가 처음 로드된 후, did-finish-load 이벤트에서 페이지의 HTML 내용을 캐시 파일로 저장합니다. 2. 서비스 워커 및 캐시 API 사용\r웹 애플리케이션에서는 서비스 워커와 캐시 API를 사용하여 정적 자산을 캐시할 수 있습니다. 이를 통해 네트워크 요청 없이도 자산을 로컬에서 빠르게 로드할 수 있습니다.\n2.1. 서비스 워커 설정\rsrc/sw.js 파일을 생성하고 서비스 워커를 설정합니다:\nself.addEventListener('install', (event) =\u003e { event.waitUntil( caches.open('v1').then((cache) =\u003e { return cache.addAll([ '/', '/index.html', '/styles.css', '/script.js' ]); }) ); }); self.addEventListener('fetch', (event) =\u003e { event.respondWith( caches.match(event.request).then((response) =\u003e { return response || fetch(event.request); }) ); });\r2.2. 서비스 워커 등록\rsrc/renderer.js 파일에서 서비스 워커를 등록합니다:\nif ('serviceWorker' in navigator) { navigator.serviceWorker.register('/sw.js').then((registration) =\u003e { console.log('Service Worker registered with scope:', registration.scope); }).catch((error) =\u003e { console.error('Service Worker registration failed:', error); }); }\r이 설정을 통해 서비스 워커가 설치되고, 정적 자산이 캐시됩니다. 이후 요청 시 캐시된 자산을 사용하여 빠르게 로드할 수 있습니다.\n결론\r위의 방법들을 통해 일렉트론 애플리케이션의 초기 실행 속도를 개선하고, 이후 실행에서는 캐시를 사용하여 더 빠르게 로드할 수 있습니다. 첫 번째 방법은 로컬 파일 시스템에 캐시를 저장하는 방법이고, 두 번째 방법은 웹 애플리케이션에서 흔히 사용하는 서비스 워커를 활용하는 방법입니다. 사용자의 요구사항에 맞는 방법을 선택하여 적용해 보세요."},"title":"데이터 캐싱"},"/docflow/distribution/guide/electron/%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EB%AA%A8%EB%93%88-%ED%99%95%EC%9D%B8-%EB%B0%8F-%EC%A0%9C%EA%B1%B0/":{"data":{"":"","#":"프로젝트에서 사용하지 않는 모듈을 확인하고 제거하는 방법에는 몇 가지가 있습니다. 이를 위해 여러 도구와 방법을 사용할 수 있습니다. 여기서는 depcheck라는 도구를 사용하여 사용하지 않는 모듈을 확인하고, npm을 사용하여 해당 모듈을 제거하는 방법을 설명하겠습니다.\n1. depcheck 설치\r먼저 depcheck를 설치합니다.\nnpm install -g depcheck\r2. 사용하지 않는 모듈 확인\rdepcheck를 사용하여 프로젝트에서 사용하지 않는 모듈을 확인합니다.\ndepcheck\r이 명령어를 실행하면, 사용하지 않는 패키지와 사용되지 않는 파일 및 모듈에 대한 보고서를 생성합니다. 예를 들어, 다음과 같은 출력이 나타날 수 있습니다:\nUnused dependencies * unused-package1 * unused-package2 Unused devDependencies * unused-dev-package1 * unused-dev-package2 Missing dependencies * missing-package1 * missing-package2\r3. 사용하지 않는 모듈 제거\r사용하지 않는 모듈을 확인한 후, npm uninstall 명령어를 사용하여 해당 모듈을 제거합니다. 예를 들어, unused-package1과 unused-package2를 제거하려면 다음 명령어를 실행합니다:\nnpm uninstall unused-package1 unused-package2\r4. missing dependencies\rmissing dependencies 섹션에 나열된 패키지들은 코드에서 사용되고 있지만 package.json에 정의되지 않은 의존성입니다. 이를 해결하기 위해 각 패키지를 package.json에 추가합니다.\nnpm install missing-package1\r개발 환경에서만 필요한 패키지라면 --save-dev 플래그를 사용하여 devDependencies 섹션에 추가할 수 있습니다.\nnpm install --save-dev missing-dev-package1\rpackage.json 파일은 자동 업데이트\nmissing dependencies가 있는 경우, 현재 빌드와 실행이 정상적으로 된다면 다음과 같은 이유일 수 있습니다:\n글로벌 설치된 패키지: 의존성이 글로벌 환경에 설치되어 있을 수 있습니다. 이 경우 로컬 node_modules 디렉토리에는 없어도 실행이 가능할 수 있습니다. 캐싱된 의존성: 이전에 설치된 의존성이 여전히 캐싱되어 있어 정상적으로 동작할 수 있습니다. 의존성이 없는 런타임 환경: 빌드 프로세스 또는 실행 환경에서 해당 의존성을 필요로 하지 않을 수 있습니다. 의존성이 간접적으로 포함됨: 다른 의존성이 이 패키지들을 포함하고 있을 수 있습니다. 그러나 missing dependencies를 무시하는 것은 바람직하지 않습니다. 이유는 다음과 같습니다: 예상치 못한 오류: 특정 상황에서 런타임 오류가 발생할 수 있습니다. 코드 유지보수: 프로젝트를 다른 개발자가 작업하거나 새로운 환경에서 설정할 때 문제가 될 수 있습니다. 일관성 있는 빌드: CI/CD 환경에서 일관된 빌드와 배포를 보장할 수 없습니다. 따라서 missing dependencies를 확인하고 해결하는 것이 중요합니다. depcheck 도구는 프로젝트에서 사용되고 있는 모듈을 분석하여, package.json 파일에 선언되어 있지 않은 의존성을 missing dependencies로 표시합니다. 그러나 다음과 같은 이유로 실제로는 사용하지 않지만 missing dependencies로 잘못 표시될 수 있습니다:\n동적 require 사용: 코드에서 동적으로 모듈을 require하는 경우 depcheck가 이를 감지하지 못할 수 있습니다. 코드 분석 한계: 코드의 특정 패턴이나 동적 로딩, 조건부 로딩 등에 의해 의존성을 올바르게 감지하지 못할 수 있습니다. 설정 파일: Webpack, Babel, ESLint 등의 설정 파일에 정의된 의존성을 depcheck가 인식하지 못할 수 있습니다. 개발 도구 및 스크립트: 특정 개발 도구나 빌드 스크립트에서만 사용되는 의존성을 depcheck가 감지하지 못할 수 있습니다. missing dependencies 잘못 표시 여부 확인\rmissing dependencies로 표시된 모듈이 실제로 사용되지 않는지 확인하는 몇 가지 방법:\n코드베이스 검색: 프로젝트 전체에서 해당 모듈이 사용되는지 검색합니다. 빌드 및 테스트: missing dependencies로 표시된 모듈을 제거한 후 프로젝트를 빌드하고 테스트하여 문제가 발생하는지 확인합니다. 동적 로딩 확인: 동적 require나 조건부 로딩이 있는지 확인합니다. missing dependencies로 표시된 모듈 제거\r실제로 사용되지 않는 경우 missing dependencies로 표시된 모듈을 제거할 수 있습니다. 제거하는 방법은 다음과 같습니다:\n모듈 제거: npm uninstall \u003cmodule_name\u003e"},"title":"사용하지 않는 모듈 확인 및 제거"},"/docflow/distribution/guide/electron/%EC%8B%A4%ED%96%89%EC%86%8D%EB%8F%84-%EA%B0%9C%EC%84%A0/":{"data":{"":"","#":"포터블로 빌드된 일렉트론 애플리케이션의 실행 속도를 올리기 위해 다양한 최적화 방법을 적용할 수 있습니다. 여기 몇 가지 주요 방법을 설명드립니다.\n1. 애플리케이션 크기 줄이기\r애플리케이션 크기를 줄이면 로딩 시간이 단축될 수 있습니다. 불필요한 파일을 제거하고 필요한 파일만 포함되도록 설정합니다.\nWebpack 사용\rWebpack을 사용하여 애플리케이션을 번들링하고 압축하면 로딩 속도를 개선할 수 있습니다.\nnpm install --save-dev webpack webpack-cli\rwebpack.config.js 파일을 생성하고 구성합니다:\nconst path = require('path'); module.exports = { mode: 'production', entry: './src/main.js', // 주 진입점 파일 output: { path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' }, target: 'electron-main', node: { __dirname: false, __filename: false }, module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, use: { loader: 'babel-loader' } } ] } };\r이렇게 설정한 후 npm run build 명령어로 번들링할 수 있습니다.\nElectron Builder 설정\rElectron Builder 설정에서 불필요한 파일을 제외하도록 설정할 수 있습니다. package.json 파일에 설정을 추가합니다:\n{ \"build\": { \"files\": [ \"dist/**/*\", \"node_modules/**/*\", \"package.json\" ], \"extraFiles\": [ \"resources/**/*\" ], \"asar\": true } }\r2. ASAR 아카이브 사용\rASAR 아카이브를 사용하면 애플리케이션 파일을 하나의 아카이브 파일로 묶어 빠르게 로드할 수 있습니다. package.json 파일의 build 설정에 asar: true를 추가합니다.\n3. 시작 시간 최적화\r애플리케이션 시작 시간 최적화를 위해 코드 레벨에서 할 수 있는 최적화 방법들입니다.\n지연 로딩\r필요하지 않은 모듈은 애플리케이션 시작 후에 로딩되도록 지연 로딩을 설정합니다.\nconst { app, BrowserWindow } = require('electron'); let mainWindow; function createWindow () { mainWindow = new BrowserWindow({ width: 800, height: 600, webPreferences: { nodeIntegration: true } }); mainWindow.loadFile('index.html'); mainWindow.on('closed', function () { mainWindow = null }); } app.on('ready', () =\u003e { createWindow(); // 지연 로딩 모듈 setTimeout(() =\u003e { const someHeavyModule = require('some-heavy-module'); // Use the module }, 1000); });\r필요 없는 모듈 제거\r애플리케이션 시작 시 필요하지 않은 모듈을 확인하고 제거합니다. 패키지 크기를 줄이고 로딩 시간을 개선할 수 있습니다.\n4. 파일 압축 및 이미지 최적화\r이미지 파일과 기타 리소스를 압축하여 애플리케이션 크기를 줄일 수 있습니다. 이를 위해 이미지 압축 도구를 사용합니다.\n5. 파일 시스템 접근 최소화\r애플리케이션이 파일 시스템에 접근하는 빈도를 최소화하면 성능을 개선할 수 있습니다. 필요한 데이터는 메모리에 로드하여 사용합니다.\n6. 하드웨어 가속 사용\rElectron에서 하드웨어 가속을 사용하도록 설정하여 성능을 향상시킬 수 있습니다. 기본적으로 활성화되어 있지만, 비활성화된 경우 명시적으로 설정할 수 있습니다.\nconst { app } = require('electron'); app.commandLine.appendSwitch('enable-gpu-rasterization'); app.commandLine.appendSwitch('enable-zero-copy'); // 기타 하드웨어 가속 옵션 추가 7. 업데이트 및 최적화된 라이브러리 사용\r최신 버전의 Electron과 관련 라이브러리를 사용하면 성능 개선이 포함된 업데이트를 활용할 수 있습니다. 프로젝트의 모든 종속성을 최신 버전으로 유지합니다.\nnpm update"},"title":"실행속도 개선"},"/docflow/distribution/guide/electron/%EC%B5%9C%EC%A0%81%ED%99%94/":{"data":{"":"","이유#이유":"","최적화-방법#최적화 방법":"electron 패키징 결과 파일은 기본적으로 크기가 크다\n이유\rChromium 엔진 Electron은 웹 콘텐츠를 렌더링하기 위해 Chromium 엔진을 포함 이 엔진은 매우 크며, 렌더링 기능을 제공하기 위해 많은 파일 포함 Node.js 통합 Electron은 Node.js 런타임을 포함하여 Node.js 기능을 사용 Electron 바이너리 Electron 자체 바이너리도 포함 최적화 방법\r압축 사용: electron-builder는 압축을 통해 최종 패키지의 크기를 줄일 수 있음 불필요한 파일 제거: .npmignore 또는 files 필드를 사용하여 패키지에 포함할 파일을 명시적으로 지정 Code Signing: 이 과정은 실제로 크기를 줄이는 것과는 무관하지만, 배포 시 중요한 단계 { \"name\": \"output\", \"version\": \"1.0.0\", \"main\": \"main.js\", \"scripts\": { \"start\": \"electron .\", \"build\": \"electron-builder --config build-config.json\" }, \"description\": \"\", \"devDependencies\": { \"electron\": \"^30.0.7\", \"electron-builder\": \"^24.13.3\" }, \"build\": { \"appId\": \"com.example.mkdocs\", \"files\": [ \"main.js\", \"site/**/*\" ], \"directories\": { \"output\": \"dist\" }, \"compression\": \"maximum\", // 최적의 압축을 위해 추가 \"extraResources\": [ \"main.js\", \"site/**/*\" ], \"extraMetadata\": { \"main\": \"main.js\" } } }"},"title":"최적화"},"/docflow/distribution/guide/electron/electron%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%84%A4%EC%B9%98-%ED%8C%8C%EC%9D%BC-%EB%A7%8C%EB%93%A4%EA%B8%B0/":{"data":{"":"","electron-설정#Electron 설정":"","electron-실행#Electron 실행":"","electron-패키징#Electron 패키징":"Electron 프로젝트 설치\rNode.js 가 설치되어 있지 않다면, Node.js 설치 새로운 프로젝트 디렉터리를 생성하고 Electron 설치\r\u003e mkdir output \u003e cd output \u003e npm init -y \u003e npm install electron --save-dev\r위와 같은 에러가 발생한다면 [Trouble Shooting] 참조 Electron 설정\rpackage.json파일 수정`Electron 설정 추가\r{ \"scripts\": { \"start\": \"electron .\" }, }\rmain.js 파일 추가\r프로젝트 디렉터리에 main.js 파일을 생성하고 아래 내용 추가 const { app, BrowserWindow } = require('electron'); const path = require('path'); function createWindow() { const mainWindow = new BrowserWindow({ width: 800, height: 600, webPreferences: { nodeIntegration: true } }); //mainWindow.loadFile(path.join(__dirname, '../site/index.html')); mainWindow.loadFile(path.join(__dirname, 'site', 'index.html')); } app.on('ready', createWindow); app.on('window-all-closed', () =\u003e { if (process.platform !== 'darwin') { app.quit(); } }); app.on('activate', () =\u003e { if (BrowserWindow.getAllWindows().length === 0) { createWindow(); } });\r이 파일은 Electron 창을 생성하고, MkDocs 빌드된 HTML 파일을 로드 main.js 파일에서 mainWindow.loadFile 함수가 site/index.html 파일을 로드하도록 설정했음을 확인 site 폴더를 상위 폴더로 설정하는 경우 경로가 정상적으로 설정되지 않는 경우가 있다. site 폴더를 output 폴더 안으로 복사하고 사용하는 것으로 변경경 site 폴더는 MkDocs 빌드 파일이 있는 폴더 Electron 실행\routput 폴더에서 다음 명령어를 실행하여 Electron 애플리케이션 시작 \u003e npm start\rElectron 패키징\rElectron 애플리케이션을 단일 실행 파일로 패키징하기 위해 electron-packager 또는 electron-builder와 같은 도구를 사용\nelectron-builder를 사용하여 설치 버전 패키징electron-builder 설치\r\u003e npm install --save-dev electron-builder\rpackage.json 파일 수정 build 스크립트와 build 설정을 package.json 파일에 추가 { \"name\": \"output\", \"version\": \"1.0.0\", \"main\": \"main.js\", \"scripts\": { \"start\": \"electron .\", \"build\": \"electron-builder\" }, \"description\": \"\", \"devDependencies\": { \"electron\": \"^30.0.7\", \"electron-builder\": \"^24.13.3\" }, \"build\": { \"appId\": \"com.example.mkdocs\", \"files\": [ \"main.js\", \"site/**/*\" //\"../site/**/*\" ], \"directories\": { \"output\": \"dist\" } } }\rElectron 애플리케이션 빌드 \u003e npm run build\rdist 폴더에 실행 파일 생성 확인 -\nelectron-builder 를 사용하여 실행 파일 패키징\rpackage.json 파일 설정 build 스크립트 추가 electron-packager 사용\relectron-packager 설치 \u003e npm install electron-packager --save-dev\r다음 명령어를 실행하여 애플리케이션 빌드 \u003e npx electron-packager . my-electron-app --platform=win32 --arch=x64 --out=dist --overwrite\rdist 디렉터리에 실행 가능한 파일 생성 확인 ","electron-프로젝트-설치#Electron 프로젝트 설치":""},"title":"Electron을 이용한 설치 파일 만들기"},"/docflow/distribution/guide/electron/electron-%ED%8C%A8%ED%82%A4%EC%A7%95-%ED%8C%8C%EC%9D%BC-%EC%84%A4%EC%A0%95/":{"data":{"":"","site-폴더-참조#site 폴더 참조":"이름 변경\r{ \"name\": \"output\", \"version\": \"1.0.0\", \"main\": \"main.js\", \"scripts\": { \"start\": \"electron .\", \"build\": \"electron-builder\" }, \"description\": \"\", \"devDependencies\": { \"electron\": \"^30.0.7\", \"electron-builder\": \"^24.13.3\" }, \"build\": { \"appId\": \"com.example.mkdocs\", \"files\": [ \"main.js\", \"site/**/*\" ], \"directories\": { \"output\": \"dist\" }, \"compression\": \"maximum\", \"extraResources\": \"site/**/*\", \"extraMetadata\": { \"main\": \"main.js\" } } }\r출력 파일 이름 : output Setup 1.0.0.exe productName 설정\r\"build\": { \"appId\": \"com.example.mkdocs\", \"productName\": \"KCT Manual\", }\r출력 파일 이름 : KCT Manual Setup 1.0.0.exe artifactName 설정\r\"build\": { \"appId\": \"com.example.mkdocs\", \"productName\": \"KCT Manual\", \"artifactName\": \"${productName}-${version}.${ext}\", }\r출력 파일 이름 : KCT Manual_1.0.0.exe 설치 화면 비활성\rpackage.json 파일에 nsis 설정을 추가하여 oneClick 설치 활성화\nNSIS 설치 https://nsis.sourceforge.io/Download \"build\": { \"appId\": \"com.example.mkdocs\", \"files\": [ \"main.js\", \"site/**/*\" ], \"directories\": { \"output\": \"dist\" }, \"compression\": \"maximum\", \"extraResources\": \"site/**/*\", \"extraMetadata\": { \"main\": \"main.js\" }, \"nsis\": { \"oneClick\": true, \"perMachine\": true, \"allowToChangeInstallationDirectory\": false, \"deleteAppDataOnUninstall\": true, } }\rnsis 설정만으로는 설치 진행 창이 사라지지 않음 \"nsis\": { \"oneClick\": true, \"perMachine\": true, \"allowToChangeInstallationDirectory\": false, \"deleteAppDataOnUninstall\": true, \"include\": \"installer.nsh\" }\r!macro customHeader\rSilentInstall silent\rSilentUnInstall silent\r!macroend\r!macro customInit\rSetSilent silent\r!macroend\rSection \"MainSection\"\r; 실제 설치 작업을 여기에 추가\rSectionEnd\rinstall.nsh 파일을 만들어서 include 시키면 빌드 버전에서 실행이 안됨 npm run 으로는 실행됨 원인 분석 필요 site 폴더 참조\r폴더 구조 KCT/Site KCT/Output Output 폴더의 Pakage.json 파일에서 Site 를 참조해야 하므로 경로를 “../Site” 로 설정하면 될거 같은데 안됨. 상대 경로 설정이 제대로 안되는 듯 빌드할때마다 Site 폴더를 복사하는 건 귀찮으니까 prebuild script 추가 프로젝트 루트 디렉토리에 copy-files.js 파일을 생성하고 다음 내용 추가 const fs = require('fs-extra'); const path = require('path'); // 상위 폴더의 site 디렉토리 경로 const sourceDir = path.join(__dirname, '..', 'site'); // 현재 프로젝트의 build 디렉토리 경로 const destDir = path.join(__dirname, 'site'); // 디렉토리 복사 fs.copy(sourceDir, destDir, err =\u003e { if (err) { console.error('Error while copying the site directory:', err); } else { console.log('Site directory copied successfully!'); } });\rpackage.json 수정\n{ \"name\": \"output\", \"version\": \"1.0.0\", \"main\": \"main.js\", \"scripts\": { \"prebuild\": \"node copy-files.js\", \"start\": \"electron .\", \"build\": \"electron-builder\" }, \"devDependencies\": { \"electron\": \"^30.0.7\", \"electron-builder\": \"^24.13.3\", \"fs-extra\": \"^10.0.0\" }, \"build\": { \"appId\": \"com.example.mkdocs\", \"productName\": \"KCT_Manual\", \"artifactName\": \"${productName}_${version}.${ext}\", \"files\": [ \"main.js\", \"site/**/*\" ], \"directories\": { \"output\": \"dist\" }, \"compression\": \"maximum\", \"extraResources\": [ { \"from\": \"site\", \"to\": \"site\" } ], \"extraMetadata\": { \"main\": \"main.js\" }, \"nsis\": { \"oneClick\": true, \"allowElevation\": true, \"allowToChangeInstallationDirectory\": false, \"deleteAppDataOnUninstall\": true, \"removeDefaultUninstallWelcomePage\": true } } }\r빌드 시 site 폴더 복사 여부 확인 ","설치-화면-비활성#설치 화면 비활성":"","이름-변경#이름 변경":""},"title":"Electron 패키징 파일 설정"},"/docflow/distribution/guide/mobile/":{"data":{"":"","#":"옵시디언(Obsidian)을 사용하여 프로젝트를 휴고(Hugo)로 빌드하고, 이를 타우리(Tauri)나 일렉트론(Electron)을 사용하여 다시 빌드하여 윈도우용 애플리케이션을 만드는 과정에서 안드로이드(Android)나 아이폰(iPhone)용 앱으로 변환할 수 있는 방법은 다음과 같습니다:\n1. 휴고(Hugo) 빌드\r먼저 Obsidian에서 만든 콘텐츠를 Hugo를 사용하여 정적 웹사이트로 빌드합니다. 이 과정은 일반적인 웹사이트 빌드와 동일합니다.\n2. 타우리(Tauri) 또는 일렉트론(Electron) 빌드\rHugo로 빌드된 정적 사이트를 Tauri 또는 Electron을 사용하여 데스크탑 애플리케이션으로 감싸서 빌드합니다. 이 과정도 일반적인 Tauri 또는 Electron 앱 빌드 과정과 동일합니다.\n3. 안드로이드 및 iOS 앱으로 변환\r안드로이드 및 iOS 앱으로 변환하기 위해 여러 가지 방법이 있습니다. 여기에서는 Capacitor와 Cordova를 사용한 방법을 설명합니다.\nCapacitor\rCapacitor는 Ionic 팀에서 만든 네이티브 브릿지로, 웹 애플리케이션을 네이티브 모바일 애플리케이션으로 감쌀 수 있습니다.\n프로젝트 설정\n먼저, Capacitor를 프로젝트에 설치합니다: npm install @capacitor/core @capacitor/cli npx cap init\r`capacitor.config.json` 파일을 설정합니다.\r웹 애플리케이션을 빌드\nHugo로 웹 애플리케이션을 빌드합니다:\nbash\nCopy code\nhugo\nCapacitor로 빌드된 파일 추가\nCapacitor가 웹 애플리케이션을 인식하도록 빌드된 파일을 추가합니다:\nbash\nCopy code\nnpx cap add android npx cap add ios\n프로젝트 빌드 및 실행\n안드로이드:\nbash\nCopy code\nnpx cap open android\niOS:\nbash\nCopy code\nnpx cap open ios\nCordova\rCordova는 웹 애플리케이션을 네이티브 모바일 애플리케이션으로 변환하는 또 다른 도구입니다.\n프로젝트 설정\nCordova를 설치합니다:\nbash\nCopy code\nnpm install -g cordova cordova create MyApp cd MyApp cordova platform add android cordova platform add ios\n웹 애플리케이션을 빌드\nHugo로 웹 애플리케이션을 빌드합니다:\nbash\nCopy code\nhugo\n빌드된 파일 복사\nHugo의 public 디렉토리의 파일을 Cordova의 www 디렉토리로 복사합니다:\nbash\nCopy code\ncp -r public/* www/\n프로젝트 빌드 및 실행\n안드로이드:\nbash\nCopy code\ncordova run android\niOS:\nbash\nCopy code\ncordova run ios\n이 과정을 통해 Obsidian에서 작성한 콘텐츠를 기반으로 Hugo로 빌드하고, 이를 Tauri나 Electron을 사용하여 데스크탑 애플리케이션으로 만들고, 나아가 Capacitor 또는 Cordova를 사용하여 모바일 애플리케이션으로 변환할 수 있습니다.\nCapacitor와 Cordova 비교\rCapacitor\r장점:\n현대적인 설계: Capacitor는 최근에 개발된 도구로, 최신 웹 기술과 네이티브 API를 쉽게 통합할 수 있도록 설계되었습니다. Ionic 프레임워크와의 통합: Ionic 팀에서 개발했기 때문에, Ionic 프레임워크와 매우 잘 통합됩니다. 자체 플러그인 생태계: 다양한 최신 플러그인을 지원하며, 커뮤니티에서도 활발하게 플러그인이 개발되고 있습니다. 개발 편의성: 최신 개발 환경과 도구와의 통합이 뛰어나며, React, Vue, Angular 등 다양한 프레임워크와 쉽게 통합할 수 있습니다. 단점: 플러그인 수 제한: 아직 Cordova에 비해 플러그인의 수가 적습니다. 새로운 도구: 상대적으로 새로운 도구이기 때문에, 일부 개발자 커뮤니티나 지원 문서가 부족할 수 있습니다. Cordova\r장점:\n오랜 역사: Cordova는 오랜 역사를 가지고 있으며, 많은 플러그인과 넓은 커뮤니티 지원을 가지고 있습니다. 플러그인 다양성: 다양한 플러그인들을 제공하며, 필요에 따라 대부분의 네이티브 기능을 쉽게 사용할 수 있습니다. 넓은 사용자층: 많은 사용자층과 프로젝트가 존재하여, 문제 해결을 위한 리소스가 풍부합니다. 단점: 레거시 문제: 오래된 설계로 인해 최신 웹 기술과의 통합이 다소 어려울 수 있습니다. 개발 경험: Capacitor에 비해 개발 경험이 떨어질 수 있으며, 최신 개발 도구와의 호환성에서 문제가 있을 수 있습니다. 어떤 것을 선택할지\r최신 기술을 사용하고자 한다면: Capacitor를 사용하는 것이 더 좋습니다. 최신 웹 프레임워크와의 통합이 쉽고, 현대적인 개발 도구를 잘 지원하기 때문입니다. 더 많은 플러그인과 안정된 생태계를 원한다면: Cordova가 더 나은 선택일 수 있습니다. 다양한 플러그인과 넓은 커뮤니티 지원을 받을 수 있습니다. 결론적으로, 프로젝트의 요구사항과 팀의 기술 스택에 따라 선택이 달라질 수 있습니다. 최신 개발 경험과 모던한 기술 스택을 선호한다면 Capacitor를, 검증된 안정성과 다양한 플러그인을 필요로 한다면 Cordova를 선택하는 것이 좋습니다. 4o "},"title":"Mobile"},"/docflow/distribution/guide/tauri/%EC%84%A4%EC%B9%98/":{"data":{"":"","npx-설치#npx 설치":"","rust-설치#Rust 설치":"","tauri-설치#Tauri 설치":"","설정#설정":"","애플리케이션-빌드#애플리케이션 빌드":"Rust 설치\rhttps://www.rust-lang.org/ 에서 다운로드 후 설치합니다. 설치 여부 확인을 위해 버전을 확인합니다. \u003e rustc --version rustc 1.78.0 (9b00956e5 2024-04-29) \u003e cargo --version cargo 1.78.0 (54d8815d0 2024-03-26)\rTauri 설치\r\u003e cargo install tauri-cli --- download / install --- \u003e cargo-tauri --version tauri-cli 1.5.14\rnpx 설치\r\u003e npx --version 10.8.0\rnpx 가 설치되어 있지 않다면 npx도 함께 설치합니다. 프로젝트 생성\r\u003e npx create-tauri-app DocFlow_Tauri\rD:\\Obsidian\u003enpx create-tauri-app Aprofl_Tauri ✔ Package name · aprofl_tauri ✔ Choose which language to use for your frontend · TypeScript / JavaScript - (pnpm, yarn, npm, bun) ✔ Choose your package manager · npm ✔ Choose your UI template · React - (https://react.dev/) ✔ Choose your UI flavor · JavaScript Template created! To get started run: cd Aprofl_Tauri npm install npm run tauri dev D:\\Obsidian\u003ecd aprofl_tauri\r몇 가지 설정이 있는데, 여기서는 다음과 같이 설정합니다.\nfrontend language : TypeScript / JavaScript package manager : npm UI template : React UI flavor : JavaScript 설정완료 후 다음과 같은 구조가 됩니다.\nD:\\Obsidian ├── DocFlow_Hugo\\Public # Hugo로 빌드된 파일들이 있는 폴더 ├── DocFlow_Tauri\\ # Tauri 프로젝트 폴더\r설정\rtauri.conf.json 파일 설정\rD:/Obsidian/DocFlow_Tauri/src-tauri/tauri.conf.json 파일의 build 섹션을 확인하고, devPath와 distDir 경로를 설정합니다. distDir: npm run tauri:build 명령어를 실행할 때 Tauri가 참조하는 소스 파일들이 위치한 폴더입니다. 빌드 시에 사용할 HTML, CSS, JavaScript 파일들이 위치한 경로를 지정합니다. 빌드된 결과물은 src-tauri/target/release 폴더에 생성됩니다. devPath: npm run tauri:dev 명령어를 실행할 때 Tauri가 참조하는 소스 파일들이 위치한 폴더입니다. 개발 모드에서 사용할 HTML, CSS, JavaScript 파일들이 위치한 경로를 지정합니다. { \"build\": { \"distDir\": \"../../DocFlow_Hugo/Public\", \"devPath\": \"../../DocFlow_Hugo/Public\" }, \"tauri\": { \"windows\": [ { \"title\": \"DocFlow\", \"width\": 800, \"height\": 600 } ] } }\r의존성 설치 및 개발 서버 실행\r의존성 설치\rnpm install\r개발 서버 실행\rTauri 개발 모드를 실행하여 애플리케이션이 제대로 동작하는지 확인합니다:\nnpm run tauri dev\r애플리케이션 빌드\r애플리케이션을 포터블 형식으로 빌드합니다:\nnpm run tauri build\rnpx i","의존성-설치-및-개발-서버-실행#의존성 설치 및 개발 서버 실행":"","프로젝트-생성#프로젝트 생성":""},"title":"설치"},"/docflow/docengr/about/":{"data":{"":"","결론#결론":"문서 엔지니어링은 정보의 체계적인 설계, 작성, 관리 및 배포 과정을 포함하는 학문과 실무 분야입니다. 이는 주로 기술 문서, 사용자 매뉴얼, 교육 자료, 프로세스 문서 등 다양한 문서의 효율적이고 효과적인 생성과 유지 보수를 목표로 합니다.\n주요 요소\r문서 설계\r문서의 구조, 형식, 내용 및 배포 방법을 계획합니다. 이는 독자의 요구와 문서의 목적을 고려하여 수행됩니다.\n작성 및 편집\r명확하고 일관된 언어로 문서를 작성하고 편집합니다. 기술 용어의 정확한 사용과 독자의 이해를 돕기 위한 명료한 표현이 중요합니다.\n정보 관리\r문서의 버전 관리, 접근 제어 및 보안을 포함하여 문서를 체계적으로 저장하고 유지합니다. 이는 문서의 최신 상태를 유지하고 필요한 사람이 적절한 문서에 접근할 수 있도록 합니다.\n배포 및 출판\r작성된 문서를 적절한 형식으로 변환하고 다양한 플랫폼과 채널을 통해 배포합니다. 이는 종이 문서, PDF, 웹페이지, 모바일 앱 등 다양한 형태로 문서를 제공할 수 있습니다.\n사용자 피드백\r사용자로부터 피드백을 받아 문서를 지속적으로 개선합니다. 이는 문서의 유용성과 정확성을 높이는 데 중요한 역할을 합니다.\n문서 엔지니어링의 중요성\r효율성\r잘 설계된 문서는 사용자가 필요한 정보를 빠르게 찾을 수 있게 하여 업무 효율성을 높입니다.\n일관성\r일관된 문서 형식과 스타일을 유지함으로써 조직 내외부에서의 커뮤니케이션을 개선합니다.\n정확성\r정확한 정보 제공은 사용자 오류를 줄이고 제품이나 서비스의 신뢰성을 높입니다.\n유지 보수 용이성\r체계적인 문서 관리와 버전 관리를 통해 문서의 업데이트와 유지 보수를 쉽게 할 수 있습니다.\n문서 엔지니어링 도구\r문서 관리 시스템 (DMS)\r문서를 체계적으로 저장, 관리, 검색할 수 있도록 돕는 소프트웨어입니다.\n텍스트 편집기 및 워드 프로세서\r문서를 작성하고 편집하는 데 사용됩니다. Microsoft Word, Google Docs, LaTeX 등이 있습니다.\n협업 도구\r여러 사용자가 동시에 문서를 작성하고 편집할 수 있도록 지원합니다. Confluence, SharePoint, Google Workspace 등이 있습니다.\n결론\r문서 엔지니어링은 정보의 명확하고 체계적인 전달을 통해 사용자 경험을 향상시키고 조직의 효율성을 높이는 데 중요한 역할을 합니다. 효과적인 문서 엔지니어링을 위해서는 계획, 작성, 관리, 배포의 모든 과정에서 체계적인 접근이 필요합니다.","문서-엔지니어링-도구#문서 엔지니어링 도구":"","문서-엔지니어링의-중요성#문서 엔지니어링의 중요성":"","주요-요소#주요 요소":""},"title":"About"},"/docflow/docengr/process/":{"data":{"":"","#":"문서 엔지니어링은 문서의 체계적이고 효율적인 설계, 작성, 관리, 배포를 포함하는 포괄적인 과정입니다. 이를 통해 문서의 일관성, 정확성, 유지 보수 용이성을 보장하고, 사용자가 필요로 하는 정보를 효과적으로 전달합니다. 아래는 문서 엔지니어링의 주요 절차와 과정을 단계별로 자세히 설명한 내용입니다.\n1. 계획 및 분석\r목표 설정\r문서의 목적과 목표를 명확히 정의합니다. 예를 들어, 사용자 매뉴얼의 목적은 사용자가 소프트웨어를 효율적으로 사용할 수 있도록 돕는 것입니다.\n독자 분석\r문서의 주요 독자 그룹을 식별하고, 그들의 요구와 기대를 분석합니다. 예를 들어, 독자가 초보자인지 전문가인지에 따라 문서의 깊이와 복잡성을 조정합니다.\n요구 사항 수집\r문서에 포함될 주요 주제와 내용을 결정하기 위해 이해관계자와 협력하여 요구 사항을 수집합니다. 예를 들어, 제품 기능, 사용 방법, 유지 보수 절차 등을 포함합니다.\n2. 설계\r문서 구조 설계\r문서의 전반적인 구조와 목차를 설계합니다. 예를 들어, 매뉴얼의 경우, 소개, 설치, 기본 사용법, 고급 기능, 문제 해결 등의 섹션으로 구성할 수 있습니다.\n형식 및 스타일 가이드 설정\r문서의 형식과 스타일을 정의합니다. 예를 들어, 글꼴, 제목 수준, 강조 방법, 일관된 용어 사용 등을 규정합니다.\n콘텐츠 계획\r각 섹션에 포함될 세부 내용을 계획합니다. 필요한 정보, 데이터, 이미지, 다이어그램 등을 나열하고 배치합니다.\n3. 작성 및 개발\r초안 작성\r설계된 구조와 계획에 따라 문서의 초안을 작성합니다. 기술적인 설명, 절차, 예제 등을 포함하여 독자가 쉽게 이해할 수 있도록 합니다.\n시각적 자료 제작\r필요한 이미지, 다이어그램, 스크린샷 등을 생성하고 문서에 포함합니다. 시각적 자료는 텍스트를 보완하여 이해를 돕습니다.\n협업 및 피드백\r작성된 초안을 이해관계자와 공유하고 피드백을 수집합니다. 피드백을 반영하여 문서를 수정하고 개선합니다.\n4. 검토 및 수정\r기술 검토\r문서의 기술적인 정확성을 검토합니다. 기술 전문가가 내용을 검토하여 오류나 누락된 정보를 확인하고 수정합니다.\n편집 및 교정\r문서의 문법, 철자, 스타일을 검토하고 교정합니다. 일관성을 유지하고, 독자가 쉽게 이해할 수 있도록 문서를 다듬습니다.\n사용자 검토\r최종 사용자나 대표 사용자 그룹에게 문서를 검토하게 합니다. 사용자 관점에서 이해하기 어려운 부분이나 개선이 필요한 부분을 확인합니다.\n5. 관리 및 유지 보수\r버전 관리\r문서의 각 버전을 체계적으로 관리합니다. 주요 변경 사항을 기록하고, 버전 번호를 명시하여 추적 가능하게 합니다.\n접근 제어\r문서의 접근 권한을 설정하여 작성자, 편집자, 검토자 등의 역할에 따라 권한을 부여합니다. 보안이 필요한 문서의 경우, 접근 제한을 강화합니다.\n정기적 업데이트\r제품이나 서비스의 변경 사항을 반영하여 문서를 정기적으로 업데이트합니다. 새로운 기능 추가, 절차 변경, 오류 수정 등을 포함합니다.\n6. 배포 및 출판\r출판 형식 결정\r문서를 어떤 형식으로 출판할지 결정합니다. 예를 들어, PDF, 웹 페이지, 인쇄본 등 다양한 형식이 있을 수 있습니다.\n배포 채널 선택\r문서를 배포할 채널을 선택합니다. 웹사이트, 이메일, 고객 포털 등을 통해 문서를 배포하고, 필요한 경우 인쇄본을 제공할 수 있습니다.\n사용자 교육\r사용자에게 문서의 사용법과 주요 내용을 교육합니다. 교육 세션, 웨비나, 동영상 튜토리얼 등을 활용할 수 있습니다.\n7. 평가 및 피드백\r사용자 피드백 수집\r문서에 대한 사용자의 피드백을 수집합니다. 피드백을 통해 문서의 유용성, 이해도, 완성도를 평가합니다.\n개선 사항 반영\r수집된 피드백을 바탕으로 문서를 지속적으로 개선합니다. 필요에 따라 새로운 섹션을 추가하거나 기존 내용을 수정합니다.\n결론\r문서 엔지니어링은 체계적인 접근 방식을 통해 문서를 설계, 작성, 관리, 배포하는 과정입니다. 각 단계에서의 철저한 계획과 검토를 통해 문서의 품질을 높이고, 사용자에게 필요한 정보를 효과적으로 전달할 수 있습니다. 이를 통해 조직의 효율성을 증대시키고, 사용자의 만족도를 높일 수 있습니다."},"title":"Process"},"/docflow/staticsite/about/staticsite%EB%9E%80/":{"data":{"":"","blog를-위한-정적-사이트staticsite20blog20종류md의-장점#\u003ca href=\"StaticSite%20Blog%20%EC%A2%85%EB%A5%98.md\"\u003eblog를 위한 정적 사이트\u003c/a\u003e의 장점":"","매뉴얼를-위한-정적-사이트의-장점#매뉴얼를 위한 정적 사이트의 장점":"정적 사이트(Static Site)는 웹사이트의 모든 페이지가 미리 만들어져 있는 형태의 사이트입니다. 즉, 사용자가 웹사이트에 접속할 때마다 서버가 새로 내용을 만들어 보내는 것이 아니라, 이미 만들어진 파일들을 그대로 전송하는 방식으로 로딩 속도나 보안성 측면에서 유리하며. 특성상 간단한 블로그 이용이나 매뉴얼 배포에 큰 강점을 가집니다.\n정적 사이트의 장점\r빠른 로딩 속도\r빠른 로딩 속도: 정적 사이트는 미리 생성된 HTML 파일을 제공하기 때문에 로딩 속도가 매우 빠릅니다. 서버에서 요청을 받을 때마다 페이지를 생성할 필요가 없으므로, 사용자 경험이 크게 향상됩니다. 성능 최적화 : 정적 사이트는 성능 최적화가 쉽습니다. 예를 들어, CDN을 사용하여 배포하면 전 세계 어디서나 빠르게 페이지를 로드할 수 있습니다. 높은 보안성\r높은 보안성: 정적 사이트는 서버 측 스크립트나 데이터베이스가 없기 때문에 해킹의 표적이 될 가능성이 낮습니다. 단순히 파일을 제공하는 방식이므로 보안 문제를 최소화할 수 있습니다. 취약점 감소 : 워드프레스나 티스토리와 달리, 정적 사이트는 플러그인이나 테마 취약점으로 인한 보안 문제가 없습니다. 저렴한 호스팅 비용\r저렴한 호스팅 비용 : 정적 사이트는 서버 자원을 거의 사용하지 않기 때문에 저렴한 비용으로 호스팅할 수 있습니다. GitHub Pages와 같은 무료 호스팅 서비스를 이용할 수도 있고, Netlify 나 Vercel 등의 서비스를 저렴하게(초기에는 무료로) 이용할 수도 있습니다. 관리 비용 절감 : 워드프레스와 같은 CMS는 정기적인 업데이트와 유지보수가 필요하지만, 정적 사이트는 이러한 관리 비용이 거의 들지 않습니다. 쉬운 배포 및 관리\r정적 사이트는 파일을 업로드하는 방식으로 배포됩니다. 콘텐츠 수정이나 추가가 필요할 때 간단히 파일을 업데이트하면 됩니다. 정적 사이트는 서버 부하가 적기 때문에 트래픽이 급증해도 문제 없이 대응할 수 있습니다. 특히 CDN을 사용하면 여러 서버에 콘텐츠를 분산시켜 제공할 수 있습니다. 개발자 중심의 워크플로우\r버전 관리와 협업 : 정적 사이트는 Git과 같은 버전 관리 시스템과 잘 통합됩니다. 이를 통해 개발자들이 코드와 콘텐츠를 쉽게 관리하고 협업할 수 있습니다. 커스터마이징 가능성 : 개발자들은 정적 사이트 생성기를 사용하여 필요한 기능을 자유롭게 추가하고 커스터마이징할 수 있습니다. 정적 사이트의 단점\r동적 콘텐츠 한계\r정적 사이트는 실시간 데이터 업데이트나 사용자 상호작용이 필요한 동적 콘텐츠를 제공하는 데 한계가 있습니다. 댓글 시스템이나 사용자 로그인 같은 기능을 구현하기 어렵습니다. 복잡한 사이트 구조 관리 어려움\r페이지가 많아질수록 각 페이지를 개별적으로 관리하는 것이 복잡해질 수 있습니다. 이를 해결하기 위해서는 추가적인 자동화 도구나 스크립트를 사용해야 합니다. 빌드 시간이 길어질 수 있음\r사이트 규모가 커지면, 모든 페이지를 다시 생성하는 데 시간이 많이 걸릴 수 있습니다. 이를 해결하기 위해 증분 빌드(Incremental Build) 같은 기술을 사용할 수 있지만, 설정이 복잡할 수 있습니다. blog를 위한 정적 사이트의 장점\r블로그는 정적 사이트 방식으로 매우 쉽게 관리할 수 있습니다. 블로그 글을 작성하고, 작성된 글을 정적 사이트 생성기를 통해 간단히 웹사이트로 변환하여 배포할 수 있습니다.\n빠른 글 작성과 배포: 글을 마크다운 형식으로 작성하고, 정적 사이트 생성기로 변환하면 바로 배포할 수 있습니다. 유지 보수 용이: 추가적인 서버 관리가 필요 없으므로, 콘텐츠에만 집중할 수 있습니다. 매뉴얼를 위한 정적 사이트의 장점\r매뉴얼이나 설명서를 정적 사이트로 만들면 다음과 같은 장점이 있습니다.\n빠른 접근성: 매뉴얼을 빠르게 열 수 있어 사용자들이 원하는 정보를 즉시 찾을 수 있습니다. 검색 기능: 정적 사이트 생성기들은 검색 기능을 제공하여 사용자들이 필요한 내용을 쉽게 찾을 수 있게 합니다. 버전 관리: 업데이트가 쉬워서 새로운 버전을 신속하게 배포할 수 있습니다. ","정적-사이트의-단점#정적 사이트의 단점":"","정적-사이트의-장점#정적 사이트의 장점":""},"title":"StaticSite란"},"/docflow/staticsite/about/staticsite-%EC%83%9D%EC%84%B1%EA%B8%B0/":{"data":{"":"","정적-사이트-생성기의-종류#정적 사이트 생성기의 종류":"정적 사이트 생성기의 종류\r각 정적 사이트 생성기는 특정 용도와 요구사항에 따라 선택할 수 있습니다. 예를 들어, Gatsby는 대규모 데이터 소스를 사용하는 프로젝트에 적합하며, Hugo는 빠른 빌드 속도가 중요한 프로젝트에, Astro는 최신 웹 기술과 성능 최적화를 원하는 프로젝트에 적합합니다. Jekyll은 GitHub Pages와의 통합이 중요한 경우에, Docusaurus는 기술 문서화 작업에, MkDocs는 간단한 문서 사이트에 적합합니다.\nDocusaurus\r특징 : React 기반의 정적 사이트 생성기로, 문서화와 블로그 기능을 통합적으로 제공. 장점 : 빠른 시작과 설정, 강력한 문서화 기능, SEO 최적화, 다양한 플러그인 지원. 단점 : React에 대한 기본적인 이해가 필요하며, 복잡한 커스터마이징이 어려울 수 있음. Hugo\r특징 : Go 언어로 작성된 매우 빠른 정적 사이트 생성기. 장점 : 매우 빠른 빌드 속도와 다국어 지원. 단점 : 템플릿 언어가 다소 복잡할 수 있음. Jekyll\r특징 : Ruby 기반의 정적 사이트 생성기로, GitHub Pages와 잘 통합됨. 장점 : 설정이 간단하고 GitHub Pages에 무료로 호스팅 가능. 단점 : 대규모 사이트에서 빌드 시간이 길어질 수 있음. Gatsby\r특징 : React를 기반으로 한 정적 사이트 생성기로, GraphQL을 사용하여 데이터를 관리. 장점 : 동적 기능을 쉽게 추가할 수 있고, 다양한 플러그인 제공. 단점 : 초기 설정이 복잡할 수 있으며, 빌드 시간이 길어질 수 있음. Next.js (정적 사이트 생성 모드)\r특징 : React 기반의 프레임워크로, 정적 사이트 생성(SSG) 및 서버 사이드 렌더링(SSR)을 모두 지원. 장점 : 동적 콘텐츠와 정적 콘텐츠를 모두 쉽게 관리 가능. 단점 : 복잡한 설정과 학습 곡선이 있을 수 있음. Eleventy\r특징 : 단순성과 유연성을 중시한 정적 사이트 생성기. 장점 : 설정이 유연하고 다양한 템플릿 엔진을 지원. 단점 : 일부 고급 기능이 부족할 수 있음. Astro\r특징: JavaScript와 프레임워크 무관성을 강조하는 새로운 정적 사이트 생성기. 장점: 다양한 프레임워크(React, Vue, Svelte 등)를 함께 사용할 수 있으며, 성능 최적화에 강점이 있음. 단점: 상대적으로 새로운 도구이기 때문에 커뮤니티와 자료가 다른 도구들에 비해 부족할 수 있음. Hexo\r특징: Node.js 기반의 빠르고 간단한 정적 사이트 생성기. 장점: 설정이 간단하고 다양한 플러그인 및 테마를 지원. 단점: 대규모 사이트에서 빌드 시간이 길어질 수 있음. VuePress\r특징: Vue.js 기반의 정적 사이트 생성기. 장점: Vue.js를 사용한 쉽고 직관적인 설정, Vue 생태계와의 호환성. 단점: Vue.js에 대한 기본적인 이해가 필요함. Metalsmith\r특징: 매우 유연하고 플러그인 기반의 정적 사이트 생성기. 장점: 플러그인을 통해 거의 모든 것을 커스터마이즈 가능. 단점: 설정이 복잡할 수 있으며, 기본 기능이 제한적임. Gridsome\r특징: Vue.js를 기반으로 한 정적 사이트 생성기로, GraphQL을 사용하여 데이터를 관리. 장점: 동적 기능을 쉽게 추가할 수 있고, 다양한 플러그인 제공. 단점: 초기 설정이 복잡할 수 있으며, Vue.js에 대한 기본적인 이해가 필요함. graph TD A -.-\u003e B A --\u003e c"},"title":"StaticSite 생성기"},"/docflow/staticsite/guide/astro/astro-%EB%B9%8C%EB%93%9C/":{"data":{"":"","#":"","폴더-복사-생략#폴더 복사 생략":"Obsidian 볼트 obsidian/blog를 Astro로 빌드하여 정적 사이트를 만드는 과정을 단계별로 설명하겠습니다. 폴더 구조, 설정 파일 및 명령어를 포함한 전체적인 과정을 다룹니다.\n1. 환경 설정 및 프로젝트 준비\r1.1. 프로젝트 폴더 구조\r다음과 같은 구조로 프로젝트를 구성합니다:\nobsidian/ ├── astro-project/ │ ├── public/ │ │ ├── attachments/ # 이미지 파일 복사 위치 │ │ ├── copyCode.js │ │ └── styles.css │ ├── src/ │ │ ├── layouts/ │ │ │ └── DefaultLayout.astro │ │ └── pages/ │ │ ├── note1/ │ │ │ └── note1.md │ │ ├── note2/ │ │ │ └── note2.md │ │ └── note3/ │ │ └── note3.md │ ├── astro.config.mjs │ └── package.json └── blog/ ├── note1/ │ └── note1.md ├── note2/ │ └── note2.md ├── note3/ │ └── note3.md └── attachments/ # 이미지 및 기타 첨부 파일 폴더\r2. Astro 프로젝트 생성\r2.1. Astro 프로젝트 생성\rmkdir astro cd astro npm create astro@latest npm install\r3. Obsidian 콘텐츠 가져오기\r3.1. Obsidian 콘텐츠 복사\robsidian/blog/notes 폴더의 Markdown 파일을 astro-project/src/pages 폴더로 복사합니다.\n3.2. 이미지 파일 복사\robsidian/blog/attachments 폴더의 이미지를 astro-project/public/images 폴더로 복사합니다.\n4. Astro 설정 파일 구성\r4.1. astro.config.mjs 파일\rimport { defineConfig } from 'astro/config'; export default defineConfig({ site: 'https://yourdomain.com', // 사이트 도메인 markdown: { remarkPlugins: [], rehypePlugins: [ [ 'rehype-rewrite', { rewrite: (node) =\u003e { if (node.tagName === 'a' \u0026\u0026 node.properties.href) { node.properties.href = node.properties.href.replace('.md', '.html'); } }, }, ], ], }, });\r5. 빌드 및 배포\r5.1. 빌드 명령어 실행\rAstro 프로젝트를 빌드합니다.\nnpm run build\r6. 폴더 구조 요약\r최종 프로젝트 폴더 구조는 다음과 같습니다:\nobsidian/ ├── astro-project/ │ ├── public/ │ │ ├── attachments -\u003e ../blog/attachments # 심볼릭 링크 │ │ ├── copyCode.js │ │ └── styles.css │ ├── src/ │ │ ├── layouts/ │ │ │ └── DefaultLayout.astro │ │ └── pages/ │ │ ├── note1 -\u003e ../../blog/note1 # 심볼릭 링크 │ │ ├── note2 -\u003e ../../blog/note2 # 심볼릭 링크 │ │ ├── note3 -\u003e ../../blog/note3 # 심볼릭 링크 └── blog/ ├── note1/ │ └── note1.md ├── note2/ │ └── note2.md ├── note3/ │ └── note3.md └── attachments/ # 이미지 및 기타 첨부 파일 폴더\r폴더 복사 생략\rObsidian 폴더를 그대로 사용하여 Astro로 빌드하고, 파일 복사 과정을 생략하는 방법을 설명드리겠습니다. 이를 위해 심볼릭 링크를 사용하거나, Astro의 설정을 통해 Obsidian 폴더를 직접 참조하도록 구성할 수 있습니다.\n1. 심볼릭 링크 사용\r심볼릭 링크를 사용하면 Obsidian 폴더를 Astro 프로젝트에서 바로 참조할 수 있습니다.\n1.1. 프로젝트 폴더 구조\robsidian/ ├── work/ └── blog/ ├── notes/ # Obsidian 노트 폴더 └── attachments/ # 이미지 및 기타 첨부 파일 폴더 astro-project/ ├── public/ │ └── images/ # 이미지 파일에 대한 심볼릭 링크 ├── src/ │ └── pages/ # 노트 폴더에 대한 심볼릭 링크 └── astro.config.mjs └── package.json\r1.2. 심볼릭 링크 생성\ncd astro-project ln -s ../../obsidian/blog/notes src/pages ln -s ../../obsidian/blog/attachments public/images\r2. Astro 프로젝트 설정\r2.1. Astro 프로젝트 생성\rmkdir astro-project cd astro-project npm create astro@latest npm install\r3. 빌드 및 배포\r3.1. 빌드 명령어 실행\rAstro 프로젝트를 빌드합니다.\nnpm run build\r3.2. Cloudflare Pages 설정\rCloudflare 계정 생성 및 로그인: Cloudflare에 가입하고 로그인합니다. 새 프로젝트 추가: Cloudflare Pages 대시보드에서 “Create a project” 버튼을 클릭합니다. GitHub 또는 GitLab 리포지토리를 연결합니다. 배포 설정: 빌드 명령어: npm run build 빌드 출력 디렉토리: dist 배포 시작: 프로젝트 설정이 완료되면 자동으로 빌드가 시작되고 배포됩니다. 최종 프로젝트 폴더 구조 요약\rastro-project/ ├── public/ │ └── images -\u003e ../../obsidian/blog/attachments # 심볼릭 링크 ├── src/ │ └── pages -\u003e ../../obsidian/blog/notes # 심볼릭 링크 ├── astro.config.mjs └── package.json"},"title":"Astro 빌드"},"/docflow/staticsite/guide/common/%EB%B9%8C%EB%93%9C-%EC%8B%9C-public-%ED%8F%B4%EB%8D%94-%EC%A0%9C%EA%B1%B0/":{"data":{"":"","단점#단점":"","요약#요약":"","자동화#자동화":"요약\r빌드 시 public 폴더를 제거하는 것은 장단점이 있습니다. 깨끗한 빌드 환경을 유지하고 정확한 배포를 보장한다는 점은 유용하지만, 빌드 시간이 증가하고 리소스 낭비가 발생할 수 있습니다. 따라서 프로젝트의 규모와 빌드 시간을 고려하여 적절히 선택하는 것이 중요합니다. 개인적으로는 웹 게시 전 로컬 서버로 작업할 때 스크립트를 통해 자동 제거하도록 설정하여 사용하고 있습니다.\n장점\r깨끗한 빌드 환경 유지\r기존의 파일들이 남아 있어서 발생할 수 있는 문제를 방지합니다. 특히, 파일 삭제나 이름 변경이 있었을 경우, 이전 파일이 남아있어 혼란을 줄 수 있습니다. 빌드 과정에서 불필요한 파일이 포함될 가능성을 줄여 배포 파일 크기를 최소화합니다. 디버깅 용이\r불필요한 파일이 남아 있어 발생할 수 있는 오류를 예방할 수 있습니다. 빌드 후에 예상하지 못한 파일이 남아 있지 않으므로 디버깅이 수월합니다. 정확한 배포\r변경된 파일만 덮어쓰는 것이 아니라 모든 파일을 새로 생성하기 때문에, 배포 시 항상 최신 상태를 유지할 수 있습니다. 잘못된 캐시나 오래된 파일로 인한 배포 문제를 줄일 수 있습니다. 단점\r빌드 시간 증가\rpublic 폴더를 삭제하고 모든 파일을 다시 생성하기 때문에, 빌드 시간이 늘어날 수 있습니다. 대규모 프로젝트의 경우 빌드 시간이 상당히 증가할 수 있습니다. 리소스 낭비\r변경되지 않은 파일들도 다시 생성하기 때문에, 일부 리소스가 낭비될 수 있습니다. 네트워크 배포 시 변경되지 않은 파일도 재업로드되어 불필요한 트래픽이 발생할 수 있습니다. 배포 오류 위험\r빌드 중 문제가 발생하여 중단되면, public 폴더가 비어 있을 수 있어 배포 시 문제가 생길 수 있습니다. public 폴더가 삭제된 상태에서 빌드가 실패하면, 원래의 파일들이 모두 손실될 수 있습니다. 자동화\r스크립트\r@echo off :: public 폴더 삭제 rmdir /s /q public :: 휴고 빌드 hugo\rNPM 스크립트\r만약 Node.js 프로젝트로 관리 중이라면, package.json 파일의 스크립트 섹션에 아래와 같이 추가할 수 있습니다.\n{ \"scripts\": { \"clean\": \"rimraf public\", \"build\": \"hugo\", \"prebuild\": \"npm run clean\" } }\r여기서 rimraf 패키지를 사용하여 cross-platform으로 public 폴더를 삭제할 수 있습니다. rimraf 패키지를 설치하려면 다음 명령어를 실행하세요.\nnpm install rimraf --save-dev\r이제제 npm run build 명령어를 실행하면, public 폴더를 삭제한 후 휴고 빌드가 실행됩니다.","장점#장점":""},"title":"빌드 시 public 폴더 제거"},"/docflow/staticsite/guide/common/%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98%EC%B6%94%EA%B0%80/":{"data":{"":"\rD:\\Obsidian\\Aprofl_Hugo\u003enpm -y npm install electron --save-dev 'npm'은(는) 내부 또는 외부 명령, 실행할 수 있는 프로그램, 또는 배치 파일이 아닙니다. D:\\Obsidian\\Aprofl_Hugo\u003e\r패키지 설치 후 명령 실행 시 위와 같은 에러가 발생한다면 명령 프롬프트 다시 실행합니다. 다시 실행 후에도 동일한 에러가 발생한다면 PATH 환경변수를 추가합니다. 제어판 \u003e 시스템 및 보안 \u003e 시스템으로 이동. 고급 시스템 설정 클릭 환경 변수 버튼 클릭 시스템 변수 섹션에서 Path를 찾아 선택한 후 편집 클릭 새 항목으로 설치한 패키지의 경로를 추가합니다. 예를 들어, Node.js 설치 경로 (보통 C:\\Program Files\\nodejs\\`) 추가 확인을 눌러 모든 창을 닫고, 명령 프롬프트 다시 실행 "},"title":"환경변수 설정"},"/docflow/staticsite/guide/common/%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98-%EC%84%A4%EC%A0%95/":{"data":{"":"\n패키지 설치 후 명령 실행 시 위와 같은 에러가 발생한다면 명령 프롬프트 다시 실행합니다. 다시 실행 후에도 동일한 에러가 발생한다면 PATH 환경변수를 추가합니다. 제어판 \u003e 시스템 및 보안 \u003e 시스템으로 이동. 고급 시스템 설정 클릭 환경 변수 버튼 클릭 시스템 변수 섹션에서 Path를 찾아 선택한 후 편집 클릭 새 항목으로 설치한 패키지의 경로를 추가합니다. 예를 들어, Node.js 설치 경로 (보통 C:\\Program Files\\nodejs\\`) 추가 확인을 눌러 모든 창을 닫고, 명령 프롬프트 다시 실행 "},"title":"환경변수 설정"},"/docflow/staticsite/guide/common/node.js-%EC%84%A4%EC%B9%98/":{"data":{"":"","nodejs--npm-설치#Node.js \u0026amp; npm 설치":"","npm-버전-관리#NPM 버전 관리":"Node.js \u0026 npm 설치\rNode.js 공식 사이트에서 다운로드 및 설치 LTS(Long Term Support) 버전을 다운로드하는 것이 안정적입니다. 현재 권장 버전을 다운로드합니다. npm은 Node.js 패키지 관리자로, Node.js 설치 시 함께 설치됩니다 설치 확인\r설치가 완료된 후, 명령 프롬프트(CMD)나 PowerShell을 열고 다음 명령어를 입력하여 Node.js와 npm이 제대로 설치되었는지 확인합니다.\n\u003e node -v \u003e npm -v\rC:\\\u003enode -v v20.15.0 C:\\\u003enpm -v 10.8.1 C:\\\u003e\rnvm 을 이용한 버전 관리 (옵션)\rnvm-windows 다운로드 및 설치\rnvm-windows Releases 페이지로 이동합니다. 최신 릴리스의 nvm-setup.zip 파일을 다운로드합니다. 다운로드한 nvm-setup.zip 파일을 압축 해제한 후, nvm-setup.exe 파일을 실행합니다. 설치 마법사에 따라 설치를 진행합니다. 명령 프롬프트(CMD)나 PowerShell 이 실행중이라면 종료 후 재실행합니다. nvm으로 Node.js 설치\r설치 가능한 Node.js 버전 확인 \u003e nvm list available | CURRENT | LTS | OLD STABLE | OLD UNSTABLE | |--------------|--------------|--------------|--------------| | 22.2.0 | 20.14.0 | 0.12.18 | 0.11.16 | | 22.1.0 | 20.13.1 | 0.12.17 | 0.11.15 | | 22.0.0 | 20.13.0 | 0.12.16 | 0.11.14 | | 21.7.3 | 20.12.2 | 0.12.15 | 0.11.13 | | 21.7.2 | 20.12.1 | 0.12.14 | 0.11.12 | | 21.7.1 | 20.12.0 | 0.12.13 | 0.11.11 | | 21.7.0 | 20.11.1 | 0.12.12 | 0.11.10 | | 21.6.2 | 20.11.0 | 0.12.11 | 0.11.9 | | 21.6.1 | 20.10.0 | 0.12.10 | 0.11.8 | | 21.6.0 | 20.9.0 | 0.12.9 | 0.11.7 | | 21.5.0 | 18.20.3 | 0.12.8 | 0.11.6 | | 21.4.0 | 18.20.2 | 0.12.7 | 0.11.5 | | 21.3.0 | 18.20.1 | 0.12.6 | 0.11.4 | | 21.2.0 | 18.20.0 | 0.12.5 | 0.11.3 | | 21.1.0 | 18.19.1 | 0.12.4 | 0.11.2 | | 21.0.0 | 18.19.0 | 0.12.3 | 0.11.1 | | 20.8.1 | 18.18.2 | 0.12.2 | 0.11.0 | | 20.8.0 | 18.18.1 | 0.12.1 | 0.9.12 | | 20.7.0 | 18.18.0 | 0.12.0 | 0.9.11 | | 20.6.1 | 18.17.1 | 0.10.48 | 0.9.10 | This is a partial list. For a complete list, visit https://nodejs.org/en/download/releases \u003e\rNode.js 설치 원하는 버전의 Node.js를 설치합니다. \u003e nvm install node # 최신 버전 설치 \u003e nvm install lts # LTS 버전 설치\rNode.js 사용 설정 설치한 Node.js 버전을 사용 설정합니다. \u003e nvm use 14.17.0 # 14.17.0 버전 사용 \u003e nvm use lts # LTS 버전 사\rC:\\\u003envm use lts node v20.15.1 (64-bit) is not installed. C:\\\u003envm install lts Downloading node.js version 20.15.1 (64-bit)... Extracting node and npm... Complete npm v10.7.0 installed successfully. Installation complete. If you want to use this version, type nvm use 20.15.1 C:\\\u003envm use lts Now using node v20.15.1 (64-bit)\r설치 확인 Node.js와 npm이 제대로 설치되었는지 확인합니다. \u003e node -v \u003e npm -v\rNPM 버전 관리\rnvm (Node Version Manager)은 주로 Node.js 버전을 관리하는 도구입니다. 따라서, nvm을 사용하여 npm 버전만 별도로 변경할 수는 없습니다. 하지만, Node.js 버전과는 별도로 npm을 업데이트하거나 다운그레이드할 수 있습니다.\nnpm 버전을 변경하는 방법은 다음과 같습니다:\nnpm 업데이트\r최신 버전으로 업데이트 npm install -g npm@latest\r특정 버전으로 업데이트 npm install -g npm@{버전번호}\r``","nvm-을-이용한-버전-관리-옵션#nvm 을 이용한 버전 관리 (옵션)":"","설치-확인#설치 확인":""},"title":"Node.js 설치"},"/docflow/staticsite/guide/docusaurus/%EB%AC%B8%EC%84%9C%ED%8A%B9%ED%99%94-%EA%B8%B0%EB%8A%A5/":{"data":{"":"","#":"계층적 문서 구조는 문서를 체계적으로 관리하고 사용자에게 쉽게 접근할 수 있도록 하는 중요한 개념입니다. 이를 통해 문서의 내용이 논리적이고 일관성 있게 구성됩니다. 다음은 계층적 문서 구조의 주요 요소들입니다:\n주요 요소\r헤더 및 섹션:\n헤더: 문서의 제목이나 주요 섹션의 제목을 나타냅니다. 일반적으로 H1, H2, H3 등의 태그로 구분됩니다. 섹션: 문서의 주요 부분을 나누는 단위로, 각 섹션은 관련된 내용을 포함합니다. 하위 섹션:\n각 섹션은 다시 하위 섹션으로 나뉠 수 있으며, 이를 통해 문서의 내용을 더 세부적으로 구분할 수 있습니다. 예를 들어, H2 아래에 H3, H4 등의 하위 섹션이 올 수 있습니다. 목차:\n문서의 전체 구조를 한눈에 볼 수 있도록 목차를 제공합니다. 목차는 각 섹션과 하위 섹션으로 연결되어 있어 사용자가 원하는 내용을 빠르게 찾을 수 있습니다1. 링크 및 참조:\n문서 내에서 다른 섹션이나 외부 자료로의 링크를 제공하여, 관련된 정보를 쉽게 접근할 수 있도록 합니다. Docusaurus의 계층적 문서 구조\rDocusaurus는 이러한 계층적 문서 구조를 쉽게 구현할 수 있도록 도와줍니다:\n자동 목차 생성: Markdown 파일을 기반으로 자동으로 목차를 생성하여, 문서의 구조를 명확하게 보여줍니다2. 버전 관리: 여러 버전의 문서를 관리할 수 있어, 소프트웨어의 다양한 릴리스에 맞춘 문서 제공이 가능합니다2. 다국어 지원: 다양한 언어로 문서를 제공할 수 있어 글로벌 사용자에게 적합합니다. Astro의 계층적 문서 구조\rAstro도 계층적 문서 구조를 지원하지만, Docusaurus만큼 문서화에 특화된 기능은 부족할 수 있습니다:\nMarkdown 및 MDX 지원: Markdown과 MDX를 사용하여 문서를 작성할 수 있으며, 이를 통해 기본적인 계층적 구조를 구현할 수 있습니다3. 다양한 프레임워크 지원: 다양한 프레임워크와 호환되어 유연한 문서 구조를 만들 수 있습니다4. 결론\r계층적 문서 구조는 문서를 체계적으로 관리하고 사용자에게 쉽게 접근할 수 있도록 하는 중요한 개념입니다. Docusaurus는 이러한 구조를 쉽게 구현할 수 있는 다양한 기능을 제공하여 문서화에 특화된 도구로 적합합니다. 반면, Astro는 다양한 프레임워크를 지원하지만, 문서화에 특화된 기능은 상대적으로 부족할 수 있습니다."},"title":"문서특화 기능"},"/docflow/staticsite/guide/docusaurus/%EB%B9%8C%EB%93%9C-%EB%B0%8F-%EB%B0%B0%ED%8F%AC/":{"data":{"":"","빌드-및-배포#빌드 및 배포":"빌드 및 배포\rDocusaurus 사이트를 빌드하여 배포할 수 있습니다. 아래 명령어를 실행하여 정적 파일을 생성합니다: \u003e npm run build\r빌드가 완료되면 build 디렉토리에 정적 파일이 생성됩니다. 이 파일들을 원하는 호스팅 서비스에 업로드하여 배포할 수 있습니다. GitHub Pages 에 배포\r\u003e GIT_USER=\u003cYour GitHub Username\u003e USE_SSH=true npm run deploy\rOffline 용 Application 빌드\rTauri를 이용한 Application 빌드 "},"title":"빌드 및 배포"},"/docflow/staticsite/guide/docusaurus/%EC%82%AC%EC%9D%B4%EB%93%9C%EB%B0%94/":{"data":{"":"","#":"프론트 매터를 통한 순서 설정\r프론트 매터를 사용하여 문서의 순서를 명시적으로 설정할 수도 있습니다. 이를 위해 각 문서의 프론트 매터에 sidebar_position 속성을 추가합니다. sidebar_position 속성은 숫자로 순서를 정의합니다. 숫자가 낮을수록 사이드바에서 상위에 위치합니다.\n예를 들어, 다음과 같이 프론트 매터를 설정할 수 있습니다:\n# About\r3. 사이드바 자동 생성\r독사우루스는 autogenerated 옵션을 사용하여 폴더 구조에 따라 자동으로 사이드바를 생성할 수 있습니다. autogenerated 옵션을 사용하면 파일의 위치와 이름에 따라 사이드바가 자동으로 정렬됩니다.\n예를 들어, sidebars.js 파일을 다음과 같이 설정할 수 있습니다:\nmodule.exports = { docs: [ { type: 'autogenerated', dirName: '.', // 현재 디렉토리의 모든 문서를 포함 }, ], };\r이 경우, 프론트 매터의 sidebar_position 속성을 사용하여 순서를 조정할 수 있습니다."},"title":"사이드바"},"/docflow/staticsite/guide/docusaurus/%EC%84%A4%EC%A0%95/":{"data":{"":"\rmodule.exports = { title: 'My Site', tagline: 'Dinosaurs are cool', url: 'https://your-docusaurus-test-site.com', baseUrl: '/', onBrokenLinks: 'throw', onBrokenMarkdownLinks: 'warn', favicon: 'img/favicon.ico', organizationName: 'your-org', // GitHub 사용자명 또는 조직명 projectName: 'your-repo', // 저장소 이름 themeConfig: { navbar: { title: 'My Site', logo: { alt: 'My Site Logo', src: 'img/logo.svg', }, items: [ { to: 'docs/', activeBasePath: 'docs', label: 'Docs', position: 'left', }, {to: 'blog', label: 'Blog', position: 'left'}, { href: 'https://github.com/your-org/your-repo', label: 'GitHub', position: 'right', }, ], }, footer: { style: 'dark', links: [ { title: 'Docs', items: [ { label: 'Style Guide', to: 'docs/', }, { label: 'Second Doc', to: 'docs/doc2/', }, ], }, { title: 'Community', items: [ { label: 'Stack Overflow', href: 'https://stackoverflow.com/questions/tagged/docusaurus', }, { label: 'Discord', href: 'https://discordapp.com/invite/docusaurus', }, { label: 'Twitter', href: 'https://twitter.com/docusaurus', }, ], }, { title: 'More', items: [ { label: 'Blog', to: 'blog', }, { label: 'GitHub', href: 'https://github.com/facebook/docusaurus', }, ], }, ], copyright: `Copyright © ${new Date().getFullYear()} My Project, Inc. Built with Docusaurus.`, }, }, presets: [ [ '@docusaurus/preset-classic', { docs: { sidebarPath: require.resolve('./sidebars.js'), }, blog: { showReadingTime: true, }, theme: { customCss: require.resolve('./src/css/custom.css'), }, }, ], ], };"},"title":"설정"},"/docflow/staticsite/guide/docusaurus/%EC%84%A4%EC%B9%98/":{"data":{"":"","nodejs-설치nodejs20설치md#\u003ca href=\"Node.js%20%EC%84%A4%EC%B9%98.md\"\u003enode.js 설치\u003c/a\u003e":"","프로젝트-생성#프로젝트 생성":"node.js 설치\r프로젝트 생성\r프로젝트 디렉토리 생성\r터미널을 열고 프로젝트를 생성할 디렉토리로 이동합니다. md project cd project project \u003e Docusaurus 프로젝트 생성\r아래 명령어를 실행하여 Docusaurus 프로젝트를 생성합니다. \u003e npx @docusaurus/init@latest init aprofl_docu classic\r여기서 aprofl_docu는 프로젝트의 이름이며, classic은 Docusaurus의 기본 템플릿입니다 프로젝트 디렉토리 구조\r프로젝트가 생성되면 디렉토리 구조는 다음과 같습니다.\naprofl_docu ├── blog ├── docs ├── src │ ├── css │ └── pages ├── static ├── docusaurus.config.js ├── package.json └── sidebars.js\r로컬 서버 시작\r프로젝트 디렉토리로 이동한 후, 아래 명령어를 실행하여 로컬 개발 서버를 시작합니다. cd aprofl_docu npm run start\r이 명령어는 Docusaurus 개발 서버를 시작합니다. 브라우저에서 http://localhost:3000 URL을 열어 로컬 웹사이트를 확인할 수 있습니다. "},"title":"설치"},"/docflow/staticsite/guide/docusaurus/%EC%97%B0%EA%B2%B0/":{"data":{"":"","#":"옵시디언 폴더를 직접 참조하여 독사우루스 사이트를 빌드하려면 심볼릭 링크를 사용하거나 독사우루스 설정 파일에서 경로를 조정하는 방법이 있습니다. 여기서는 심볼릭 링크를 사용하여 옵시디언 폴더를 독사우루스의 docs 폴더로 참조하겠습니다.\n1. 심볼릭 링크 생성\r심볼릭 링크를 사용하면 옵시디언 폴더의 내용을 독사우루스 docs 폴더에서 참조할 수 있습니다. 다음 단계를 따라주세요.\n옵시디언 마크다운 파일들이 있는 폴더(예: path/to/obsidian/folder)를 찾습니다. 독사우루스 프로젝트의 docs 폴더를 삭제하거나 이름을 변경합니다. 터미널을 열고 독사우루스 프로젝트 폴더로 이동한 다음, 심볼릭 링크를 생성합니다. 2. 독사우루스 설정 파일 수정\r심볼릭 링크가 설정된 후, 독사우루스 설정 파일인 docusaurus.config.js 파일을 수정하여 올바른 경로를 참조하도록 합니다.\ndocusaurus.config.js 파일을 열고, 문서 경로를 확인하고 필요한 설정을 업데이트합니다."},"title":"연결"},"/docflow/staticsite/guide/docusaurus/%EC%9E%91%EC%84%B1/":{"data":{"":"","문서-작성#문서 작성":"문서 작성\rdocs 디렉토리에 Markdown 파일을 추가하여 문서를 작성할 수 있습니다. docs/intro.md 파일을 열고 다음과 같이 수정합니다. # Intro Hello. 사이드바 구성\rsidebars.js 파일을 열어 새로운 문서를 사이드바에 추가할 수 있습니다. 기본적으로 다음과 같이 구성됩니다 module.exports = { tutorialSidebar: [ { type: 'doc', id: 'intro', // 문서 ID }, // 다른 항목들... ], };\r설정 파일 수정\rdocusaurus.config.js 파일을 열어 사이트 설정을 변경할 수 있습니다. 예를 들어, 사이트 제목이나 URL을 변경할 수 있습니다 module.exports = { title: 'My Manual', tagline: 'Hello', url: 'https://your-docusaurus-test-site.com', baseUrl: '/', onBrokenLinks: 'throw', onBrokenMarkdownLinks: 'warn', favicon: 'img/favicon.ico', organizationName: 'your-org', // GitHub org/user name. projectName: 'your-project', // repo name. // 기타 설정들... };"},"title":"작성"},"/docflow/staticsite/guide/docusaurus/%ED%94%84%EB%A1%A0%ED%8A%B8%EB%A9%94%ED%83%80/":{"data":{"":"","#":"독사우루스에서 마크다운 문서를 작성할 때 프론트 매터(front matter)는 선택 사항이지만, 특정 기능을 사용하려면 포함하는 것이 좋습니다. 프론트 매터는 YAML 형식으로 작성되며, 문서의 메타데이터를 정의하는 데 사용됩니다. 아래는 독사우루스 문서에서 자주 사용하는 프론트 매터 항목들입니다.\n예시\r# Example Document\r다음은 프론트 매터를 포함한 마크다운 문서의 예시입니다:\n필수 항목 설명\rid: 문서의 고유 식별자입니다. 각 문서마다 유일해야 합니다. 한글 사용은 가능하지만 권장되지 않습니다. title: 문서의 제목입니다. 페이지의 \u003ctitle\u003e 태그로 사용되며, 문서의 주요 제목으로 표시됩니다. 추가 항목 (선택 사항)\r필수 항목 외에, 선택적으로 유용한 몇 가지 항목을 추가할 수 있습니다. 필요에 따라 다음 항목들을 포함할 수 있습니다:\nsidebar_label: 사이드바에 표시되는 레이블입니다. 문서의 제목을 간단하게 표현할 수 있습니다. 지정하지 않으면, 기본적으로 title 속성이 사이드바에 표시됩니다 description: 문서의 간단한 설명으로, SEO와 검색 결과에서 요약 문구로 사용됩니다. keywords: 문서와 관련된 키워드 목록으로, SEO 최적화에 도움이 됩니다. slug: 문서의 URL 경로를 정의합니다. 기본적으로는 id를 사용하지만, 필요에 따라 수정할 수 있습니다. sidebar_position: 사이드바에서 문서의 위치를 정의합니다. 숫자가 낮을수록 상위에 표시됩니다. # Example Document\r추가 항목\r```md\r# Example Document\r설명\rdescription: 문서의 간단한 설명입니다. tags: 문서에 적용할 태그 목록입니다. author: 문서의 작성자입니다. author_url: 작성자의 프로필 URL입니다. author_image_url: 작성자의 이미지 URL입니다. image: 문서와 관련된 이미지 URL입니다. hide_title: true로 설정하면 페이지에서 제목을 숨깁니다. hide_table_of_contents: true로 설정하면 페이지에서 목차를 숨깁니다. toc_min_heading_level: 목차에 포함할 최소 헤딩 레벨을 정의합니다. toc_max_heading_level: 목차에 포함할 최대 헤딩 레벨을 정의합니다. draft: true로 설정하면 문서를 초안 상태로 표시하여 배포하지 않습니다. date: 문서의 작성 날짜입니다. updated: 문서의 마지막 수정 날짜입니다. 프론트 매터의 값이 없는 경우, 일부 속성은 문제가 될 수 있으며, 일부는 문제가 되지 않을 수 있습니다. 빈 값을 정의하면 일부 도구나 파서가 이를 처리하지 못하고 오류를 발생시킬 수 있습니다.\n다음은 빈 값을 가질 때의 문제와 해결 방법에 대한 설명입니다:\n주요 항목별 빈 값 처리\rid: 빈 값일 경우 문서의 고유 식별자가 없으므로 문제가 발생합니다. 반드시 값을 입력해야 합니다. title: 빈 값일 경우 문서의 제목이 없으므로 문제가 발생합니다. 반드시 값을 입력해야 합니다. sidebar_label: 빈 값일 경우 사이드바에 표시될 레이블이 없으므로 문제가 발생할 수 있습니다. 기본적으로 title을 사용할 수 있지만 명시적으로 지정하는 것이 좋습니다. sidebar_position: 빈 값일 경우 사이드바에서 문서의 순서가 지정되지 않습니다. 필요하지 않으면 생략할 수 있습니다. slug: 빈 값일 경우 URL 경로가 없으므로 문제가 발생할 수 있습니다. 반드시 값을 입력해야 합니다. description: 빈 값이어도 큰 문제는 없지만 SEO에 영향을 줄 수 있습니다. keywords: 빈 값이어도 큰 문제는 없지만 SEO에 영향을 줄 수 있습니다. tags: 빈 값이어도 큰 문제는 없지만 문서 분류에 영향을 줄 수 있습니다. author: 빈 값이어도 큰 문제는 없습니다. author_url: 빈 값일 경우 문제는 없지만, 의미 없는 링크가 생성될 수 있습니다. author_image_url: 빈 값일 경우 문제는 없지만, 의미 없는 링크가 생성될 수 있습니다. image: 빈 값이어도 큰 문제는 없습니다. hide_title: false로 설정하면 제목을 숨기지 않습니다. true 또는 false로 설정하지 않으면 기본값을 사용합니다. hide_table_of_contents: false로 설정하면 목차를 숨기지 않습니다. true 또는 false로 설정하지 않으면 기본값을 사용합니다. toc_min_heading_level: 빈 값일 경우 기본값이 사용됩니다. toc_max_heading_level: 빈 값일 경우 기본값이 사용됩니다. draft: false로 설정하면 문서를 초안으로 표시하지 않습니다. true 또는 false로 설정하지 않으면 기본값을 사용합니다. date: 빈 값일 경우 문제가 발생할 수 있습니다. updated: 빈 값일 경우 문제가 발생할 수 있습니다. 프론트 매터가 없는 경우\r프론트 매터가 없더라도 기본적으로 문서가 작동하지만, 사이드바에 표시되거나 URL 경로가 자동으로 설정되지 않을 수 있습니다. 특히 대규모 문서 사이트를 관리할 때는 프론트 매터를 사용하는 것이 유용합니다.\n프론트 매터 없이 기본 문서\r프론트 매터 없이 작성된 문서도 독사우루스에서 인식할 수 있습니다. 예를 들어:\n# Welcome to Docusaurus This is a quick introduction to Docusaurus.\r이 경우 독사우루스는 파일 이름을 ID로 사용하고, 기본 설정을 적용하여 문서를 처리합니다.\nID 에 한글 사용\r독사우루스(Docusaurus)에서 id에 한글을 사용하는 것은 기술적으로 가능합니다. 그러나 몇 가지 고려사항이 있습니다. id는 문서의 고유 식별자이므로 URL 경로, 링크, 네비게이션 등 다양한 부분에서 사용됩니다.\n고려사항\rURL 인코딩 문제:\nid가 URL의 일부로 사용될 때 한글은 URL 인코딩이 필요합니다. 이로 인해 URL이 길어지고 가독성이 떨어질 수 있습니다. 호환성 문제:\n일부 시스템이나 브라우저에서는 비영어 문자를 처리하는 데 문제가 있을 수 있습니다. 이는 특히 국제적으로 널리 사용되는 경우 문제가 될 수 있습니다. 일관성 유지:\n프로젝트 전체에서 일관된 스타일을 유지하는 것이 좋습니다. 만약 영어와 한글이 혼합되어 사용된다면 유지보수성이 떨어질 수 있습니다. 권장사항\r가능하면 id에는 영어와 숫자를 사용하는 것이 좋습니다. 이는 가독성과 호환성을 높이고, URL 인코딩 문제를 피할 수 있습니다. 만약 한글을 사용해야 한다면, slug 속성을 사용하여 URL 경로를 별도로 지정하는 방법을 고려할 수 있습니다.\n예시\r한글 id 사용 예시\r# Example Document This is an example document with a Korean ID.\r이 경우 id는 한글을 사용하지만, URL 경로는 slug를 통해 영어로 지정됩니다.\n결론\r프론트 매터는 선택 사항이지만, 문서의 구조와 네비게이션을 명확하게 정의하고 사용자 경험을 향상시키기 위해 사용하는 것이 좋습니다. 필요에 따라 프론트 매터를 추가하거나 최소한으로 유지할 수 있습니다."},"title":"프론트메타"},"/docflow/staticsite/guide/docusaurus/id-%EC%84%A4%EC%A0%95/":{"data":{"":"","#":"","스크립트를-사용하여-url-인코딩-문제-해결#스크립트를 사용하여 URL 인코딩 문제 해결":"옵시디언의 링크 방식\r옵시디언은 마크다운 기반의 메모 및 문서 관리 애플리케이션으로, 내부 링크를 생성하는 데 사용되는 방식은 매우 직관적입니다. 옵시디언에서는 문서 제목을 그대로 링크로 사용합니다.\n예시:\n[[문서 제목]]\r옵시디언에서 문서 제목이 “테스트 진행\"인 경우, 내부 링크는 다음과 같이 작성됩니다:\n[[테스트 진행]]\r독사우루스의 링크 방식\r독사우루스는 정적 사이트 생성기로, 링크를 생성할 때 id를 사용하여 문서를 참조합니다. 이는 URL 경로로 사용되므로 URL 인코딩 문제를 방지하기 위해 영어와 숫자, 하이픈(-)만 사용하는 것이 좋습니다.\n예시:\n[링크 텍스트](/docs/문서-id)\r독사우루스에서 “테스트 진행” 문서를 참조하려면, 먼저 해당 문서에 id를 설정해야 합니다. 예를 들어, id를 test-progress로 설정한 경우, 링크는 다음과 같이 작성됩니다:\n[테스트 진행](/docs/test-progress)\r프론트 매터 없이 제목을 아이디로 사용하는 경우\r프론트 매터를 사용하지 않고 제목을 아이디로 사용할 경우, 한글과 띄어쓰기, 특수문자 등이 URL 인코딩 문제를 일으킬 수 있습니다. 이는 브라우저와 서버 간의 통신에서 문제가 될 수 있습니다.\n예시:\n옵시디언에서 “테스트 진행” 문서를 참조하는 링크:\n[테스트 진행](테스트%20진행)\r이는 독사우루스에서도 기본적으로 작동할 수 있지만, URL 인코딩 문제를 방지하기 위해 아이디를 변경하는 것이 좋습니다.\n스크립트를 사용하여 URL 인코딩 문제 해결\r문제점\r한글과 띄어쓰기 문제: 제목에 한글과 띄어쓰기가 포함된 경우 URL 인코딩 문제가 발생할 수 있습니다. 링크 정확성: 옵시디언의 내부 링크를 독사우루스에서 참조하도록 변환해야 합니다. 해결 방법\r아이디 생성: 문서 제목을 로마자로 변환하고, 띄어쓰기를 하이픈(-)으로 대체하여 URL 안전한 아이디를 생성합니다. 프론트 매터 추가: 각 문서에 프론트 매터를 추가하여 id와 title을 설정합니다. 내부 링크 변환: 옵시디언의 내부 링크를 독사우루스 형식으로 변환합니다. unidecode 설치\runidecode 모듈은 텍스트를 로마자로 변환하는데 사용되며, 이를 설치하기 위해 다음 명령어를 사용해야 합니다.\npip install unidecode\r스크립트 예시\rimport os import re from unidecode import unidecode def generate_id(title): id = unidecode(title) # 한글을 로마자로 변환 id = re.sub(r'\\s+', '-', id) # 띄어쓰기를 하이픈으로 대체 id = re.sub(r'[^\\w\\-]', '', id) # 특수문자 제거 id = id.strip('-').lower() # 양쪽 끝의 하이픈 제거 및 소문자 변환 return id def extract_keywords_and_tags(file_path): # 파일 경로에서 폴더 이름 추출 path_parts = os.path.normpath(file_path).split(os.sep) folder_names = path_parts[:-1] # 마지막 부분은 파일 이름이므로 제외 return folder_names def add_or_update_front_matter(file_path): with open(file_path, 'r', encoding='utf-8') as f: lines = f.readlines() # 파일이 비어 있는지 확인 if not lines: print(f\"File is empty: {file_path}\") return None, None # 코드 블록 안에 있는지 확인하는 함수 def is_within_code_block(index): in_code_block = False for i in range(index): if lines[i].strip().startswith(\"```\"): in_code_block = not in_code_block return in_code_block # 기존 프론트 매터가 있는지 확인 if lines[0].strip() == '---' and not is_within_code_block(0): front_matter_end = 1 while front_matter_end \u003c len(lines) and lines[front_matter_end].strip() != '---': front_matter_end += 1 front_matter_end += 1 front_matter = lines[:front_matter_end] content = lines[front_matter_end:] else: front_matter = [] content = lines # 프론트 매터 정보 추출 및 기본 값 설정 title = content[0].strip('# ').strip() id = generate_id(title) keywords_and_tags = extract_keywords_and_tags(file_path) keywords = ', '.join(keywords_and_tags) tags = ', '.join(keywords_and_tags) front_matter_dict = { 'id': id, 'title': title, 'description': '', 'keywords': keywords, 'tags': tags, 'sidebar_position': '1' } # 기존 프론트 매터가 있으면 비어있는 항목만 채우기 for line in front_matter: match = re.match(r'(\\w+):\\s*(.*)', line.strip()) if match: key, value = match.groups() if value: front_matter_dict[key] = value # 새로운 프론트 매터 생성 new_front_matter = ['---\\n'] for key, value in front_matter_dict.items(): new_front_matter.append(f'{key}: {value}\\n') new_front_matter.append('---\\n') # 파일에 새 프론트 매터와 기존 내용 결합하여 쓰기 with open(file_path, 'w', encoding='utf-8') as f: f.writelines(new_front_matter + content) return title, id def convert_internal_links(file_path, title_id_map): with open(file_path, 'r', encoding='utf-8') as f: content = f.read() # 코드 블록 안에 있는 링크를 무시하는 함수 def is_within_code_block(content, start_index): in_code_block = False for i in range(start_index): if content[i:i+3] == \"```\": in_code_block = not in_code_block return in_code_block def replace_link(match): link_title = match.group(1) link_id = title_id_map.get(link_title, generate_id(link_title)) return f'[{link_title}](/docs/{link_id})' # 링크를 변환하면서 코드 블록을 무시 new_content = [] index = 0 while index \u003c len(content): if content[index] == '[' and not is_within_code_block(content, index): match = re.match(r'\\[\\[([^\\]]+)\\]\\]', content[index:]) if match: new_content.append(replace_link(match)) index += len(match.group(0)) continue new_content.append(content[index]) index += 1 new_content = ''.join(new_content) with open(file_path, 'w', encoding='utf-8') as f: f.write(new_content) def process_markdown_files(directory): title_id_map = {} for root, _, files in os.walk(directory): for filename in files: if filename.endswith('.md'): file_path = os.path.join(root, filename) title, id = add_or_update_front_matter(file_path) if title and id: title_id_map[title] = id for root, _, files in os.walk(directory): for filename in files: if filename.endswith('.md'): file_path = os.path.join(root, filename) convert_internal_links(file_path, title_id_map) # 예시 디렉토리 경로 markdown_directory = r\"D:\\Obsidian\\aprofl_docu\\docs\" process_markdown_files(markdown_directory)\r설명\rgenerate_id(title): 제목을 로마자로 변환하고, 띄어쓰기를 하이픈으로 대체하여 id를 생성합니다. extract_keywords_and_tags(file_path): 파일 경로에서 폴더 이름을 추출하여 keywords와 tags로 사용합니다. add_or_update_front_matter(file_path): 기존 프론트 매터가 있는지 확인하고, 필요한 경우 항목을 추가하거나 수정합니다. 기본 항목으로 id, title, description, keywords, tags, sidebar_position을 설정합니다. convert_internal_links(file_path, title_id_map): 옵시디언의 내부 링크를 독사우루스 형식으로 변환합니다. process_markdown_files(directory): 지정된 디렉토리 내의 모든 마크다운 파일을 처리하여 프론트 매터를 추가하거나 수정하고, 내부 링크를 변환합니다. ","프론트-매터-없이-제목을-아이디로-사용하는-경우#프론트 매터 없이 제목을 아이디로 사용하는 경우":""},"title":"ID 설정"},"/docflow/staticsite/guide/docusaurus/intro/":{"data":{"":"","개요#개요":"","단점#단점":"개요\rDocusaurus는 오픈 소스 정적 사이트 생성기로, 주로 기술 문서화를 위해 사용됩니다. Docusaurus의 강력한 문서화 기능 중 몇 가지 주요 장단점은 다음과 같습니다:\n장점\rMarkdown 지원\rDocusaurus는 Markdown을 사용하여 문서를 작성할 수 있습니다. Markdown은 간단하고 직관적인 문서 작성 형식으로, 빠르고 효율적인 문서 작성을 가능하게 합니다. 자동 생성된 사이드바\rDocusaurus는 디렉토리 구조를 기반으로 자동으로 사이드바를 생성합니다. 이를 통해 문서의 구조를 쉽게 관리하고 네비게이션을 단순화할 수 있습니다. 버전 관리\rDocusaurus는 문서의 여러 버전을 쉽게 관리할 수 있는 기능을 제공합니다. 이는 소프트웨어의 여러 버전에 대한 문서를 관리할 때 유용합니다. 검색 기능\r내장된 강력한 검색 기능을 통해 사용자가 필요한 정보를 빠르게 찾을 수 있습니다. Algolia DocSearch와 같은 서비스를 쉽게 통합할 수도 있습니다. 다국어 지원\r다국어 지원을 통해 여러 언어로 문서를 작성하고 관리할 수 있습니다. 이를 통해 글로벌 사용자에게 쉽게 접근할 수 있습니다. 플러그인 시스템\r다양한 플러그인을 통해 기능을 확장할 수 있습니다. 예를 들어, Google Analytics 통합, PWA(Progressive Web App) 지원, SEO 최적화 등의 기능을 추가할 수 있습니다. React 기반\rDocusaurus는 React를 기반으로 하여 커스터마이징이 용이합니다. React 컴포넌트를 사용하여 문서를 확장하거나 커스터마이징할 수 있습니다. 정적 사이트 생성\rDocusaurus는 정적 사이트 생성기로서, 빠르고 안전한 웹사이트를 제공합니다. 정적 파일로 제공되기 때문에 로딩 속도가 빠르고, 보안 취약점이 적습니다. 테마 커스터마이징\r테마와 레이아웃을 쉽게 커스터마이징할 수 있어, 브랜드에 맞는 일관된 문서화 스타일을 유지할 수 있습니다. 커뮤니티와 생태계\r활발한 커뮤니티와 생태계를 가지고 있어, 다양한 리소스와 도움을 받을 수 있습니다. 공식 플러그인 외에도 커뮤니티에서 제공하는 다양한 플러그인과 테마를 활용할 수 있습니다. 단점\r설정의 복잡성\r초기 설정이 다소 복잡할 수 있습니다. JavaScript 의존성\r프로젝트에 Node.js와 npm이 필요합니다. ","장점#장점":""},"title":"Intro"},"/docflow/staticsite/guide/docusaurus/keywards-%EC%99%80-tags/":{"data":{"":"","#":"keywords와 tags는 독사우루스에서 문서나 블로그 글을 분류하고 검색 엔진 최적화를 도울 수 있는 메타데이터로 사용되지만, 두 개념에는 차이점이 있습니다. 다음은 keywords와 tags의 차이점에 대한 설명입니다.\n1. Keywords (키워드)\r주요 용도: keywords는 검색 엔진 최적화(SEO)를 위해 사용되며, 문서나 페이지와 관련된 주요 단어들을 나열합니다.\n위치: 주로 프론트 매터에서 사용됩니다.\n형식: 배열 형태로 나열됩니다.\n기능: 문서의 내용을 설명하는 핵심 단어들을 제공하여 검색 엔진이 해당 문서를 더 잘 인식할 수 있게 합니다.\n예시:\n2. Tags (태그)\r주요 용도: tags는 블로그 포스트나 문서의 주제나 카테고리를 지정하는 데 사용됩니다. 이는 사용자 인터페이스에서 해당 태그를 클릭하여 관련된 다른 글들을 쉽게 찾을 수 있도록 합니다.\n위치: 주로 블로그 포스트의 프론트 매터에서 사용됩니다.\n형식: 배열 형태로 나열됩니다.\n기능: 문서나 블로그 포스트를 특정 주제나 카테고리로 그룹화하여 관련 콘텐츠를 쉽게 찾을 수 있도록 돕습니다.\n예시:\n비교 요약\r특성 Keywords (키워드) Tags (태그) 주요 용도 SEO를 위한 검색어 제공 콘텐츠를 주제별로 그룹화 위치 문서 및 블로그 프론트 매터 주로 블로그 포스트 프론트 매터 형식 배열 형태 배열 형태 기능 검색 엔진 최적화, 검색 기능 강화 사용자 인터페이스에서 태그 클릭 시 관련 글 찾기 예시 keywords: [tutorial, docusaurus, guide] tags: [blog, tutorial, first-post] 결론\rkeywords는 검색 엔진 최적화와 문서 검색 기능 강화를 위해 사용되는 메타데이터입니다. tags는 블로그나 문서를 주제별로 그룹화하여 관련 콘텐츠를 쉽게 찾을 수 있도록 돕는 메타데이터입니다. 이 두 가지를 적절히 활용하면 사용자 경험을 향상시키고, 검색 엔진에서 문서의 가시성을 높일 수 있습니다."},"title":"Keywards 와 Tags"},"/docflow/staticsite/guide/docusaurus/seo/":{"data":{"":"","#":"기본 SEO 최적화 기능\r자동 메타 태그 생성\n타이틀: 각 문서의 제목을 \u003ctitle\u003e 태그로 자동 생성하여 검색 엔진이 문서의 제목을 인식할 수 있도록 합니다. 메타 설명: description 프론트 매터를 통해 메타 설명(\u003cmeta name=\"description\"\u003e)을 생성합니다. 이는 검색 결과에서 요약 문구로 표시됩니다. 키워드: keywords 프론트 매터를 통해 \u003cmeta name=\"keywords\"\u003e 태그를 생성합니다. Clean URLs\n독사우루스는 기본적으로 클린 URL을 사용합니다. 예를 들어, /docs/introduction 대신 /docs/introduction.html을 사용하지 않습니다. 모바일 최적화\n독사우루스는 모바일 기기에서도 잘 작동하도록 반응형 디자인을 기본적으로 지원합니다. 이는 검색 엔진에서 모바일 친화적인 사이트로 인식될 수 있습니다. 사용자 설정을 통한 추가 SEO 최적화\rOpen Graph 및 Twitter 카드 메타 태그\ndocusaurus.config.js 파일을 수정하여 Open Graph 및 Twitter 카드 메타 태그를 추가할 수 있습니다. 이를 통해 소셜 미디어에서 콘텐츠가 공유될 때 더 나은 미리보기를 제공합니다. module.exports = { // ...다른 설정들 themeConfig: { // ...다른 설정들 metadata: [ {name: 'keywords', content: 'docusaurus, documentation, blog'}, {name: 'description', content: 'A website for Docusaurus documentation and blog.'}, {property: 'og:title', content: 'Docusaurus'}, {property: 'og:description', content: 'A website for Docusaurus documentation and blog.'}, {property: 'og:type', content: 'website'}, {property: 'og:url', content: 'https://your-docusaurus-site.com'}, {property: 'og:image', content: 'https://your-docusaurus-site.com/img/logo.png'}, {name: 'twitter:card', content: 'summary_large_image'}, {name: 'twitter:title', content: 'Docusaurus'}, {name: 'twitter:description', content: 'A website for Docusaurus documentation and blog.'}, {name: 'twitter:image', content: 'https://your-docusaurus-site.com/img/logo.png'}, ], }, };\rXML 사이트맵\nXML 사이트맵을 생성하여 검색 엔진이 사이트 구조를 더 잘 이해하고 색인화할 수 있도록 합니다. @docusaurus/plugin-sitemap 플러그인을 사용하여 사이트맵을 생성할 수 있습니다. npm install @docusaurus/plugin-sitemap\rmodule.exports = { // ...다른 설정들 plugins: [ [ '@docusaurus/plugin-sitemap', { id: 'default', changefreq: 'weekly', priority: 0.5, }, ], ], };\rrobots.txt\n@docusaurus/plugin-robots-txt 플러그인을 사용하여 검색 엔진에 사이트 색인화를 제어할 수 있습니다. npm install @docusaurus/plugin-robots-txt\rmodule.exports = { // ...다른 설정들 plugins: [ [ '@docusaurus/plugin-robots-txt', { policy: [ { userAgent: '*', allow: '/', }, ], }, ], ], };\r결론\r독사우루스는 기본적으로 SEO 최적화에 유리한 기능을 제공하며, 사용자가 추가적인 설정을 통해 SEO를 더욱 향상시킬 수 있습니다. 기본 메타 태그 생성, 클린 URL, 모바일 최적화 등은 이미 기본 설정에 포함되어 있으며, Open Graph 및 Twitter 카드 메타 태그 추가, XML 사이트맵 생성, robots.txt 파일 설정 등을 통해 추가 최적화를 할 수 있습니다."},"title":"SEO"},"/docflow/staticsite/guide/hugo/%EB%8B%A4%EA%B5%AD%EC%96%B4-%EC%A7%80%EC%9B%90/":{"data":{"":"","#":"ko, en, ja 를 지원하고, ko를 기본으로 사용할 경우 설정은 다음과 같습니다.\n폴더 구조 설정\r프로젝트 폴더 구조는 다음과 같습니다. Obsidian의 blog 폴더를 ko 콘텐츠로 사용하고, en 및 ja 콘텐츠를 별도로 구성합니다.\nobsidian/ ├── blog/ │ ├── note1/ │ │ └── note1.md │ ├── note2/ │ │ └── note2.md │ ├── note3/ │ │ └── note3.md │ └── attachments/ # 이미지 및 기타 첨부 파일 폴더 hugo-project/ ├── content/ │ ├── en/ │ │ └── _index.md # 영어 콘텐츠 │ ├── ja/ │ │ └── _index.md # 일본어 콘텐츠 ├── config.toml └── themes/ └── doks/\rconfig.toml 파일 설정\rHugo의 config.toml 파일을 수정하여 다국어 설정을 추가하고 blog 폴더를 content/ko로 마운트합니다.\nbaseURL = \"https://example.com/\" languageCode = \"en-us\" title = \"My Hugo Site\" # 다국어 설정 [languages] [languages.ko] languageName = \"한국어\" weight = 1 contentDir = \"content/ko\" [languages.en] languageName = \"English\" weight = 2 contentDir = \"content/en\" [languages.ja] languageName = \"日本語\" weight = 3 contentDir = \"content/ja\" # 블로그 폴더 마운트 [module] [[module.mounts]] source = \"../blog\" target = \"content/ko\"\r다국어 네비게이션 설정\rDoks 테마에서 다국어 네비게이션을 설정하려면 config.toml 파일에 메뉴 항목을 추가해야 합니다.\n[menu] [[menu.main]] identifier = \"home\" name = \"Home\" url = \"/\" weight = 1 pre = \"ko: / | en: /en/ | ja: /ja/\" [[menu.main]] identifier = \"obsidian\" name = \"Obsidian\" url = \"/Obsidian/\" weight = 2 pre = \"ko: /about/ | en: /en/about/ | ja: /ja/about/\"\r다국어 스위처 추가\rDoks 테마에 언어 스위처를 추가하려면 layouts/partials/navbar.html 파일을 수정하여 언어 선택 링크를 추가합니다.\n{{ $currentLang := .Lang }} \u003cnav\u003e \u003c!-- 기존 네비게이션 코드 --\u003e \u003cul class=\"language-switcher\"\u003e {{ range .Site.Languages }} \u003cli\u003e \u003ca href=\"{{ .RelPermalink }}\" class=\"{{ if eq .Lang $currentLang }}active{{ end }}\"\u003e{{ .LanguageName }}\u003c/a\u003e \u003c/li\u003e {{ end }} \u003c/ul\u003e \u003c/nav\u003e"},"title":"다국어 지원"},"/docflow/staticsite/guide/hugo/%EB%B9%8C%EB%93%9C-%EC%8B%9C-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%8B%A4%ED%96%89/":{"data":{"":"","cloudflare-pages-설정#Cloudflare Pages 설정":"스크립트\rHugo 빌드 스크립트에서 파이썬 스크립트를 먼저 실행하고, 이후 Hugo 빌드를 실행하도록 설정합니다. 이를 위해 쉘 스크립트를 작성합니다.\nWindows용 스크립트\rbuild.bat라는 이름의 배치 파일을 작성합니다.\n@echo off REM 메타데이터 추가 스크립트 실행 python add_meta.py \u0026\u0026 REM 이미지 이름 및 참조경로 변경 스크립트 실행 python change_image_name.py hugo server --ignoreCache\r코드 설명\r@echo off\r이 명령은 배치 파일의 명령어를 실행할 때 화면에 표시되지 않도록 합니다. 즉, 배치 파일 내에서 실행되는 명령어를 숨깁니다. REM\rREM 명령은 주석을 표시하는 데 사용됩니다. 설명을 제공할 뿐 실제로 실행되지 않습니다. 여기서는 “이미지 링크 업데이트 스크립트 실행\"이라는 설명을 제공합니다. python add_meta.py\radd_meta.py라는 파이썬 스크립트를 실행합니다. 파이썬이 설치되어 있어야 하며, add_meta.py 파일이 배치 파일과 동일한 디렉토리에 있어야 합니다. \u0026\u0026 이 추가되면 각 단계가 실패했을 때 배치 파일 실행을 중지합니다. hugo –ignoreCache\rHugo를 사용하여 사이트를 빌드합니다. --ignoreCache 옵션은 Hugo가 캐시된 파일을 무시하고 새로 빌드하도록 합니다. 이 명령이 실행되면 Hugo가 설정 파일과 콘텐츠 파일을 사용하여 정적 사이트를 생성하고, public 디렉토리에 결과를 저장합니다. 로그 출력\r@echo off REM 메타데이터 추가 스크립트 실행 python add_meta.py if %errorlevel% neq 0 ( echo Error occurred in add_meta.py exit /b %errorlevel% ) REM 이미지 이름 및 참조경로 변경 스크립트 실행 python change_image_name.py if %errorlevel% neq 0 ( echo Error occurred in change_image_name.py exit /b %errorlevel% ) REM Hugo 서버 시작 및 캐시 무시 hugo server --ignoreCache if %errorlevel% neq 0 ( echo Error occurred in hugo server exit /b %errorlevel% )\r스크립트 실행\r명령 프롬프트를 열고 build.bat 스크립트가 위치한 디렉토리로 이동한 후 다음 명령을 실행합니다:\nbuild.bat\rCloudflare Pages 설정\rCloudflare Pages를 사용하여 Hugo 사이트를 배포할 수 있습니다. 이 과정에서 Cloudflare Pages 설정을 통해 빌드 시 파이썬 스크립트를 실행하도록 설정할 수 있습니다.\nCloudflare Pages 프로젝트를 설정합니다. 프로젝트 설정에서 Build Settings를 구성합니다. 빌드 명령어를 다음과 같이 설정합니다: python add_meta.py \u0026\u0026 hugo --minify\r빌드 출력 디렉토리를 public으로 설정합니다. ","스크립트#스크립트":""},"title":"빌드 시 스크립트 실행"},"/docflow/staticsite/guide/hugo/%EC%82%AC%EC%9D%B4%EB%93%9C%EB%B0%94-%EC%B6%94%EA%B0%80/":{"data":{"":"","사이드바가-지원되는-테마-사용#사이드바가 지원되는 테마 사용":"","폴더-구조#폴더 구조":"Hugo 자체적으로는 사이드바나 내비게이션을 기본적으로 제공하지 않습니다. 대신, 매우 유연한 템플릿 시스템을 제공하여 사용자나 테마 개발자가 사이드바나 내비게이션을 원하는 대로 구현할 수 있습니다.\n사이드바가 지원되는 테마 사용\r주로 기술 문서나 학습자료 등의 문서 사이트를 위한 테마입니다. 확장 가능한 트리형 사이드바를 옵션으로 제공합니다. Doks\r설치\rgit init git submodule add https://github.com/h-enk/doks.git themes/doks\r설정\rbaseURL = 'http://example.org/' languageCode = 'en-us' title = 'My New Wiki Site' theme = 'doks' [params] # Doks-specific settings disable_search = false disable_language_dropdown = false disable_version_dropdown = false [menu] [[menu.main]] identifier = \"home\" name = \"Home\" url = \"/\" weight = 1 [[menu.main]] identifier = \"blog\" name = \"Blog\" url = \"/blog/\" weight = 2\r테마 구성 파일 복사\rDoks 테마의 기본 구성 파일을 복사합니다 copy themes\\doks\\config\\_default\\config.toml config.toml\rDocsy\rDocsy 테마 적용 Book\r폴더 구조를 기반으로 한 사이드바 구현\r사용자 정의 템플릿 만들기\r사이드바는 왼쪽에 생성 확장 가능한 트리형 네비게이션 baseURL = 'http://example.org/' languageCode = 'en-us' title = 'Aprofl' theme = 'PaperMod' contentDir = \"content/Blog\" [params] author = \"Aprofl\" description = \"For productivity.\" ShowReadingTime = true ShowShareButtons = true ShowPostNavLinks = true layouts/partials/sidebar.html 파일 생성\r\u003caside\u003e \u003cul class=\"tree\"\u003e {{ range .Site.Menus.main }} \u003cli\u003e \u003cspan class=\"caret\"\u003e{{ .Name }}\u003c/span\u003e {{ if .Children }} \u003cul class=\"nested\"\u003e {{ range .Children }} \u003cli\u003e \u003ca href=\"{{ .URL }}\"\u003e{{ .Name }}\u003c/a\u003e \u003c/li\u003e {{ end }} \u003c/ul\u003e {{ end }} \u003c/li\u003e {{ end }} \u003c/ul\u003e \u003c/aside\u003e\rlayouts/_default/baseof.html 파일 수정\r\u003c!DOCTYPE html\u003e \u003chtml lang=\"{{ .Site.LanguageCode }}\"\u003e \u003chead\u003e {{ partial \"head.html\" . }} \u003clink rel=\"stylesheet\" href=\"{{ \"css/custom.css\" | relURL }}\"\u003e \u003c/head\u003e \u003cbody\u003e {{ partial \"header.html\" . }} \u003cdiv class=\"container\"\u003e \u003cdiv class=\"sidebar\"\u003e {{ partial \"sidebar.html\" . }} \u003c/div\u003e \u003cmain class=\"content\"\u003e {{ block \"main\" . }}{{ end }} \u003c/main\u003e \u003c/div\u003e {{ partial \"footer.html\" . }} \u003cscript src=\"{{ \"js/custom.js\" | relURL }}\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e\r사용자 정의 CSS 추가\rstatic/css/custom.css 파일을 생성하고 다음 CSS 스타일을 추가합니다: /* 레이아웃 설정 */ .container { display: flex; } .sidebar { width: 250px; margin-right: 20px; } .content { flex: 1; } /* 트리 메뉴 스타일링 */ ul.tree, ul.tree ul { list-style-type: none; padding-left: 20px; } ul.tree ul { display: none; } .caret { cursor: pointer; user-select: none; /* Prevent text selection */ } .caret::before { content: \"\\25B6\"; /* Right-pointing arrow */ color: black; display: inline-block; margin-right: 6px; } .caret-down::before { transform: rotate(90deg); /* Down-pointing arrow */ } .nested { display: none; } .active { display: block; }\r사용자 정의 JavaScript 추가\rstatic/js/custom.js 파일을 생성하고, 다음 JavaScript 코드를 추가합니다: document.addEventListener(\"DOMContentLoaded\", function() { var toggler = document.getElementsByClassName(\"caret\"); for (var i = 0; i \u003c toggler.length; i++) { toggler[i].addEventListener(\"click\", function() { this.parentElement.querySelector(\".nested\").classList.toggle(\"active\"); this.classList.toggle(\"caret-down\"); }); } });\r폴더 구조\rmyblog/ ├── archetypes/ ├── content/ │ ├── blog/ ├── layouts/ │ ├── partials/ │ │ └── sidebar.html │ ├── _default/ │ │ └── baseof.html ├── static/ │ ├── css/ │ │ └── custom.css │ ├── js/ │ │ └── custom.js ├── themes/ │ └── PaperMod/ └── config.toml","폴더-구조를-기반으로-한-사이드바-구현#폴더 구조를 기반으로 한 사이드바 구현":""},"title":"사이드바 추가"},"/docflow/staticsite/guide/hugo/%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%B0%B8%EC%A1%B0/":{"data":{"":"","요약#요약":"","이미지가-보이지-않는-경우-점검-사항#이미지가 보이지 않는 경우 점검 사항":"요약\rObsidian과 Hugo는 각각 이미지 참조 방식에 차이가 있어 호환성 문제가 발생할 수 있습니다. 이를 해결하기 위해 Obsidian의 설정을 변경하고, 이미지 링크를 수정하는 방법을 사용할 수 있습니다. Templater 플러그인을 활용하면 링크 수정을 자동화할 수 있으며, Hugo의 static 폴더에 이미지를 저장하여 경로 문제를 해결할 수 있습니다.\n호환되지 않는 이유\rObsidian의 이미지 참조 방식\rObsidian은 내부 링크와 이미지 포함을 고유한 형식으로 처리합니다.\n이미지를 추가할 때 기본적으로 다음과 같은 형식으로 추가됩니다. ![[Pasted image 20240608165739.png]]\r일반적인 마크다운 형식으로도 참조 가능합니다. Hugo의 이미지 참조 방식\rHugo는 정적 사이트 생성기로, 일반적인 마크다운 형식으로 이미지를 참조합니다. Hugo에서는 다음과 같은 형식을 사용합니다\n![image](resources/image_2020240608165739.png)\r이미지는 보통 static 폴더에 저장되며, 마크다운 파일 내에서 해당 경로를 사용하여 이미지를 참조합니다.\n호환 방법\rObsidian 설정 변경\rObsidian에서 이미지를 특정 폴더에 저장하도록 설정할 수 있습니다. 이를 통해 Hugo와의 호환성을 높일 수 있습니다.\n이미지 링크 수정\rObsidian에서 이미지를 추가한 후, 링크를 일반적인 마크다운 형식으로 수정합니다.\n공백이 있으면 안됩니다. ![image_20240608165739](Resources/image_20240608165739.png)\r스크립트를 이용한 일괄 변경\rTemplater 플러그인을 이용한 변경 자동화\r이 작업은 수동으로 수행해야 하지만, Templater 플러그인을 사용하여 자동화할 수 있습니다. 다만, 이 방식은 참조용이고, 스크립트를 통해 진행 할 예정입니다.\n이미지가 보이지 않는 경우 점검 사항\r로컬 서버 URL 확인\r브라우저에서 http://localhost:1313/resources/docflow.png 경로로 접근해 이미지가 표시되는지 확인합니다. 표시되지 않는다면 public/Resouces 폴더에서 dockflow.png 파일이 있는지 확인합니다. 없다면 마운트 설정을 확인해봅니다.\n마운트 확인\r[[mounts]] source = \"../DocFlow/Resources\" target = \"static/Resources\"\r위 코드는 프로젝트 폴더와 동일한 계층에 있는 dockFlow/Resources 폴더를 프로젝트 폴더의 static 폴더로 마운트 시킵니다. 빌드를 진행하면 static 폴더의 내용이 Public/Resources 폴더로 복사 됩니다. 페이지 소스 링크 확인\r확인 방법\r이미지가 보이지 않는 페이지에서 마우스를 우클릭하고 페이지 소스 보기를 선택합니다. ctrl + F 키를 입력하고, docflow.png 를 검색합니다.\n\u003cimg src=\"Resources/docflow.png\" alt=\"DockFlow\" /\u003e\r위와 같이 보인다면 상대주소로 설정이 되어 있는 것이며, 상대주소 참조 방식에 따라 이미지 참조가 되지 않을 수 있습니다. src=\"Resources/docflow.png\" 부분을 클릭합니다. 이동된 주소가 이미지의 위치와 다르다면, 주소 참조 방식을 변경해야 합니다. 만, 간단하게 절대 주소 참조 방식으로 변경합니다.\n수정 방법\r`/node_modules/@hyas/images/layouts/_default/_markup/render-image.html’ 파일을 수정합니다. {{ $renderHookName := \"image\" }} {{ $minHugoVersion := \"0.114.0\" }} {{ if lt hugo.Version $minHugoVersion }} {{ errorf \"The %q render hook requires Hugo v%s or later.\" $renderHookName $minHugoVersion }} {{ end }} {{ $errorLevel := or site.Params.render_hooks.image.errorLevel \"ignore\" | lower }} {{ if not (in (slice \"ignore\" \"warning\" \"error\") $errorLevel) }} {{ errorf \"The %q render hook is misconfigured. The errorLevel %q is invalid. Please check your site configuration.\" $renderHookName $errorLevel }} {{ end }} {{ $contentPath := \"\" }} {{ with .Page.File }} {{ $contentPath = .Path }} {{ else }} {{ $contentPath = .Path }} {{ end }} {{ $u := urls.Parse .Destination }} {{ $msg := printf \"The %q render hook was unable to resolve the destination %q in %s\" $renderHookName $u.String $contentPath }} {{ $r := \"\" }} {{ if $u.IsAbs }} {{ with resources.GetRemote $u.String }} {{ with .Err }} {{ if eq $errorLevel \"warning\" }} {{ warnf \"%s. See %s\" . $contentPath }} {{ else if eq $errorLevel \"error\" }} {{ errorf \"%s. See %s\" . $contentPath }} {{ end }} {{ else }} {{ $r = . }} {{ end }} {{ else }} {{ if eq $errorLevel \"warning\" }} {{ warnf $msg }} {{ else if eq $errorLevel \"error\" }} {{ errorf $msg }} {{ end }} {{ end }} {{ else }} {{ with .Page.Resources.Get (strings.TrimPrefix \"./\" $u.Path) }} {{ $r = . }} {{ else }} {{ with (and (ne .Page.BundleType \"leaf\") (.Page.CurrentSection.Resources.Get (strings.TrimPrefix \"./\" $u.Path))) }} {{ $r = . }} {{ else }} {{ with resources.Get (printf \"resources/%s\" $u.Path) }} {{ $r = . }} {{ else }} {{ if eq $errorLevel \"warning\" }} {{ warnf $msg }} {{ else if eq $errorLevel \"error\" }} {{ errorf $msg }} {{ end }} {{ end }} {{ end }} {{ end }} {{ end }} {{ if $r }} {{ $id := printf \"h-rh-i-%d\" .Ordinal }} {{ with .Attributes.id }} {{ $id = . }} {{ end }} {{ if ne $r.MediaType.SubType \"gif\" }} {{ $r = $r.Resize (printf \"%dx%d webp\" $r.Width $r.Height) }} {{ end }} \u003cimg src=\"{{ $r.RelPermalink | absURL }}\" width=\"{{ string $r.Width }}\" height=\"{{ string $r.Height }}\" decoding=\"{{ site.Params.hyas_images.defaults.decoding }}\" fetchpriority=\"{{ site.Params.hyas_images.defaults.fetchpriority }}\" loading=\"{{ site.Params.hyas_images.defaults.loading }}\" alt=\"{{ .PlainText }}\" {{ with .Title }}title=\"{{ . }}\"{{ end }} id=\"{{ $id }}\" /\u003e {{ else }} \u003cimg src=\"{{ .Destination | absURL }}\" alt=\"{{ .PlainText }}\" {{ with .Title }}title=\"{{ . }}\"{{ end }} /\u003e {{ warnf \"Image not found: %s\" .Destination }} {{ end }}\r수정된 내용은 다음과 같습니다.\n이미지 참조 경로를 절대주소로 변경합니다. 참조 실패 시 에러메세지를 출력합니다. 참고\r브라우저 캐시 지우기\r브라우저 캐시에 의해 수정된 내용이 바로 반영되지 않을 수 있습니다. 변경 후에도 동일한 문제가 발생한다면 브라우저 캐시를 지우고 페이지를 다시 로드합니다.","호환-방법#호환 방법":"","호환되지-않는-이유#호환되지 않는 이유":""},"title":"이미지 참조"},"/docflow/staticsite/guide/hugo/%EC%B0%B8%EC%A1%B0%EB%A7%81%ED%81%AC/":{"data":{"":"","문단참조#문단참조":"문제점\rObsidian과 Hugo 간의 링크 호환성 문제 해결\rObsidian에서 상대경로로 설정된 링크는 Hugo에서 제대로 작동하지 않을 수 있습니다. Hugo는 기본적으로 링크를 처리할 때 상대경로를 기준으로 하여 현재 페이지의 경로에 따라 링크를 해석하기 때문에 Obsidian에서 설정한 상대경로 링크가 Hugo에서 의도한 대로 작동하지 않을 수 있습니다.\n절대경로 사용의 일관성 유지\r링크를 절대경로로 설정하면, 경로의 변화에 영향을 받지 않고 항상 정확한 위치를 가리킬 수 있습니다. 이는 특히 프로젝트 구조가 복잡하거나 여러 폴더에 걸쳐 있는 경우에 중요합니다. 절대경로를 사용하면 링크가 항상 일관된 경로를 유지하므로 링크 오류를 줄일 수 있습니다.\nHugo의 빌드 과정에서 발생하는 경로 문제 해결\rHugo는 baseURL을 기준으로 모든 링크를 처리합니다. baseURL을 올바르게 설정하고, 모든 링크를 절대경로로 변환함으로써 이러한 문제를 해결할 수 있습니다.\n해결방안\rObsidian 링크 경로 변경\rObsidian에서 상대경로로 설정된 링크를 절대경로로 변경합니다. 예를 들면 다음과 같습니다.\n[옵시디언이란](obsidian/about/옵시디언이란)\rrender-link.html 파일 수정\rbaseURL 을 설정한 후에도 Obsidian 과 Hugo의 절대경로에는 차이가 발생할 수 있습니다. 보통 프로젝트나 폴더의 구조 차이로 발생하는데, 예를 들면 다음과 같습니다.\nbaseURL 이 localHost 인 상태에서 [옵시디언이란](obsidian/about/옵시디언이란) 이 링크를 걸면 휴고는 주소를 다음과 같이 해석합니다. http://localhost:1313/obsidian/about/옵시디언이란\r하지만 프로젝트 구조나 마운트 설정 등에 따라 실제 파일은 다음의 위치에 있을 수 있습니다.\nhttp://localhost:1313/docs/staticsite/obsidian/about/옵시디언이란\r이 때, baseURL 을 http://localhost:1313/docs/staticsite/ 로 바꾸면 일반 페이지 링크에 문제가 발생합니다.\n즉, 링크 주소만 바꿔야 하는 경우 추가되는 주소를 render-link.html 을 통해 설정할 수 있습니다.\n\\node_modules\\@hyas\\doks-core\\layouts\\_default\\_markup\\render-link.html {{ if (strings.HasPrefix .Destination \"mailto\") -}} {{ with .Text -}} {{ partial \"main/email\" (dict \"emailAddress\" $.Destination \"emailTitle\" .) }} {{ else -}} {{ partial \"main/email\" (dict \"emailAddress\" $.Destination) }} {{ end -}} {{ else -}} {{ $link := .Destination | relURL }} {{ if not (strings.HasPrefix $link \"/docs/staticsite\") -}} {{ $link = printf \"/docs/%s\" $link }} {{ end -}} \u003ca href=\"{{ $link | safeURL }}\"{{ with .Title}} title=\"{{ . }}\"{{ end }}\u003e{{ .Text | safeHTML }}\u003c/a\u003e {{- end -}}\r문단참조\rObsidian에서 문단을 참조하는 형식인 /obsidian/guide#test와 같은 링크도 Hugo에서 호환될 수 있습니다. #test는 해당 페이지 내의 앵커 링크를 나타내며, 페이지가 로드되면 지정된 위치로 스크롤됩니다.\n다음은 문단 참조가 포함된 링크를 Hugo와 호환되게 설정하는 과정입니다:","문제점#문제점":"","해결방안#해결방안":""},"title":"참조링크"},"/docflow/staticsite/guide/hugo/%EC%B6%94%EC%B2%9C%ED%85%8C%EB%A7%88/":{"data":{"":"","#":"SEO 최적화와 검색 최적화를 감안하여 Hugo 테마를 추천드리겠습니다. 앞서 언급한 기능들(사이드바, 다크 모드, 다중 언어 지원) 외에도 SEO 최적화 기능을 잘 지원하는 테마들입니다.\n1. PaperMod\r특징:\n사이드바: 깔끔한 사이드바 네비게이션 제공. 다크 모드: 다크 모드 지원. 다중 언어 지원: 다중 언어 지원 기능 내장. SEO 최적화: 기본적인 SEO 설정이 잘 되어 있으며, 추가적인 메타 태그 설정 가능. 심플함: 미니멀한 디자인과 빠른 로딩 속도. 기타: Open Graph 및 Twitter Card 지원. 링크: PaperMod\n2. Docsy\r특징:\n사이드바: 문서화에 최적화된 사이드바 네비게이션. 다크 모드: 다크 모드 지원. 다중 언어 지원: 다양한 언어를 손쉽게 추가 및 관리. SEO 최적화: 기본적인 SEO 설정 및 추가적인 설정 가능. 심플함: 구글의 Docsy 테마를 기반으로 한 심플하고 직관적인 디자인. 기타: 구조화된 데이터 및 SEO 관련 메타 태그 지원. 링크: Docsy\n3. Minimo\r특징:\n사이드바: 깔끔한 사이드바 네비게이션 제공. 다크 모드: 다크 모드 지원. 다중 언어 지원: 다중 언어 지원 기능 내장. SEO 최적화: 기본적인 SEO 설정이 잘 되어 있으며, Google Analytics와 같은 툴과 통합 가능. 심플함: 미니멀한 디자인과 사용자 친화적인 인터페이스. 기타: Open Graph 및 Twitter Card 지원. 링크: Minimo\n4. Jane\r특징:\n사이드바: 편리한 사이드바 네비게이션. 다크 모드: 다크 모드 지원. 다중 언어 지원: 다중 언어 지원 기능 내장. SEO 최적화: SEO 최적화를 위한 다양한 설정 및 추가 가능. 심플함: 간결한 디자인과 쉬운 설정. 기타: Open Graph 및 Twitter Card 지원. 링크: Jane\n5. LoveIt\r특징:\n사이드바: 커스터마이징 가능한 사이드바 네비게이션. 다크 모드: 다크 모드 지원. 다중 언어 지원: 다중 언어 지원 기능 내장. SEO 최적화: 기본적인 SEO 설정이 잘 되어 있으며, 추가적인 설정 가능. 심플함: 직관적이고 심플한 디자인. 기타: 구조화된 데이터 및 SEO 관련 메타 태그 지원. 링크: LoveIt\n6. Hello Friend NG\rSEO 최적화: SEO 최적화가 잘 되어 있습니다. Dark Mode 지원: 다크 모드를 지원합니다. Sidebar 기본 지원: 사이드바를 기본적으로 제공합니다. 다국어 지원: 다국어 지원이 가능합니다. 반응형: 반응형 디자인으로 모든 기기에서 잘 작동합니다. 심플함: 매우 심플하고 깔끔한 디자인을 자랑합니다. 검색 최적화: 검색 기능이 내장되어 있습니다3. "},"title":"추천테마"},"/docflow/staticsite/guide/hugo/%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC%EC%99%80-%ED%83%9C%EA%B7%B8/":{"data":{"":"","#":"카테고리와 태그는 콘텐츠를 분류하고 조직하는 데 사용되는 두 가지 주요 개념입니다. 둘 다 콘텐츠를 체계적으로 정리하는 데 도움이 되지만, 그 용도와 범위는 다릅니다. 아래는 카테고리와 태그의 차이점에 대한 설명입니다.\n카테고리 (Categories)\r목적:\n광범위한 분류: 카테고리는 콘텐츠를 넓은 주제나 섹션으로 구분하는 데 사용됩니다. 계층적 구조: 카테고리는 계층적 구조를 가질 수 있습니다. 즉, 하위 카테고리가 상위 카테고리의 일부가 될 수 있습니다. 기본 분류: 콘텐츠를 조직하는 기본적인 방법입니다. 특징:\n광범위한 주제: 카테고리는 일반적으로 콘텐츠의 주제나 섹션을 나타냅니다. 계층 구조: 카테고리는 부모-자식 관계를 가질 수 있습니다. 수량: 보통 하나의 콘텐츠는 하나 또는 소수의 카테고리에 속합니다. 네비게이션: 사이트의 구조나 메뉴에서 사용됩니다. 예시:\n블로그 사이트에서의 카테고리: Tech, Lifestyle, Travel, Programming. 기술 블로그에서의 카테고리: Programming, Data Science, DevOps. 태그 (Tags)\r목적:\n세부적인 분류: 태그는 콘텐츠를 더 세부적으로 분류하고, 특정 주제나 키워드와 연관시키는 데 사용됩니다. 비계층적 구조: 태그는 계층 구조가 없습니다. 모든 태그는 독립적입니다. 다양한 키워드: 콘텐츠의 다양한 측면을 나타내는 키워드입니다. 특징:\n구체적인 키워드: 태그는 특정 주제나 키워드를 나타냅니다. 비계층 구조: 태그는 계층 구조를 갖지 않습니다. 수량: 하나의 콘텐츠는 여러 개의 태그를 가질 수 있습니다. 검색 및 필터링: 사용자가 특정 키워드로 콘텐츠를 검색하고 필터링하는 데 사용됩니다. 예시:\n블로그 게시물에서의 태그: Go, Hugo, Tutorial, JavaScript, CSS. 요리 블로그에서의 태그: Dessert, Quick Recipes, Vegetarian, Gluten-Free. 요약\r특징 카테고리 (Categories) 태그 (Tags) 분류의 범위 넓은 주제, 섹션 세부적인 주제, 키워드 구조 계층적 (부모-자식 관계 가능) 비계층적 (독립적) 수량 하나 또는 소수의 카테고리 여러 개의 태그 사용 용도 사이트 구조, 네비게이션 검색, 필터링, 관련 콘텐츠 연결 실전 예시\r콘텐츠의 프론트매터\r--- title: \"How to Use Tags and Categories\" date: 2024-07-19T12:00:00Z categories: - Programming - Tutorial tags: - Hugo - Taxonomy - Front Matter ---"},"title":"카테고리와 태그"},"/docflow/staticsite/guide/hugo/%ED%85%8C%EB%A7%88-%EC%84%A4%EC%B9%98/":{"data":{"":"","설정#설정":"설치\rHugo와 Node.js 설치\rHyas와 Doks 템플릿을 사용하여 프로젝트 생성\rnpm create hyas@latest Aprofl_Hugo -- --template doks cd DocFlow_Hugo\r프로젝트의 의존성 설치\rnpm install\r개발 서버 시작\rhugo server\rD:\\Obsidian\\DocFlow_Hugo\u003ehugo server Watching for changes in D:\\Obsidian\\DocFlow_Hugo\\{assets,content,layouts,node_modules,package.json,static} Watching for config changes in D:\\Obsidian\\DocFlow_Hugo\\config\\_default, D:\\Obsidian\\DocFlow_Hugo\\config\\_default\\menus Start building sites … hugo v0.127.0-74e0f3bd63c51f3c7a0f07a7c779eec9e922957e+extended windows/amd64 BuildDate=2024-06-05T10:27:59Z VendorInfo=gohugoio | EN -------------------+----- Pages | 29 Paginator pages | 0 Non-page files | 0 Static files | 13 Processed images | 4 Aliases | 4 Cleaned | 0 Built in 438 ms Environment: \"development\" Serving pages from disk Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop\r웹 브라우저에서 http://localhost:1313을 열어 Doks 템플릿이 적용된 사이트를 확인할 수 있습니다. 설정\rcontent 폴더에 md 파일을 채웁니다. 중요한 점은\n폴더별 _index.md 파일이 있어야 합니다. 파일 자동 추가 방법 참조 _index.md 파일을 포함하여 모든 파일에는 메타데이터 가 있어야 합니다. 메타데이터 자동 추가 방법 참조 ","설치#설치":""},"title":"테마 설치"},"/docflow/staticsite/guide/hugo/_index.md/":{"data":{"":"","_indexmd-파일의-예제#\u003ccode\u003e_index.md\u003c/code\u003e 파일의 예제":"개요\r_index.md 파일은 Hugo에서 섹션(폴더)의 인덱스 페이지를 정의하는 데 사용되는 특별한 Markdown 파일입니다. 이 파일은 폴더의 메타데이터와 콘텐츠를 설정하며, 각 섹션의 인덱스 페이지에 대한 다양한 설정을 정의할 수 있습니다. _index.md 파일은 주로 섹션의 제목, 설명, 정렬 순서, SEO 설정 등을 지정하는 데 사용됩니다.\n역할과 기능\r섹션의 메타데이터 설정 _index.md 파일을 통해 섹션의 제목, 설명, 날짜, 수정 날짜, 드래프트 상태, 가중치, 목차 등의 메타데이터를 설정할 수 있습니다.\rSEO 최적화\rSEO 관련 메타데이터를 설정하여 검색 엔진 최적화를 도울 수 있습니다. 예를 들어, 제목, 설명, 캐노니컬 URL, 인덱스 여부 등을 지정할 수 있습니다. 콘텐츠 포함\r섹션의 인덱스 페이지에 표시될 콘텐츠를 _index.md 파일에 직접 작성할 수 있습니다. 테마와의 연동\r특정 테마, 특히 Doks와 같은 고급 테마는 _index.md 파일을 사용하여 섹션의 레이아웃과 스타일을 커스터마이즈할 수 있습니다. 이를 통해 일관된 디자인과 사용자 경험을 제공할 수 있습니다. 언제 _index.md 파일이 필요하지 않을 수 있는가?\r단순한 사이트 구조\r모든 폴더가 단순히 콘텐츠 파일(.md 파일)만 포함하고 있고, 추가적인 메타데이터나 정렬이 필요하지 않은 경우 _index.md 파일이 필요하지 않을 수 있습니다. 테마의 기본 설정\r일부 테마는 기본적으로 모든 섹션에 대해 특정 레이아웃과 메타데이터를 제공하므로 _index.md 파일이 없어도 기본 설정이 적용됩니다. _index.md 파일이 없는 경우\r특정 테마에서 _index.md 파일이 없으면, 해당 섹션의 기본 설정이 적용되지만, 다음과 같은 문제를 겪을 수 있습니다:\n메타데이터 누락\r섹션의 SEO 최적화나 기타 메타데이터 설정이 누락될 수 있습니다. 기본 레이아웃 적용\r특정 섹션의 인덱스 페이지가 기본 레이아웃으로 표시될 수 있습니다. _index.md 파일의 예제","개요#개요":"","역할과-기능#역할과 기능":"","주요-필드#주요 필드":" title: 섹션의 제목을 정의합니다. 이는 섹션의 인덱스 페이지에 표시됩니다. description: 섹션에 대한 설명입니다. 주로 검색 엔진이나 미리보기에서 사용됩니다. summary: 섹션의 요약입니다. 페이지나 게시물의 요약으로 표시되며, 검색 결과나 목록에서 사용될 수 있습니다. date: 섹션의 생성 날짜와 시간입니다. lastmod: 섹션의 마지막 수정 날짜와 시간입니다. draft: 섹션이 초안 상태인지 여부를 나타냅니다. true로 설정하면 섹션이 사이트 빌드 시 포함되지 않습니다. weight: 섹션의 정렬 순서를 제어합니다. 낮은 숫자가 더 높은 우선 순위를 가집니다. toc: 섹션의 목차(Table of Contents) 표시 여부를 제어합니다. seo: SEO 최적화를 위한 설정을 포함합니다. title: SEO를 위한 맞춤 제목입니다. description: SEO를 위한 맞춤 설명입니다. canonical: SEO를 위한 맞춤 캐노니컬 URL입니다. noindex: 검색 엔진에서 인덱싱하지 않도록 설정합니다. "},"title":"_index.md"},"/docflow/staticsite/guide/hugo/config.toml/%ED%8F%B4%EB%8D%94-%EB%B0%8F-%ED%8C%8C%EC%9D%BC/":{"data":{"":"","hugotoml-vs-configtoml#Hugo.toml vs Config.toml":"폴더 구조\robsidian/ └── blog/ ├── post1.md ├── post2.md └── ... blog_hugo/ ├── archetypes/ ├── content/ ├── layouts/ ├── static/ ├── themes/ ├── config.toml\r폴더 및 파일 설명\rarchetypes/: Hugo에서 새로운 콘텐츠를 생성할 때 사용할 템플릿이 저장되는 디렉토리입니다. content/: 사이트의 콘텐츠 파일이 저장되는 디렉토리입니다. layouts/: Hugo 템플릿 파일이 저장되는 디렉토리입니다. partials/: 사이트의 일부(예: 사이드바)를 정의하는 파셜 템플릿이 저장되는 폴더입니다. sidebar.html: 트리 구조의 사이드바를 정의하는 템플릿 파일입니다. _default/: 기본 레이아웃 템플릿이 저장되는 폴더입니다. baseof.html: 모든 페이지에 공통으로 적용되는 기본 레이아웃 파일입니다. static/: 정적 파일(CSS, JavaScript 등)이 저장되는 디렉토리입니다. css/: 사용자 정의 CSS 파일이 저장되는 폴더입니다. custom.css: 트리 구조 사이드바의 스타일을 정의하는 CSS 파일입니다. js/: 사용자 정의 JavaScript 파일이 저장되는 폴더입니다. custom.js: 트리 구조 사이드바의 확장/축소 기능을 구현하는 JavaScript 파일입니다. themes/: Hugo 테마가 저장되는 디렉토리입니다. PaperMod/: PaperMod 테마가 저장되는 폴더입니다. config.toml: Hugo 사이트의 설정 파일입니다. Hugo.toml vs Config.toml\rHugo는 설정 파일의 이름을 자유롭게 지정할 수 있는 기능을 제공하며, 기본적으로는 config.toml을 사용하지만, 다른 이름의 파일을 사용할 수도 있습니다. 최상위 폴더에 hugo.toml 파일이 있는 경우, 이는 프로젝트의 설정 파일로 사용되고 있을 가능성이 큽니다. Hugo는 기본적으로 config.toml을 찾지만, 특정 설정 파일을 명시적으로 지정할 수 있습니다.\n설정 파일의 관계\rconfig.toml Hugo의 기본 설정 파일입니다. 이 파일이 존재하면 Hugo는 이 파일을 사이트의 설정으로 사용합니다. hugo.toml 프로젝트에서 설정 파일의 이름을 hugo.toml로 지정했다면, 이 파일이 사이트의 설정을 정의합니다. Hugo는 여러 설정 파일을 병합하거나 우선 순위를 두고 사용하는 기능을 제공하지 않습니다. 따라서 여러 설정 파일이 있는 경우, 명시적으로 사용할 파일을 지정해야 합니다. 설정 파일 지정 방법\rHugo는 실행 시 특정 설정 파일을 명시적으로 지정할 수 있습니다. 예를 들어, hugo.toml 파일을 사용하려면 다음과 같이 명령어를 사용할 수 있습니다\nhugo server --config hugo.toml","폴더-구조#폴더 구조":"","폴더-및-파일-설명#폴더 및 파일 설명":""},"title":"폴더 및 파일"},"/docflow/staticsite/guide/hugo/config.toml/imaging/":{"data":{"":"","imaging-섹션#\u003ccode\u003e[imaging]\u003c/code\u003e 섹션":"[imaging] 설정은 웹사이트에서 사용되는 이미지의 품질과 처리 방식을 제어합니다. 적절한 리샘플링 필터, 압축 품질, 앵커 포인트 설정을 통해 이미지가 최적의 품질과 성능을 발휘할 수 있도록 합니다. 이러한 설정을 통해 사이트의 시각적 요소를 향상시키고, 사용자 경험을 개선할 수 있습니다.\n[imaging] 섹션\rresampleFilter\rresampleFilter = \"CatmullRom\"\rresampleFilter는 이미지를 리샘플링할 때 사용할 필터를 설정합니다. 리샘플링 필터는 이미지를 축소하거나 확대할 때 픽셀 데이터를 보간하는 방식입니다. 다양한 필터가 있으며, 각 필터는 이미지 품질과 처리 속도에 영향을 미칩니다. Filter 종류\rCatmull-Rom 필터 Catmull-Rom 스플라인 필터는 부드러운 이미지를 생성하는 데 효과적입니다. 이미지가 흐릿해지지 않도록 유지하면서 선명한 가장자리를 보장합니다. 이는 고품질 이미지 리샘플링에 적합합니다. Nearest 가장 빠른 방법으로 픽셀을 가장 가까운 이웃으로 보간합니다. 빠르지만 품질이 낮습니다. Linear 선형 보간을 사용하여 속도와 품질 간의 균형을 맞춥니다. Cubic 큐빅 보간을 사용하여 이미지 품질을 높입니다. Lanczos 고품질 보간 필터로 이미지의 디테일을 유지합니다. quality\rquality = 75\rquality는 이미지의 압축 품질을 설정합니다. 이 값은 1에서 100 사이의 정수로 설정되며, 높은 값일수록 이미지 품질이 좋지만 파일 크기가 커집니다. 반대로 낮은 값은 이미지 품질을 낮추고 파일 크기를 줄입니다. 예시\rquality = 75는 이미지 품질과 파일 크기 사이의 균형을 맞추는 적당한 설정입니다. 일반적으로 웹에서는 70~80 사이의 값이 품질과 성능을 모두 만족시키는 데 적합합니다. anchor\ranchor = \"smart\"\ranchor는 이미지 크롭(crop) 시 기준점을 설정합니다. 이 기준점을 기준으로 이미지를 자르게 됩니다. smart 설정은 이미지의 주요 부분을 자동으로 감지하여 크롭합니다. 특히 인물 사진이나 특정 주요 요소가 있는 이미지에서 유용합니다. 이미지를 자를 때 중요한 부분이 잘리지 않도록 보장합니다. 기타 값\rcenter: 이미지의 중앙을 기준으로 크롭합니다. top: 이미지의 상단을 기준으로 크롭합니다. bottom: 이미지의 하단을 기준으로 크롭합니다. left: 이미지의 왼쪽을 기준으로 크롭합니다. right: 이미지의 오른쪽을 기준으로 크롭합니다. "},"title":"Imaging"},"/docflow/staticsite/guide/hugo/config.toml/markup/":{"data":{"":"","markup-섹션#\u003ccode\u003e[markup]\u003c/code\u003e 섹션":"","예시-마크다운-파일#예시 마크다운 파일":"[markup] 섹션은 마크다운과 코드 하이라이팅 설정을 정의합니다. 이 섹션은 사이트의 콘텐츠를 어떻게 렌더링하고 스타일링할지를 설정하는 중요한 부분입니다.\n[markup] 섹션\r[markup.goldmark]\rGoldmark 마크다운 렌더러 설정 Goldmark는 Hugo에서 사용되는 마크다운 렌더러로, 빠르고 확장성이 뛰어나며 CommonMark 표준을 준수합니다. [markup.goldmark.parser.attribute]\rGoldmark 파서 설정 block = true 블록 수준의 속성 파서를 활성화합니다. 예를 들어, 특정 블록 요소에 ID나 클래스를 지정하여 스타일을 적용할 수 있습니다. 다음과 같이, 마크다운 제목에 ID와 클래스를 추가할 수 있습니다. # 제목 {#custom-id .custom-class}\r`[markup.goldmark.renderer]\rGoldmark 렌더러 설정 unsafe = true 안전하지 않은 HTML 렌더링을 허용합니다. 마크다운 파일 내의 HTML 태그를 렌더링할 수 있도록 허용합니다. 보안상의 이유로 기본적으로 Hugo는 마크다운 내의 HTML 태그를 렌더링하지 않습니다. 이 설정을 활성화하면 사용자 정의 HTML을 마크다운 콘텐츠 내에서 사용할 수 있습니다. 다음과 같이, 마크다운 파일 내에 HTML 태그를 포함할 수 있습니다. \u003cdiv class=\"custom-div\"\u003e \u003cp\u003e이것은 사용자 정의 HTML 블록입니다.\u003c/p\u003e \u003c/div\u003e\r[markup.highlight]\r코드 하이라이팅 설정\n코드 하이라이팅은 프로그래밍 코드 블록을 시각적으로 강조하는 기능으로, 코드의 가독성을 높이고 이해하기 쉽게 만듭니다.\nstyle = \"tango\"\n하이라이팅 스타일을 tango로 설정합니다. tango는 Pygments 라이브러리에서 제공하는 여러 스타일 중 하나입니다. 이 스타일은 다양한 색상을 사용하여 코드의 각 부분을 시각적으로 구분합니다. 다른 스타일 예시\rmonokai: 어두운 배경에 밝은 색상을 사용하는 인기 있는 스타일 github: GitHub에서 사용하는 코드 하이라이팅 스타일 vs: Visual Studio에서 사용하는 스타일 각 스타일은 코드의 가독성을 높이고 다양한 환경에서 보기 좋게 만들기 위해 설계되었습니다.\n예시 마크다운 파일\r다음은 설정된 [markup] 옵션을 활용하는 예시 마크다운 파일입니다:\n# 마크다운 제목 {#custom-id .custom-class} 이것은 블록 수준의 속성을 가진 제목입니다. ```html \u003cdiv class=\"custom-div\"\u003e \u003cp\u003e이것은 사용자 정의 HTML 블록입니다.\u003c/p\u003e \u003c/div\u003e\r위 HTML 블록은 unsafe 설정이 활성화되어 있기 때문에 렌더링됩니다."},"title":"MarkUp"},"/docflow/staticsite/guide/hugo/config.toml/permalinks/":{"data":{"":"","permalinks-설정#Permalinks 설정":"","사용-가능한-permalink-변수#사용 가능한 Permalink 변수":"[permalinks] 는 사이트의 각 섹션에 대해 URL 구조를 정의하는 데 사용되는 설정으로, 이를 통해 더 일관되고 사용자 친화적인 URL을 만들 수 있습니다. 각 섹션별로 다른 URL 패턴을 지정할 수 있으며, 이를 통해 SEO 최적화와 사용자 경험을 개선할 수 있습니다.\nPermalinks 설정\rHugo에서 permalinks 섹션은 각 섹션의 URL 패턴을 정의합니다. 여기서 섹션은 콘텐츠 디렉토리 내의 폴더를 의미합니다. 예를 들어, content/blog 폴더는 blog 섹션이 됩니다.\n예제 설정\r[permalinks] blog = \"/:section/:year/:month/:day/:slug/\"\r위 설정은 blog 섹션의 콘텐츠 URL 형식을 정의합니다.\nURL 패턴의 각 요소 설명\r/:section/: 콘텐츠가 속한 섹션 이름입니다. 예를 들어, content/blog 섹션은 blog가 됩니다. /:year/: 콘텐츠의 연도입니다. 콘텐츠가 게시된 연도를 포함합니다. /:month/: 콘텐츠의 월입니다. 콘텐츠가 게시된 월을 포함합니다. /:day/: 콘텐츠의 일입니다. 콘텐츠가 게시된 날짜를 포함합니다. /:slug/: 콘텐츠의 슬러그입니다. 일반적으로 콘텐츠의 제목을 기반으로 하며, URL에 사용할 수 있는 형태로 변환됩니다. 예제 콘텐츠\r예를 들어, content/blog/hello-world.md 파일이 있다면, 이 파일의 메타데이터는 다음과 같습니다:\n이 설정에 따르면, 이 블로그 게시물의 URL은 다음과 같이 생성됩니다:\n/blog/2024/06/13/hello-world/\r다른 섹션에 대한 Permalinks 설정\r각 섹션별로 다른 URL 패턴을 정의할 수 있습니다. 예를 들어, content/obsidian 섹션에 대해 다른 URL 패턴을 설정하고 싶다면 다음과 같이 설정할 수 있습니다\n[permalinks] blog = \"/:section/:year/:month/:day/:slug/\" obsidian = \"/:section/:title/\"\r위 설정에서는 obsidian 섹션의 URL 패턴을 /obsidian/제목/ 형식으로 정의합니다. Hugo에서 여러 섹션에 대해 동일한 permalink 설정을 적용하려면, 각 섹션별로 명시적으로 설정을 정의해야 합니다. 여러 섹션에 동일한 permalink 설정을 한 번에 적용하는 기능은 제공하지 않습니다. 예를 들어, 블로그와 옵시디언 섹션이 있고, 두 섹션 모두 동일한 permalink 패턴을 사용하고 싶다면 다음과 같이 설정합니다:\n[permalinks] blog = \"/:section/:year/:month/:day/:slug/\" obsidian = \"/:section/:year/:month/:day/:slug/\"\r사용 가능한 Permalink 변수\rHugo에서는 여러 가지 변수를 사용하여 URL 패턴을 정의할 수 있습니다. 주요 변수들은 다음과 같습니다:\n:year: 콘텐츠가 게시된 연도 (예: 2024) :month: 콘텐츠가 게시된 월 (예: 06) :day: 콘텐츠가 게시된 일 (예: 13) :title: 콘텐츠의 제목 (예: Hello World) :slug: 콘텐츠의 슬러그 (예: hello-world) :section: 콘텐츠가 속한 섹션 (예: blog) :filename: 콘텐츠 파일의 이름 (확장자 제외) "},"title":"Permalinks"},"/docflow/staticsite/guide/hugo/config.toml/taxonomies/":{"data":{"":"","paramstaxonomy#params.taxonomy":"","taxonomies#Taxonomies":"","taxonomies-설정-예시#Taxonomies 설정 예시":"","taxonomies-설정-의미#Taxonomies 설정 의미":"Taxonomies\rTaxonomies는 Hugo에서 콘텐츠를 분류하고 정리하는 데 사용되는 메커니즘입니다. Taxonomies 설정을 통해 Hugo 사이트의 콘텐츠를 더 잘 조직하고 사용자에게 관련 콘텐츠를 쉽게 탐색할 수 있는 방법을 제공합니다. 만약 이러한 기능이 필요하지 않다면 taxonomies 설정을 생략할 수 있지만, 이는 콘텐츠 관리와 사용자 경험 측면에서 제한이 될 수 있습니다. 일반적으로 태그(tag)와 카테고리(category)가 가장 많이 사용됩니다.\n[taxonomies] tag = \"tags\" category = \"categories\"\r이 섹션은 사이트에서 사용할 taxonomies를 정의합니다. 여기서는 두 가지 taxonomies를 정의하고 있습니다:\ntag = \"tags\" 태그는 여러 게시물에 적용할 수 있는 키워드입니다. 예를 들어, 특정 주제를 가진 여러 게시물에 같은 태그를 달 수 있습니다. 여기서 tag는 단수형 이름이고 tags는 URL에서 사용할 복수형 이름입니다. category = \"categories\" 카테고리는 게시물을 분류하는 더 광범위한 그룹입니다. 예를 들어, 블로그의 큰 주제별로 카테고리를 나눌 수 있습니다. category는 단수형 이름이고 categories는 URL에서 사용할 복수형 이름입니다. Taxonomies 설정 예시\r위와 같이 설정했을 때, 다음과 같이 컨텐츠에 메타데이터를 추가하여 Taxonomies를 적용할 수 있습니다.\n옵시디언 기능에 대한 안내 페이지입니다.\rparams.taxonomy\rtaxonomies의 추가 설정을 정의합니다.\n[params.taxonomy] taxonomyCloud = [\"tags\", \"categories\"] taxonomyCloudTitle = [\"Tag Cloud\", \"Categories\"] taxonomyPageHeader = [\"tags\", \"categories\"]\rtaxonomyCloud = [\"tags\", \"categories\"] 이 설정은 태그 클라우드와 카테고리 클라우드를 표시할 taxonomies를 지정합니다. 태그 클라우드와 카테고리 클라우드는 해당 항목의 분포를 시각적으로 나타낸 것입니다. taxonomyCloudTitle = [\"Tag Cloud\", \"Categories\"] 이 설정은 태그 클라우드와 카테고리 클라우드의 제목을 지정합니다. 각 항목은 taxonomyCloud 배열의 항목과 일치해야 합니다. taxonomyPageHeader = [\"tags\", \"categories\"] 이 설정은 페이지 헤더에 표시할 taxonomies를 지정합니다. 페이지 헤더에 태그와 카테고리가 표시됩니다. Taxonomies 설정 의미\rTaxonomies를 설정하지 않으면 Hugo는 기본적으로 콘텐츠를 태그와 카테고리로 분류하지 않습니다. 이는 사이트 방문자가 콘텐츠를 특정 주제나 그룹으로 쉽게 검색하거나 필터링할 수 없다는 의미입니다. 구체적으로는 다음과 같은 영향을 미칩니다:\nTaxonomies를 설정하지 않을 경우의 영향\r태그와 카테고리 기능 비활성화\r콘텐츠에 태그나 카테고리를 지정해도, 이를 통해 콘텐츠를 그룹화하거나 검색할 수 없습니다. 예를 들어, 블로그 게시물에 여러 태그를 달아도 그 태그를 클릭하여 관련 게시물을 찾을 수 없습니다. 태그 클라우드와 카테고리 클라우드 표시 안 됨\r사이트에 태그 클라우드나 카테고리 클라우드를 표시하는 부분이 없다면, 사용자가 태그나 카테고리를 통해 콘텐츠를 탐색할 수 없습니다. 페이지 헤더에 태그나 카테고리 표시 안 됨\r콘텐츠 페이지의 헤더에 태그나 카테고리가 표시되지 않습니다. 이는 각 콘텐츠가 어떤 주제나 카테고리에 속하는지 사용자에게 명확히 보여주지 않습니다. SEO 및 UX 영향\r검색 엔진 최적화(SEO) 측면에서 태그와 카테고리는 중요한 역할을 합니다. 검색 엔진은 태그와 카테고리를 통해 콘텐츠의 주제와 관련성을 더 잘 이해할 수 있습니다. 사용자 경험(UX) 측면에서도 사용자가 특정 주제에 대한 콘텐츠를 쉽게 찾을 수 있게 하므로 중요한 요소입니다. "},"title":"Taxonomies"},"/docflow/staticsite/guide/hugo/doks-theme/%EB%8B%A4%EA%B5%AD%EC%96%B4-%EC%A7%80%EC%9B%90/":{"data":{"":"","#":"ko, en, ja 를 지원하고, ko를 기본으로 사용할 경우 설정은 다음과 같습니다.\n폴더 구조 설정\r프로젝트 폴더 구조는 다음과 같습니다. Obsidian의 blog 폴더를 ko 콘텐츠로 사용하고, en 및 ja 콘텐츠를 별도로 구성합니다.\nobsidian/ ├── blog/ │ ├── note1/ │ │ └── note1.md │ ├── note2/ │ │ └── note2.md │ ├── note3/ │ │ └── note3.md │ └── attachments/ # 이미지 및 기타 첨부 파일 폴더 hugo-project/ ├── content/ │ ├── en/ │ │ └── _index.md # 영어 콘텐츠 │ ├── ja/ │ │ └── _index.md # 일본어 콘텐츠 ├── config.toml └── themes/ └── doks/\rconfig.toml 파일 설정\rHugo의 config.toml 파일을 수정하여 다국어 설정을 추가하고 blog 폴더를 content/ko로 마운트합니다.\nbaseURL = \"https://example.com/\" languageCode = \"en-us\" title = \"My Hugo Site\" # 다국어 설정 [languages] [languages.ko] languageName = \"한국어\" weight = 1 contentDir = \"content/ko\" [languages.en] languageName = \"English\" weight = 2 contentDir = \"content/en\" [languages.ja] languageName = \"日本語\" weight = 3 contentDir = \"content/ja\" # 블로그 폴더 마운트 [module] [[module.mounts]] source = \"../blog\" target = \"content/ko\"\r다국어 네비게이션 설정\rDoks 테마에서 다국어 네비게이션을 설정하려면 config.toml 파일에 메뉴 항목을 추가해야 합니다.\n[menu] [[menu.main]] identifier = \"home\" name = \"Home\" url = \"/\" weight = 1 pre = \"ko: / | en: /en/ | ja: /ja/\" [[menu.main]] identifier = \"obsidian\" name = \"Obsidian\" url = \"/Obsidian/\" weight = 2 pre = \"ko: /about/ | en: /en/about/ | ja: /ja/about/\"\r다국어 스위처 추가\rDoks 테마에 언어 스위처를 추가하려면 layouts/partials/navbar.html 파일을 수정하여 언어 선택 링크를 추가합니다.\n{{ $currentLang := .Lang }} \u003cnav\u003e \u003c!-- 기존 네비게이션 코드 --\u003e \u003cul class=\"language-switcher\"\u003e {{ range .Site.Languages }} \u003cli\u003e \u003ca href=\"{{ .RelPermalink }}\" class=\"{{ if eq .Lang $currentLang }}active{{ end }}\"\u003e{{ .LanguageName }}\u003c/a\u003e \u003c/li\u003e {{ end }} \u003c/ul\u003e \u003c/nav\u003e"},"title":"다국어 지원"},"/docflow/staticsite/guide/hugo/doks-theme/%EB%8C%80%EB%AC%B8-%EB%B3%80%EA%B2%BD/":{"data":{"":"레이아웃은 layouts/index.html 에서 수정 세부 구성 내역에 대한 변경은 /node_modules/@hyas/doks-core/i18n/en.toml 에서 수정 지원하는 언어에 따라 파일 달라짐. 일본어를 지원한다면 ja.toml 수정"},"title":"대문 변경"},"/docflow/staticsite/guide/hugo/doks-theme/%ED%85%8C%EB%A7%88-%EA%B3%84%EC%B8%B5-%EA%B5%AC%EC%A1%B0/":{"data":{"":"","테마-계층-구조-이해#테마 계층 구조 이해":"예를 들어 baseof.html 파일의 경우 doks 프로젝트 안에 두 개가 존재합니다.\nnode_modules@hyas\\doks-core\\layouts_default\\baseof.html` node_modules@hyas\\core\\layouts_default\\baseof.htm ` 이유는 Doks 테마가 하위 테마(또는 상위 테마)를 포함하여 테마 계층 구조를 사용하기 때문입니다. 테마 계층 구조 이해\rDoks 테마 @hyas/doks-core는 Doks 테마의 핵심 부분을 제공합니다. 이 폴더에는 Doks 테마의 기본 레이아웃과 템플릿이 포함되어 있습니다. Hyas Core @hyas/core는 Doks 테마가 기반으로 하는 더 일반적인 템플릿과 레이아웃을 제공할 수 있습니다. Hyas는 Hugo 테마 중 하나로, Doks가 이 테마를 상속받아 확장하는 방식으로 동작할 수 있습니다. 테마 우선 순위\rHugo는 테마 계층 구조에서 파일을 찾을 때 특정한 우선 순위를 따릅니다. 예를 들어, baseof.html 파일을 찾을 때 다음 순서로 파일을 검색합니다:\n사이트의 기본 레이아웃 layouts/_default/baseof.html 활성 테마 (여기서는 @hyas/doks-core): themes/doks-core/layouts/_default/baseof.html 상위 테마 (여기서는 @hyas/core): themes/core/layouts/_default/baseof.html 이 구조 덕분에 사용자는 특정 파일을 덮어써서 커스터마이즈할 수 있습니다. 기본적으로 doks-core의 baseof.html을 사용하지만, core에 있는 파일로 대체할 수 있습니다. 두 파일의 역할\r@hyas/doks-core/layouts/_default/baseof.html Doks 테마의 기본 레이아웃 파일입니다. 이 파일은 Doks 테마의 커스터마이징된 레이아웃과 스타일을 정의합니다. @hyas/core/layouts/_default/baseof.html Hyas Core 테마의 기본 레이아웃 파일입니다. 이 파일은 Doks 테마에서 상속받아 사용하는 더 일반적인 레이아웃과 스타일을 정의할 수 있습니다. 어떤 파일을 수정해야 할까?\r보통 @hyas/doks-core에 있는 baseof.html 파일을 수정합니다. 왜냐하면 이는 Doks 테마의 레이아웃을 정의하고 있으며, 사용자가 직접 커스터마이징하고자 하는 파일이기 때문입니다. 하지만 Hyas Core 테마에 대한 기본 레이아웃 변경이 필요하다면 @hyas/core에 있는 파일을 수정할 수 있습니다."},"title":"테마 계층 구조"},"/docflow/staticsite/guide/hugo/doks-theme/config.toml/":{"data":{"":"","내용#내용":"doks 의 설정 파일은 themes/doks/config/_default/Hugo.toml 입니다. Hugo는 프로젝트 루트의 config.toml 파일을 우선적으로 참조합니다. 만약 프로젝트 루트에 config.toml 파일을 새로 생성하면, Hugo는 이 파일을 주요 설정 파일로 사용합니다. config.toml 파일이 없는 경우에만 테마 디렉토리의 _default 설정 파일을 참조합니다. 따라서 프로젝트 루트에 config.toml 파일을 생성하면, _default에 있는 설정 파일을 참조하지 않고 새로 생성한 config.toml 파일을 사용하게 됩니다. 필요한 모든 설정을 이 파일에 포함시켜야 합니다. 하지만, 필요한 기본 설정을 프로젝트 루트의 config.toml 파일에 포함시키고, 추가 설정을 테마에서 가져오는 방식으로 사용할 수 있습니다. 이 경우, Hugo의 설정 병합 기능을 활용할 수 있습니다.\n내용\r기본 설정\rtitle = \"My Docs\" # 사이트의 제목 baseurl = \"http://localhost/\" # 사이트의 기본 URL canonifyURLs = false # 모든 URL을 절대 URL로 변환 disableAliases = true # Hugo에서 자동 생성된 별칭 비활성화 disableHugoGeneratorInject = true # Hugo generator 메타 태그 비활성화 enableEmoji = true # 이모지 지원 활성화 enableGitInfo = false # Git 정보를 포함 비활성화 enableRobotsTXT = true # robots.txt 파일 생성 활성화 languageCode = \"en-US\" # 사이트의 기본 언어 paginate = 10 # 페이지네이션 설정 rssLimit = 10 # RSS 피드에 포함될 항목 수 summarylength = 20 # 콘텐츠 요약의 길이\r다국어 지원 설정\rdefaultContentLanguage = \"en\" # 기본 콘텐츠 언어 disableLanguages = [\"de\", \"nl\"] # 비활성화할 언어 목록 defaultContentLanguageInSubdir = false # 기본 언어를 하위 디렉토리에 포함할지 여부\r저작권 및 빌드 설정\rcopyRight = \"Copyright (c) 2020-2024 Hyas\" # 저작권 정보 [build.buildStats] enable = true # 빌드 통계 활성화\r출력 형식 설정\r[outputs] home = [\"HTML\", \"RSS\", \"searchIndex\"] # 홈 페이지 출력 형식 section = [\"HTML\", \"RSS\", \"SITEMAP\"] # 섹션 페이지 출력 형식 [outputFormats.searchIndex] mediaType = \"application/json\" baseName = \"search-index\" isPlainText = true notAlternative = true [outputFormats.SITEMAP] mediaType = \"application/xml\" baseName = \"sitemap\" isHTML = false isPlainText = true noUgly = true rel = \"sitemap\"\r사이트맵 설정\r[sitemap] changefreq = \"monthly\" # 사이트맵의 기본 변경 빈도 filename = \"sitemap.xml\" # 사이트맵 파일 이름 priority = 0.5 # 사이트맵의 기본 우선 순위\r캐시설정\r[caches] [caches.getjson] dir = \":cacheDir/:project\" # 캐시 디렉토리 설정 maxAge = -1 # 캐시의 최대 수명\r텍소노미 설정\r[taxonomies] contributor = \"contributors\" # 기여자 분류 category = \"categories\" # 카테고리 분류 tag = \"tags\" # 태그 분류\r영구 링크 설정\r[permalinks] blog = \"/blog/:slug/\" # 블로그 퍼머링크 구조 docs = \"/docs/:sections[1:]/:slug/\" # 문서 퍼머링크 구조\rHTML 압축 설정\r[minify.tdewolff.html] keepWhitespace = false # HTML에서 공백을 유지하지 않음\r관련 콘텐츠 설정\r[related] threshold = 80 # 관련 콘텐츠의 임계값 includeNewer = true # 새로운 관련 콘텐츠 포함 여부 toLower = false # 소문자로 변환 여부 [[related.indices]] name = \"categories\" # 관련 콘텐츠 인덱스 - 카테고리 weight = 100 # 가중치 [[related.indices]] name = \"tags\" # 관련 콘텐츠 인덱스 - 태그 weight = 80 # 가중치 [[related.indices]] name = \"date\" # 관련 콘텐츠 인덱스 - 날짜 weight = 10 # 가중치\r이미지 설정\r[imaging] anchor = \"Center\" # 이미지 앵커 위치 bgColor = \"#ffffff\" # 이미지 배경색 hint = \"photo\" # 이미지 힌트 quality = 85 # 이미지 품질 resampleFilter = \"Lanczos\" # 이미지 리샘플링 필터"},"title":"config.toml"},"/docflow/staticsite/guide/hugo/doks-theme/contributors-error/":{"data":{"":"\rERROR render of \"term\" failed: \"D:\\Obsidian\\DocFlow_Hugo\\node_modules\\@hyas\\doks-core\\layouts\\_default\\term.html:47:15\": execute of template failed: template: _default/term.html:47:15: executing \"main\" at \u003cpartial \"main/blog-meta.html\" .\u003e: error calling partial: \"D:\\Obsidian\\DocFlow_Hugo\\node_modules\\@hyas\\doks-core\\layouts\\partials\\main\\blog-meta.html:1:17\": execute of template failed: template: partials/main/blog-meta.html:1:17: executing \"partials/main/blog-meta.html\" at \u003clen .Params.contributors\u003e: error calling len: reflect: call of reflect.Value.Type on zero Value Total in 1555 ms Error: error building site: render: failed to render pages: render of \"term\" failed: \"D:\\Obsidian\\DocFlow_Hugo\\node_modules\\@hyas\\doks-core\\layouts\\_default\\term.html:47:15\": execute of template failed: template: _default/term.html:47:15: executing \"main\" at \u003cpartial \"main/blog-meta.html\" .\u003e: error calling partial: \"D:\\Obsidian\\DocFlow_Hugo\\node_modules\\@hyas\\doks-core\\layouts\\partials\\main\\blog-meta.html:1:17\": execute of template failed: template: partials/main/blog-meta.html:1:17: executing \"partials/main/blog-meta.html\" at \u003clen .Params.contributors\u003e: error calling len: reflect: call of reflect.Value.Type on zero Value\r이 오류는 Hugo가 contributors 필드의 값을 처리할 때 발생합니다.\ncontributors 필드가 빈 값이거나 정의되지 않은 경우 발생하는 문제입니다. 메타데이터 템플릿을 수정하여 contributors 필드를 빈 배열로 초기화하여 해결할 수 있습니다. 템플릿에서 contributors 필드를 처리할 때, 이 필드가 비어 있거나 존재하지 않는 경우를 안전하게 처리하도록 변경합니다. /node_modules/@hyas/doks-core/layouts/partials/main/blog-meta.html 파일을 다음과 같이 수정합니다. {{ if isset .Params \"contributors\" }} {{ $contributors := .Params.contributors }} {{ if $contributors }} {{ $len := len $contributors }} {{ $last := sub $len 1 -}} \u003cp\u003e \u003csmall\u003e {{- time.Format (default \":date_long\" .Site.Params.dateFormat) .PublishDate -}} {{- with .Params.categories -}} \u0026nbsp;in\u0026nbsp; {{- range $index, $category := . -}} {{ if gt $index 0 }}, {{ end -}} \u003ca class=\"stretched-link position-relative link-muted\" href=\"{{ \"/categories/\" | relLangURL }}{{ . | urlize }}/\"\u003e{{ . }}\u003c/a\u003e {{- end }} {{- end }} {{- if gt $len 0 }} \u0026nbsp;by\u0026nbsp; {{- range $index, $contributor := $contributors -}} {{- if gt $index 0 }}{{ if eq $index $last }} and {{ else }}, {{ end }}{{ end -}} {{- with $.Site.GetPage \"taxonomyTerm\" (printf \"contributors/%s\" (urlize .)) -}} {{ if $.Params.avatar -}} {{ $image := .Resources.GetMatch (printf \"**%s\" .Params.avatar) -}} {{ $imageLq := $image.Resize \"15x15 webp q95\" -}} {{ $image = $image.Resize \"60x60 webp q95\" -}} \u003cimg class=\"rounded-circle w-auto mx-1 lazyload blur-up\" src=\"{{ $imageLq.RelPermalink }}\" data-src=\"{{ $image.RelPermalink }}\" alt=\"{{ .Title }}\" width=\"30\" height=\"30\"\u003e {{- end }} {{- end -}} \u003ca class=\"stretched-link position-relative\" href=\"{{ \"/contributors/\" | relLangURL }}{{ . | urlize }}/\"\u003e{{ . }}\u003c/a\u003e {{- end }} {{- end }} {{- /* NOTE: classes 'stretched-link position-relative' are necessary to properly display the title attribute on hover */ -}} \u003cspan class=\"stretched-link position-relative reading-time text-nowrap\" title=\"{{ i18n \"reading_time\" }}\"\u003e{{/* trim subsequent whitespace */ -}} \u003csvg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon icon-tabler icon-tabler-clock\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\"\u003e \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"\u003e\u003c/path\u003e \u003cpath d=\"M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0\"\u003e\u003c/path\u003e \u003cpath d=\"M12 7v5l3 3\"\u003e\u003c/path\u003e \u003c/svg\u003e {{- .ReadingTime }}\u0026nbsp;{{ i18n \"minute\" .ReadingTime -}} \u003c/span\u003e{{/* trim subsequent whitespace */ -}} \u003c/small\u003e \u003c/p\u003e {{ else }} \u003cp\u003e \u003csmall\u003e {{- time.Format (default \":date_long\" .Site.Params.dateFormat) .PublishDate -}} {{- with .Params.categories -}} \u0026nbsp;in\u0026nbsp; {{- range $index, $category := . -}} {{ if gt $index 0 }}, {{ end -}} \u003ca class=\"stretched-link position-relative link-muted\" href=\"{{ \"/categories/\" | relLangURL }}{{ . | urlize }}/\"\u003e{{ . }}\u003c/a\u003e {{- end }} {{- end }} {{- /* NOTE: classes 'stretched-link position-relative' are necessary to properly display the title attribute on hover */ -}} \u003cspan class=\"stretched-link position-relative reading-time text-nowrap\" title=\"{{ i18n \"reading_time\" }}\"\u003e{{/* trim subsequent whitespace */ -}} \u003csvg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon icon-tabler icon-tabler-clock\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\"\u003e \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"\u003e\u003c/path\u003e \u003cpath d=\"M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0\"\u003e\u003c/path\u003e \u003cpath d=\"M12 7v5l3 3\"\u003e\u003c/path\u003e \u003c/svg\u003e {{- .ReadingTime }}\u0026nbsp;{{ i18n \"minute\" .ReadingTime -}} \u003c/span\u003e{{/* trim subsequent whitespace */ -}} \u003c/small\u003e \u003c/p\u003e {{ end }} {{ else }} \u003cp\u003e \u003csmall\u003e {{- time.Format (default \":date_long\" .Site.Params.dateFormat) .PublishDate -}} {{- with .Params.categories -}} \u0026nbsp;in\u0026nbsp; {{- range $index, $category := . -}} {{ if gt $index 0 }}, {{ end -}} \u003ca class=\"stretched-link position-relative link-muted\" href=\"{{ \"/categories/\" | relLangURL }}{{ . | urlize }}/\"\u003e{{ . }}\u003c/a\u003e {{- end }} {{- end }} {{- /* NOTE: classes 'stretched-link position-relative' are necessary to properly display the title attribute on hover */ -}} \u003cspan class=\"stretched-link position-relative reading-time text-nowrap\" title=\"{{ i18n \"reading_time\" }}\"\u003e{{/* trim subsequent whitespace */ -}} \u003csvg xmlns=\"http://www.w3.org/2000/svg\" class=\"icon icon-tabler icon-tabler-clock\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" stroke-width=\"2\" stroke=\"currentColor\" fill=\"none\" stroke-linecap=\"round\" stroke-linejoin=\"round\"\u003e \u003cpath stroke=\"none\" d=\"M0 0h24v24H0z\" fill=\"none\"\u003e\u003c/path\u003e \u003cpath d=\"M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0\"\u003e\u003c/path\u003e \u003cpath d=\"M12 7v5l3 3\"\u003e\u003c/path\u003e \u003c/svg\u003e {{- .ReadingTime }}\u0026nbsp;{{ i18n \"minute\" .ReadingTime -}} \u003c/span\u003e{{/* trim subsequent whitespace */ -}} \u003c/small\u003e \u003c/p\u003e {{ end }}"},"title":"Contributors Error"},"/docflow/staticsite/guide/hugo/doks-theme/mediatype-parsing-%EC%97%90%EB%9F%AC/":{"data":{"":"","발생-원인#발생 원인":"","에러-내용#에러 내용":"","해결-방안#해결 방안":"에러 내용\rBuilt in 527 ms Error: error building site: render: failed to render pages: render of \"page\" failed: \"D:\\Obsidian\\DocFlow_Hugo\\node_modules\\@hyas\\doks-core\\layouts\\_default\\single.html:39:36\": execute of template failed: template: _default/single.html:39:36: executing \"main\" at \u003c.Content\u003e: error calling Content: \"D:\\Obsidian\\DocFlow\\About\\About.md:1:1\": \"D:\\Obsidian\\DocFlow_Hugo\\node_modules\\@hyas\\images\\layouts\\_default\\_markup\\render-image.html:155:12\": execute of template failed: template: _default/_markup/render-image.html:155:12: executing \"_default/_markup/render-image.html\" at \u003c$r.MediaType.SubType\u003e: can't evaluate field MediaType in type string\r발생 원인\r템플릿 렌더링 중 MediaType 필드를 평가할 수 없다는 내용이 있습니다. 이는 resources.Get 함수가 리소스를 찾지 못했거나, 찾은 리소스의 형식이 예상한 대로 MediaType 필드를 가지지 않는 경우 발생할 수 있습니다.\n해결 방안\rHUGO 버전 확인\rrender-image.html 파일에서는 Hugo 버전이 최소 0.114.0 이상이어야 한다고 명시되어 있습니다. 사용 중인 Hugo 버전이 해당 버전 이상인지 확인합니다.\nhugo version hugo v0.127.0-74e0f3bd63c51f3c7a0f07a7c779eec9e922957e+extended windows/amd64 BuildDate=2024-06-05T10:27:59Z VendorInfo=gohugoio\r템플릿 디버깅\rrender-image.html 파일에서 $r 변수가 예상대로 설정되고 있는지 확인합니다. $r 변수가 제대로 설정되지 않으면 MediaType 필드를 접근할 수 없습니다\nnode_modules/@hyas/images/layouts/_default/_markup/render-image.html {{ $renderHookName := \"image\" }} {{ $minHugoVersion := \"0.114.0\" }} {{ if lt hugo.Version $minHugoVersion }} {{ errorf \"The %q render hook requires Hugo v%s or later.\" $renderHookName $minHugoVersion }} {{ end }} {{ $errorLevel := or site.Params.render_hooks.image.errorLevel \"ignore\" | lower }} {{ if not (in (slice \"ignore\" \"warning\" \"error\") $errorLevel) }} {{ errorf \"The %q render hook is misconfigured. The errorLevel %q is invalid. Please check your site configuration.\" $renderHookName $errorLevel }} {{ end }} {{ $contentPath := \"\" }} {{ with .Page.File }} {{ $contentPath = .Path }} {{ else }} {{ $contentPath = .Path }} {{ end }} {{ $u := urls.Parse .Destination }} {{ $msg := printf \"The %q render hook was unable to resolve the destination %q in %s\" $renderHookName $u.String $contentPath }} {{ $r := \"\" }} {{ if $u.IsAbs }} {{ with resources.GetRemote $u.String }} {{ with .Err }} {{ if eq $errorLevel \"warning\" }} {{ warnf \"%s. See %s\" . $contentPath }} {{ else if eq $errorLevel \"error\" }} {{ errorf \"%s. See %s\" . $contentPath }} {{ end }} {{ else }} {{ $r = . }} {{ end }} {{ else }} {{ if eq $errorLevel \"warning\" }} {{ warnf $msg }} {{ else if eq $errorLevel \"error\" }} {{ errorf $msg }} {{ end }} {{ end }} {{ else }} {{ with .Page.Resources.Get (strings.TrimPrefix \"./\" $u.Path) }} {{ $r = . }} {{ else }} {{ with (and (ne .Page.BundleType \"leaf\") (.Page.CurrentSection.Resources.Get (strings.TrimPrefix \"./\" $u.Path))) }} {{ $r = . }} {{ else }} {{ with resources.Get $u.Path }} {{ $r = . }} {{ else }} {{ if eq $errorLevel \"warning\" }} {{ warnf $msg }} {{ else if eq $errorLevel \"error\" }} {{ errorf $msg }} {{ end }} {{ end }} {{ end }} {{ end }} {{ end }} {{ if and (not (eq $r \"\")) (in (slice \"image/png\" \"image/jpeg\" \"image/webp\") $r.MediaType.Type) }} {{ $id := printf \"h-rh-i-%d\" .Ordinal }} {{ with .Attributes.id }} {{ $id = . }} {{ end }} {{ if and (not (eq $r.MediaType.SubType \"\")) (ne $r.MediaType.SubType \"gif\") }} {{ $r = $r.Resize (printf \"%dx%d webp\" $r.Width $r.Height) }} {{ end }} \u003cimg src=\"{{ $r.RelPermalink }}\" width=\"{{ string $r.Width }}\" height=\"{{ string $r.Height }}\" decoding=\"{{ site.Params.hyas_images.defaults.decoding }}\" fetchpriority=\"{{ site.Params.hyas_images.defaults.fetchpriority }}\" loading=\"{{ site.Params.hyas_images.defaults.loading }}\" alt=\"{{ .PlainText }}\" {{ with .Title }}title=\"{{ . }}\"{{ end }} id=\"{{ $id }}\" /\u003e {{ else }} \u003cimg src=\"{{ .Destination }}\" alt=\"{{ .PlainText }}\" {{ with .Title }}title=\"{{ . }}\"{{ end }} /\u003e {{ end }}\r리소스 형식 확인\rMediaType이 설정된 리소스만을 다루도록 확인합니다. 현재 템플릿은 image/png, image/jpeg, image/webp 형식만을 허용하고 있습니다."},"title":"MediaType Parsing 에러"},"/docflow/staticsite/guide/hugo/front-matter/":{"data":{"":"","메타데이터#메타데이터":"메타데이터\r메타데이터를 각 문서의 시작 부분에 추가하면, Hugo는 이를 기반으로 문서를 렌더링하고 SEO 최적화 작업을 수행합니다. 필수 필드는 아니지만, 각 필드를 적절하게 채워 넣으면 사이트의 품질과 검색 엔진 최적화에 도움이 됩니다.\n다음은 doks theme 용 Front Matter 입니다. 테마에 따라 내용이 달라질 수 있습니다. ","주요-필드#주요 필드":" title: 섹션의 제목을 정의합니다. 이는 섹션의 인덱스 페이지에 표시됩니다. description: 섹션에 대한 설명입니다. 주로 검색 엔진이나 미리보기에서 사용됩니다. summary: 섹션의 요약입니다. 페이지나 게시물의 요약으로 표시되며, 검색 결과나 목록에서 사용될 수 있습니다. date: 섹션의 생성 날짜와 시간입니다. lastmod: 섹션의 마지막 수정 날짜와 시간입니다. draft: 섹션이 초안 상태인지 여부를 나타냅니다. true로 설정하면 섹션이 사이트 빌드 시 포함되지 않습니다. weight: 섹션의 정렬 순서를 제어합니다. 낮은 숫자가 더 높은 우선 순위를 가집니다. toc: 섹션의 목차(Table of Contents) 표시 여부를 제어합니다. seo: SEO 최적화를 위한 설정을 포함합니다. title: SEO를 위한 맞춤 제목입니다. description: SEO를 위한 맞춤 설명입니다. canonical: SEO를 위한 맞춤 캐노니컬 URL입니다. noindex: 검색 엔진에서 인덱싱하지 않도록 설정합니다. "},"title":"Front Matter"},"/docflow/staticsite/guide/hugo/hugo-%EC%84%A4%EC%B9%98/":{"data":{"":"","hugo-사이트-빌드#Hugo 사이트 빌드":"Node.js 설치\rHugo 설치 파일 다운로드\rHugo 공식 웹사이트(https://gohugo.io/)의 다운로드 페이지에서 운영 체제에 맞는 설치 파일을 다운로드합니다. 설치 파일 압축 해제\r다운로드한 파일의 압축을 해제합니다. 압축을 해제하면 hugo.exe 파일이 생성됩니다. Hugo 실행 파일 이동\rhugo.exe 파일을 `D:/Obsidian/ref’ 등의 디렉토리에 복사합니다. 디렉토리 경로는 제한이 없으며, 없다면 새로 만듭니다. 환경변수 설정\r“내 PC” -\u003e “속성” -\u003e “고급 시스템 설정” -\u003e “환경 변수\"로 이동합니다. 시스템 변수에서 “Path\"를 선택하고 “편집\"을 클릭합니다. “새로 만들기\"를 클릭하고 hugo.exe 파일을 복사한 디렉토리를 추가합니다. 설치 확인\r명령 프롬프트를 열고 다음 명령어를 입력하여 설치가 제대로 되었는지 확인합니다: \u003e hugo version\r설치된 Hugo 버전이 표시되면 설치가 완료된 것입니다. D:\\Obsidian\u003ehugo version hugo v0.127.0-74e0f3bd63c51f3c7a0f07a7c779eec9e922957e+extended windows/amd64 BuildDate=2024-06-05T10:27:59Z VendorInfo=gohugoio D:\\Obsidian\u003e\rHugo 사이트 생성\r일반적인 Hugo project 진행 방식입니다만, 이 프로젝트는 Doks 테마를 이용해 진행 할 예정이므로, 이후 내용은 참고만 하시고 Doks 테마 설치 부터 이어서 진행하시기 바랍니다.\n터미널에서 다음 명령어를 실행하여 새로운 Hugo 사이트를 생성합니다 mkdir blog_hugo cd blog_hugo hugo new site .\rD:\\Obsidian\u003emkdir DocFlow_Hugo D:\\Obsidian\u003ecd DocFlow_Hugo D:\\Obsidian\\DocFlow_Hugo\u003ehugo new site . Congratulations! Your new Hugo site was created in D:\\Obsidian\\DocFlow_Hugo. Just a few more steps... 1. Change the current directory to D:\\Obsidian\\DocFlow_Hugo. 2. Create or install a theme: - Create a new theme with the command \"hugo new theme \u003cTHEMENAME\u003e\" - Or, install a theme from https://themes.gohugo.io/ 3. Edit hugo.toml, setting the \"theme\" property to the theme name. 4. Create new content with the command \"hugo new content \u003cSECTIONNAME\u003e\\\u003cFILENAME\u003e.\u003cFORMAT\u003e\". 5. Start the embedded web server with the command \"hugo server --buildDrafts\". See documentation at https://gohugo.io/. D:\\Obsidian\\DocFlow_Hugo\u003e\r이후 폴더 구조는 다음과 같습니다.\nD:. ├─archetypes ├─assets ├─content ├─data ├─i18n ├─layouts ├─static └─themes\rHugo 사이트 빌드\rHugo 로컬 서버 실행\rHugo 로컬 개발 서버를 실행하여 사이트를 미리보기합니다 hugo server\rD:\\Obsidian\\DocFlow_Hugo\u003e hugo server Watching for changes in D:\\Obsidian\\DocFlow_Hugo\\{archetypes,assets,content,data,i18n,layouts,static} Watching for config changes in D:\\Obsidian\\DocFlow_Hugo\\hugo.toml Start building sites … hugo v0.127.0-74e0f3bd63c51f3c7a0f07a7c779eec9e922957e+extended windows/amd64 BuildDate=2024-06-05T10:27:59Z VendorInfo=gohugoio WARN found no layout file for \"html\" for kind \"taxonomy\": You should create a template file which matches Hugo Layouts Lookup Rules for this combination. WARN found no layout file for \"html\" for kind \"home\": You should create a template file which matches Hugo Layouts Lookup Rules for this combination. | EN -------------------+----- Pages | 4 Paginator pages | 0 Non-page files | 0 Static files | 0 Processed images | 0 Aliases | 0 Cleaned | 0 Built in 3 ms Environment: \"development\" Serving pages from disk Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop\rHugo 로컬 서버 보기\r브라우저에서 http://localhost:1313으로 접속하여 사이트를 확인합니다. ","hugo-설치-파일-다운로드#Hugo 설치 파일 다운로드":"","nodejs-설치nodejs20설치md#\u003ca href=\"Node.js%20%EC%84%A4%EC%B9%98.md\"\u003eNode.js 설치\u003c/a\u003e":"","환경변수-설정staticsiteguidecommon환경변수20설정#\u003ca href=\"StaticSite/Guide/Common/%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98%20%EC%84%A4%EC%A0%95\"\u003e환경변수 설정\u003c/a\u003e":""},"title":"HUGO 설치"},"/docflow/staticsite/guide/hugo/hugo_state.json/":{"data":{"":"","#":"hugo_stats.json 파일은 일반적으로 Hugo 사이트의 자산 관리를 최적화하는 데 사용됩니다. 이 파일의 주요 역할과 관리 방법에 대해 설명하겠습니다.\nhugo_stats.json 파일의 역할\r자산 최적화: hugo_stats.json 파일은 Hugo가 빌드 시 생성하는 파일로, 자산(예: CSS, JS 파일) 최적화 정보가 포함되어 있습니다. 이 파일은 Hugo의 Hugo Pipes 기능을 통해 생성되며, 자산의 해시, 크기, 경로 등의 정보를 포함합니다. 빌드 성능 향상: 이 파일을 사용하면 Hugo는 자산을 다시 컴파일할 필요 없이 기존 자산을 재사용할 수 있어 빌드 시간을 단축할 수 있습니다. 깃으로 추적해야 하나?\r추적하지 않음: 일반적으로 hugo_stats.json 파일은 빌드 아티팩트로 간주되므로 Git에서 추적하지 않는 것이 좋습니다. 이 파일은 빌드 시마다 변경되므로, Git에서 추적하면 불필요한 커밋이 많이 발생할 수 있습니다. .gitignore에 추가: hugo_stats.json 파일을 Git의 추적에서 제외하려면 프로젝트의 .gitignore 파일에 다음 줄을 추가합니다. hugo_stats.json"},"title":"hugo_state.json"},"/docflow/staticsite/guide/hugo/menu/":{"data":{"":"","메뉴-관리#메뉴 관리":"섹션 추가\rconfig/_default/menus/menus.en.toml 파일에서 섹션을 관리할 수 있습니다. 섹션 추가 시 url 은 폴더 경로와 일치해야 합니다. [[main]] name = \"DocFlow\" url = \"/DocFlow/about/about\" weight = 10 [[main]] name = \"Docs\" url = \"/docs/\" weight = 20 [[main]] name = \"Blog\" url = \"/blog/\" weight = 30\r메뉴 관리\rDoks 테마에서는 각 섹션별로 다른 레이아웃을 적용하고 있습니다. 예를 들어, docs 섹션에서는 사이드바가 활성화되지만, Blog 테마에서는 활성화되지 않습니다. 마찬가지로 추가 된 DocFlow 섹션에서도 사이드바는 보이지 않습니다. 섹션이 여러개인 경우 레이아웃을 달리 적용하는 방법에 대해서는 조금 복잡할 수 있으므로 여기에서는 다루지 않으며, Docs 섹션을 이용하여 메뉴를 구성하였습니다. 변경된 구성은 다음과 같습니다.\n[[main]] name = \"DocFlow\" url = \"/docs/about/about\" weight = 10 [[main]] name = \"Blog\" url = \"/blog/\" weight = 30","섹션-추가#섹션 추가":""},"title":"Menu"},"/docflow/staticsite/guide/hugo/mount/":{"data":{"":"","마운트-기능-소개#마운트 기능 소개":"","사용-예시#사용 예시":"마운트 기능 소개\rHugo의 마운트 기능은 프로젝트의 파일 및 디렉토리 구조를 유연하게 관리할 수 있게 해주는 기능입니다. 이 기능을 통해 외부 디렉토리나 파일을 Hugo 프로젝트의 특정 위치에 연결할 수 있습니다. 마운트 기능을 사용하면 코드 재사용이 쉬워지고, 프로젝트 구조를 보다 모듈화하여 유지보수가 용이해집니다.\nHugo 마운트 기능 개요\rHugo의 마운트 기능은 config.toml 파일에서 설정할 수 있으며, module.mounts 섹션을 사용하여 디렉토리 또는 파일을 원하는 위치에 마운트할 수 있습니다. 이를 통해 외부 콘텐츠나 테마 요소를 프로젝트의 특정 경로에 연결하여 사용할 수 있습니다. 옵시디언으로 글을 작성하고 관리하는 경우, 옵시디언의 볼트를 content 폴더에 마운트 시킴으로서 별도의 처리 과정 없이 소스로 사용할 수 있습니다.\n사용법\r기본 설정\rHugo 프로젝트의 config.toml 파일을 열고, mounts 섹션을 추가합니다. 예를 들어, 다음과 같이 외부 콘텐츠 디렉토리를 마운트할 수 있습니다:\n[module] [[module.mounts]] source = \"../DockFlow\" target = \"content/docs\"\r여기서 source는 외부 디렉토리의 경로이고, target은 Hugo 프로젝트 내에서 연결할 가상 경로입니다. 프로젝트 폴더 구조는 다음과 같습니다:\nobsidian/ ├── DocFlow/ │ ├── note1/ │ │ └── note1.md │ ├── note2/ │ │ └── note2.md │ ├── note3/ │ │ └── note3.md │ └── attachments/ └── DocFlow_Hugo/ ├── config.toml ├── content/ ├── themes/ │ └── doks/ └── ...\r이 예시에서는 DockFlow 폴더 정체를 DocFlow_Hugo/content/docs 폴더로 연결합니다.\n여러 마운트 설정\r여러 디렉토리를 마운트할 수 있습니다. 예를 들어, 테마의 일부를 프로젝트에 포함시키고 싶은 경우 다음과 같이 설정할 수 있습니다:\n[module] [[module.mounts]] source = \"my-theme/assets\" target = \"assets\" [[module.mounts]] source = \"my-theme/static\" target = \"static\" [[module.mounts]] source = \"my-theme/layouts\" target = \"layouts\"\r이 설정은 my-theme 디렉토리의 assets, static, layouts 디렉토리를 각각 Hugo 프로젝트의 해당 디렉토리에 마운트합니다.\n외부 Git 리포지토리 마운트\rHugo 모듈을 사용하여 외부 Git 리포지토리를 마운트할 수도 있습니다. 예를 들어, 다음과 같이 설정합니다:\n[[module.imports]] path = \"github.com/username/repository\" mounts = [ { source = \"content\", target = \"content/external\" } ]\r이 설정은 GitHub의 repository 리포지토리에서 content 디렉토리를 가져와 Hugo 프로젝트의 content/external 디렉토리에 마운트합니다.\n사용 예시\rDoks 테마에서는 Module 섹션을 별도의 파일로 분리하여 관리합니다. config/_default/module.toml 파일을 수정하여 마운트를 추가할 수 있습니다. [[mounts]] source = \"../DocFlow\" target = \"content/docs\"\rHugo 서버를 실행해 보면, Pages 등이 마운트한 폴더의 파일 수만큼 증가한 것을 볼 수 있습니다. D:\\Obsidian\\DocFlow_Hugo\u003ehugo server Watching for changes in D:\\Obsidian\\{DocFlow,DocFlow_Hugo} Watching for config changes in D:\\Obsidian\\DocFlow_Hugo\\config\\_default, D:\\Obsidian\\DocFlow_Hugo\\config\\_default\\menus Start building sites … hugo v0.127.0-74e0f3bd63c51f3c7a0f07a7c779eec9e922957e+extended windows/amd64 BuildDate=2024-06-05T10:27:59Z VendorInfo=gohugoio | EN -------------------+------ Pages | 338 Paginator pages | 25 Non-page files | 47 Static files | 13 Processed images | 4 Aliases | 64 Cleaned | 0 Built in 564 ms Environment: \"development\" Serving pages from disk Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop","사용법#사용법":""},"title":"Mount"},"/docflow/staticsite/guide/hugo/script/%EB%A7%81%ED%81%AC-%EC%9C%A0%ED%9A%A8%EC%84%B1-%EA%B2%80%EC%82%AC/":{"data":{"":"","스크립트#스크립트":"스크립트\rimport os import re import urllib.parse # 파일이 존재하는지 확인하는 함수 def file_exists(base_path, file_path): file_path = urllib.parse.unquote(file_path) # URL 디코딩 file_path = file_path.replace('/', os.sep).replace('\\\\', os.sep) return os.path.exists(os.path.join(base_path, file_path)) # 마크다운 파일에서 링크를 추출하는 함수 def extract_links(content): # 코드 블럭 패턴 code_block_pattern = re.compile(r'(```[\\s\\S]+?```|`[^`]+`)') # 코드 블럭 안의 내용을 제거 content_without_code_blocks = code_block_pattern.sub('', content) # 이미지 링크, 옵시디언 링크, 일반 링크 추출 md_pattern = re.compile(r'!\\[([^\\]]*)\\]\\(([^)]+)\\)') # 이미지 링크 패턴 obsidian_pattern = re.compile(r'!\\[\\[([^\\]]+)\\]\\]') # 옵시디언 링크 패턴 link_pattern = re.compile(r'\\[([^\\]]+)\\]\\(([^)]+)\\)') # 일반 링크 패턴 links = md_pattern.findall(content_without_code_blocks) links += obsidian_pattern.findall(content_without_code_blocks) links += link_pattern.findall(content_without_code_blocks) return [link[1] if isinstance(link, tuple) else link for link in links] # 마크다운 파일을 처리하는 함수 def process_markdown_files(base_path, md_directory, image_directory): broken_links = { \"Anchor\": [], \"Image\": [], \"Internal\": [], } for md_root, _, md_files in os.walk(md_directory): for md_file in md_files: if md_file.endswith(\".md\"): md_file_path = os.path.join(md_root, md_file) with open(md_file_path, 'r', encoding='utf-8') as f: content = f.read() links = extract_links(content) for link in links: actual_path = os.path.join(base_path, urllib.parse.unquote(link.replace('/', os.sep))) if link.startswith('#'): # 앵커 링크는 현재 파일 내에 해당 앵커가 존재하는지 확인 anchor = link[1:] if not re.search(r'^#+\\s+' + re.escape(anchor), content, re.MULTILINE): broken_links[\"Anchor\"].append((md_file_path, link, actual_path)) elif link.endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp')): # 이미지 링크 image_path = os.path.join(image_directory, urllib.parse.unquote(link.replace('/', os.sep))) if not os.path.exists(image_path): broken_links[\"Image\"].append((md_file_path, link, image_path)) elif not re.match(r'http[s]?://', link): # 내부 링크 if not file_exists(base_path, link): broken_links[\"Internal\"].append((md_file_path, link, actual_path)) return broken_links # 디렉토리 경로 설정 base_path = r'D:\\Obsidian\\DocFlow' md_directory_path = r'D:\\Obsidian\\DocFlow' image_directory_path = os.path.join(base_path, 'Resources') # 마크다운 파일 처리 및 깨진 링크 찾기 broken_links = process_markdown_files(base_path, md_directory_path, image_directory_path) # 깨진 링크 출력 print(\"\\nBroken links:\") for link_type, links in broken_links.items(): if links: print(f\"\\n{link_type} Links:\") for md_file, link, actual_path in links: print(f\"File: {md_file}, Link: {link}, Path: {actual_path}\")\r스크립트 설명\r마크다운 파일 내의 앵커, 이미지, 내부 링크를 검사하여 깨진 링크를 식별하고 출력합니다. "},"title":"링크 유효성 검사"},"/docflow/staticsite/guide/hugo/script/%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%B0%B8%EC%A1%B0-%EB%B3%80%EA%B2%BD/":{"data":{"":"","스크립트#스크립트":"","스크립트-설명#스크립트 설명":"스크립트\rimport os import re import urllib.parse def change_image_names_and_update_links(directory, md_directory): space_pattern = re.compile(r'\\s') md_pattern = re.compile(r'!\\[([^\\]]*)\\]\\(([^)]+)\\)') obsidian_pattern = re.compile(r'!\\[\\[([^\\]]+)\\]\\]') code_block_pattern = re.compile(r'(```[\\s\\S]+?```|`[^`]+`)') file_mapping = {} # old_file_name -\u003e new_file_name # 파일 이름 변경 for root, _, files in os.walk(directory): for file in files: old_file_path = os.path.join(root, file) new_file_name = file if space_pattern.search(new_file_name): new_file_name = space_pattern.sub('_', new_file_name) new_file_path = os.path.join(root, new_file_name) # 파일 이름 변경 if old_file_path != new_file_path: os.rename(old_file_path, new_file_path) print(f\"Renamed: {old_file_path} -\u003e {new_file_path}\") # 파일 이름 매핑 저장 file_mapping[file] = new_file_name # 마크다운 파일 링크 업데이트 for md_root, _, md_files in os.walk(md_directory): for md_file in md_files: if md_file.endswith(\".md\"): md_file_path = os.path.join(md_root, md_file) with open(md_file_path, 'r', encoding='utf-8') as f: content = f.read() original_content = content # 코드 블럭과 코드 블럭 외부를 분리하여 처리 parts = code_block_pattern.split(content) updated_parts = [] for i, part in enumerate(parts): if i % 2 == 0: # 코드 블럭 외부의 텍스트 처리 def replace_md_links(match): alt_text = match.group(1) file_path = match.group(2) file_name = os.path.basename(file_path) if file_name in file_mapping: new_file_name = file_mapping[file_name] return f'![{alt_text}](Resources/{new_file_name})' return match.group(0) def replace_obsidian_links(match): file_name = match.group(1) new_file_name = file_mapping.get(file_name, file_name) return f'![{new_file_name}](Resources/{new_file_name})' part = md_pattern.sub(replace_md_links, part) updated_part = obsidian_pattern.sub(replace_obsidian_links, part) else: # 코드 블럭 내부는 그대로 유지 updated_part = part updated_parts.append(updated_part) updated_content = ''.join(updated_parts) # 파일을 업데이트된 내용으로 덮어쓰기 (변경된 경우에만) if original_content != updated_content: with open(md_file_path, 'w', encoding='utf-8') as f: f.write(updated_content) print(f\"Updated links in: {md_file_path}\") # 디렉토리 경로 설정 image_directory_path = r'D:\\Obsidian\\DocFlow\\Resources' md_directory_path = r'D:\\Obsidian\\DocFlow' print(\"Change ImageName\") # 이미지 파일 이름 변경 및 링크 업데이트 함수 호출 change_image_names_and_update_links(image_directory_path, md_directory_path) print()\r스크립트 설명\r이미지 파일 이름에 공백이 있다면 _로 대체합니다. 옵시디언 이미지 참조 링크를 일반 마크다운 링크 형식으로 변경합니다. ![[image.png]] 형식이 ![image](image.png) 형식으로 변경됩니다. 코드 블럭 안에 있는 링크는 변경하지 않습니다. "},"title":"이미지 참조 변경"},"/docflow/staticsite/guide/hugo/script/%EC%BD%94%EB%93%9C-%EC%A0%95%EB%A6%AC/":{"data":{"":"","스크립트#스크립트":"","스크립트-설명#스크립트 설명":"스크립트\rcleanup_code.py import os import re # 코드 블럭 주위에 빈 줄을 삽입하는 함수. def insert_blank_lines_around_code_blocks(content): lines = content.split('\\n') updated_lines = [] inside_code_block = False for i, line in enumerate(lines): if line.startswith(\"```\"): if not inside_code_block: if updated_lines and updated_lines[-1].strip() != '': updated_lines.append('') inside_code_block = True else: inside_code_block = False updated_lines.append(line) if i + 1 \u003c len(lines) and lines[i + 1].strip() != '': updated_lines.append('') continue updated_lines.append(line) return '\\n'.join(updated_lines) # 이미지 참조 라인 위아래로 빈 줄을 삽입하는 함수. def insert_blank_lines_around_images(content): md_pattern = re.compile(r'!\\[([^\\]]*)\\]\\(([^)]+)\\)') obsidian_pattern = re.compile(r'!\\[\\[([^\\]]+)\\]\\]') code_block_pattern = re.compile(r'(```[\\s\\S]+?```|`[^`]+`)') # 코드 블럭과 코드 블럭 외부를 분리하여 처리 parts = code_block_pattern.split(content) updated_parts = [] for i, part in enumerate(parts): if i % 2 == 0: lines = part.split('\\n') updated_lines = [] for j, line in enumerate(lines): if md_pattern.match(line) or obsidian_pattern.match(line): if j \u003e 0 and updated_lines[-1].strip() != '': updated_lines.append('') updated_lines.append(line) if j + 1 \u003c len(lines) and lines[j + 1].strip() != '': updated_lines.append('') else: updated_lines.append(line) updated_parts.append('\\n'.join(updated_lines)) else: updated_parts.append(part) return ''.join(updated_parts) # 2단계 헤딩 (##) 라인 위아래로 빈 줄을 삽입하는 함수. def insert_blank_lines_around_headings(content): heading_pattern = re.compile(r'^##\\s.*$', re.MULTILINE) code_block_pattern = re.compile(r'(```[\\s\\S]+?```|`[^`]+`)') # 코드 블럭과 코드 블럭 외부를 분리하여 처리 parts = code_block_pattern.split(content) updated_parts = [] for i, part in enumerate(parts): if i % 2 == 0: lines = part.split('\\n') updated_lines = [] for j, line in enumerate(lines): if heading_pattern.match(line): if j \u003e 0 and updated_lines[-1].strip() != '': updated_lines.append('') updated_lines.append(line) if j + 1 \u003c len(lines) and lines[j + 1].strip() != '': updated_lines.append('') else: updated_lines.append(line) updated_parts.append('\\n'.join(updated_lines)) else: updated_parts.append(part) return ''.join(updated_parts) # 이미지 참조 라인과 2단계 헤딩, 코드 블럭 주위에 빈 줄을 삽입하는 함수 def process_markdown_files(md_directory): for md_root, _, md_files in os.walk(md_directory): for md_file in md_files: if md_file.endswith(\".md\"): md_file_path = os.path.join(md_root, md_file) with open(md_file_path, 'r', encoding='utf-8') as f: content = f.read() original_content = content # 코드 블럭 주위 빈 줄 삽입 updated_content = insert_blank_lines_around_code_blocks(content) # 이미지 참조 라인 주위 빈 줄 삽입 updated_content = insert_blank_lines_around_images(updated_content) # 2단계 헤딩 주위 빈 줄 삽입 updated_content = insert_blank_lines_around_headings(updated_content) # 파일을 업데이트된 내용으로 덮어쓰기 if updated_content != original_content: with open(md_file_path, 'w', encoding='utf-8') as f: f.write(updated_content) print(f\"Updated code in: {md_file_path}\") # 디렉토리 경로 설정 md_directory_path = r'D:\\Obsidian\\DocFlow' # 마크다운 파일 처리 함수 호출 print(f\"Cleanup Code\") process_markdown_files(md_directory_path)\r스크립트 설명\r코드 블럭 주위에 빈 줄을 삽입합니다. 이미지 참조 라인 주위에 빈 줄을 삽입합니다. 코드 블럭 안에 있는 라인은 제외합니다. 2단계 헤딩 (##) 라인 위아래로 빈 줄을 삽입합니다. 코드 블럭 안에 있는 라인은 제외합니다. "},"title":"코드 정리"},"/docflow/staticsite/guide/hugo/script/%ED%8C%8C%EC%9D%BC-%EC%A0%95%EB%A6%AC/":{"data":{"":"","스크립트#스크립트":"","스크립트-설명#스크립트 설명":"스크립트\rcleanup_file.py import os import re import yaml def is_markdown_file(file): return file.endswith('.md') def is_referenced_image(file, md_directory): # 이미지 파일이 마크다운 파일에서 참조되고 있는지 확인하는 함수. file_name = os.path.basename(file) for root, _, md_files in os.walk(md_directory): for md_file in md_files: if is_markdown_file(md_file): md_file_path = os.path.join(root, md_file) with open(md_file_path, 'r', encoding='utf-8') as f: content = f.read() if file_name in content: return True return False def remove_unreferenced_images_and_files(directory, md_directory): # 참조되지 않는 이미지 파일과 기타 파일을 삭제하는 함수. for root, _, files in os.walk(directory): for file in files: file_path = os.path.join(root, file) if not is_markdown_file(file) and not is_referenced_image(file_path, md_directory): os.remove(file_path) print(f\"Deleted unreferenced file: {file_path}\") def remove_empty_markdown_files(directory): # 내용이 없거나 메타데이터만 있는 마크다운 파일을 삭제하는 함수. metadata_pattern = re.compile(r\"---(.*?)---\", re.DOTALL) for root, _, files in os.walk(directory): for file in files: if is_markdown_file(file) and file != \"_index.md\": file_path = os.path.join(root, file) with open(file_path, 'r', encoding='utf-8') as f: content = f.read() metadata_match = metadata_pattern.match(content) if metadata_match: metadata_content = metadata_match.group(1) remaining_content = content[metadata_match.end():].strip() if not remaining_content: os.remove(file_path) print(f\"Deleted empty markdown file: {file_path}\") def remove_bak_files(directory): # .bak 파일을 삭제하는 함수. for root, _, files in os.walk(directory): for file in files: if file.endswith('.bak'): file_path = os.path.join(root, file) os.remove(file_path) print(f\"Deleted .bak file: {file_path}\") def remove_orphan_index_files(directory): # .md 파일이나 서브 폴더가 없는데 _index.md 파일이 있는 경우 해당 _index.md 파일을 제거하는 함수. for root, dirs, files in os.walk(directory): # .md 파일이나 서브 폴더가 없는지 확인 has_md_files_or_subdirs = any(is_markdown_file(f) for f in files if f != \"_index.md\") or bool(dirs) if not has_md_files_or_subdirs: index_file_path = os.path.join(root, \"_index.md\") if os.path.exists(index_file_path): os.remove(index_file_path) print(f\"Deleted orphan _index.md file: {index_file_path}\") # 디렉토리 경로 설정 directory_path = r'D:\\Obsidian\\DocFlow\\Resources' md_directory_path = r'D:\\Obsidian\\DocFlow' print(f\"Cleanup File : unreferenced_images_and_files\") # 참조되지 않는 이미지 파일과 기타 파일 삭제 remove_unreferenced_images_and_files(directory_path, md_directory_path) print(f\"Cleanup File : empty_markdown_files\") # 내용이 없거나 메타데이터만 있는 마크다운 파일 삭제 remove_empty_markdown_files(md_directory_path) # .bak 파일 삭제 print(f\"Cleanup File : .bak files\") remove_bak_files(md_directory_path) # .md 파일이나 서브 폴더가 없는데 _index.md 파일이 있는 경우 제거 print(f\"Cleanup File : orphan_index_files\") remove_orphan_index_files(md_directory_path) print()\r스크립트 설명\r.md 파일에서 참조되지 않는 이미지나 파일을 삭제합니다. 내용이 없거나 메타데이터만 있는 마크다운 파일을 삭제합니다. _index.md 파일은 제외합니다. "},"title":"파일 정리"},"/docflow/staticsite/guide/hugo/script/%ED%8F%B4%EB%8D%94-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8/":{"data":{"":"","스크립트#스크립트":"","스크립트-설명#스크립트 설명":"스크립트\rimport os import filecmp import shutil def sync_directories(source_dir, target_dir): \"\"\" Sync the target directory to match the source directory. \"\"\" # Create target directory if it doesn't exist if not os.path.exists(target_dir): os.makedirs(target_dir) # Compare the two directories comparison = filecmp.dircmp(source_dir, target_dir) # Update files that are new or have changed for file_name in comparison.left_only + comparison.diff_files: source_file = os.path.join(source_dir, file_name) target_file = os.path.join(target_dir, file_name) if os.path.isdir(source_file): if os.path.exists(target_file): shutil.rmtree(target_file) shutil.copytree(source_file, target_file) else: shutil.copy2(source_file, target_file) # Delete files that are no longer present in the source directory for file_name in comparison.right_only: target_file = os.path.join(target_dir, file_name) if os.path.isdir(target_file): shutil.rmtree(target_file) else: os.remove(target_file) # Recursively sync subdirectories for subdir in comparison.common_dirs: sync_directories(os.path.join(source_dir, subdir), os.path.join(target_dir, subdir)) def main(): source_content_dir = '../docflow' target_content_dir = 'content/docs' source_static_dir = '../docflow/resources' target_static_dir = 'static/resources' sync_directories(source_content_dir, target_content_dir) sync_directories(source_static_dir, target_static_dir) if __name__ == \"__main__\": main()\r스크립트 설명\rsync_directories\rsource_dir과 target_dir을 비교하고 업데이트합니다. 타겟 디렉토리가 없는 경우 생성합니다. filecmp.dircmp를 사용하여 디렉토리 비교를 수행합니다. left_only는 소스 디렉토리에만 있는 파일 목록을 나타냅니다. diff_files는 두 디렉토리 간에 내용이 다른 파일 목록을 나타냅니다. right_only는 타겟 디렉토리에만 있는 파일 목록을 나타냅니다. 소스 디렉토리에만 있는 파일 및 변경된 파일을 타겟 디렉토리로 복사합니다. 타겟 디렉토리에만 있는 파일을 삭제합니다. 공통 하위 디렉토리에 대해 재귀적으로 동일한 작업을 수행합니다. main 함수\rsync_directories 함수를 호출하여 ../docflow와 content/docs를 동기화합니다. sync_directories 함수를 호출하여 ../docflow/resources와 static/resources를 동기화합니다. "},"title":"폴더 업데이트"},"/docflow/staticsite/guide/hugo/script/_index.md-%ED%8C%8C%EC%9D%BC-%EC%B6%94%EA%B0%80/":{"data":{"":"","스크립트#스크립트":"","스크립트-설명#스크립트 설명":"대부분의 Theme는 모든 폴더에 _index.md 파일을 요구합니다. metadata_template 내용은 테마에 따라 달라지며, 다음 예시는 doks theme 용입니다.\n스크립트\rimport os import datetime import re import yaml # 메타데이터 템플릿 metadata_template = { \"title\": \"{title}\", \"description\": \"\", \"summary\": \"\", \"date\": \"{date}\", \"lastmod\": \"{lastmod}\", \"draft\": False, \"weight\": 10, \"categories\": [], \"tags\": [], \"contributors\": [], \"toc\": True, \"sidebar\": { \"collapsed\": True, }, \"seo\": { \"title\": \"\", # custom title (optional) \"description\": \"\", # custom description (recommended) \"canonical\": \"\", # custom canonical URL (optional) \"noindex\": True # false (default) or true } } # YAML 로드 및 덤프 도우미 함수 def load_yaml(content): return yaml.safe_load(content) def dump_yaml(metadata): return yaml.dump(metadata, sort_keys=False, default_flow_style=False, allow_unicode=True) # 파일의 생성 시간과 수정 시간을 ISO 형식으로 반환하는 함수 def get_file_times(file_path): creation_time = os.path.getctime(file_path) modification_time = os.path.getmtime(file_path) creation_time_iso = datetime.datetime.utcfromtimestamp(creation_time).isoformat() modification_time_iso = datetime.datetime.utcfromtimestamp(modification_time).isoformat() return creation_time_iso, modification_time_iso # 메타데이터를 업데이트하거나 추가하는 함수 def update_metadata(content, title, date, lastmod): new_metadata = metadata_template.copy() new_metadata[\"title\"] = title new_metadata[\"date\"] = date new_metadata[\"lastmod\"] = lastmod # 기존 메타데이터가 있는지 확인 metadata_match = re.match(r\"---(.*?)---\", content, re.DOTALL) if metadata_match: existing_metadata_str = metadata_match.group(1) existing_metadata = load_yaml(existing_metadata_str) original_metadata = existing_metadata.copy() # 필요한 필드가 없으면 추가, 있으면 유지 for key, value in metadata_template.items(): if key not in existing_metadata: existing_metadata[key] = value elif isinstance(value, dict): for subkey, subvalue in value.items(): if subkey not in existing_metadata[key]: existing_metadata[key][subkey] = subvalue # date 필드는 원래 값 유지 if not existing_metadata.get(\"date\"): existing_metadata[\"date\"] = date # lastmod 필드 업데이트 (다른 사항이 수정된 경우에만) if existing_metadata != original_metadata: existing_metadata[\"lastmod\"] = lastmod # 새로운 메타데이터 YAML 생성 updated_metadata_str = dump_yaml(existing_metadata) new_metadata_block = f\"---\\n{updated_metadata_str}\\n---\\n\" if updated_metadata_str.strip() == existing_metadata_str.strip(): return content, 'unchanged' else: return content.replace(metadata_match.group(0), new_metadata_block), 'updated' else: # 메타데이터가 없는 경우 새 메타데이터 추가 new_metadata_str = dump_yaml(new_metadata) new_metadata_block = f\"---\\n{new_metadata_str}\\n---\\n\" return new_metadata_block + content.lstrip(), 'added' # 특정 디렉토리 내의 모든 폴더에 _index.md 파일 생성 def create_index_files(directory): total_index_files_count = 0 index_added_count = 0 index_updated_count = 0 for root, dirs, files in os.walk(directory): for dir in dirs: folder_path = os.path.join(root, dir) index_file_path = os.path.join(folder_path, \"_index.md\") # .md 파일이나 서브 폴더가 있는지 확인 has_md_files = any(file.endswith('.md') for file in os.listdir(folder_path) if os.path.isfile(os.path.join(folder_path, file))) has_sub_folders = any(os.path.isdir(os.path.join(folder_path, sub)) for sub in os.listdir(folder_path)) if not has_md_files and not has_sub_folders: continue total_index_files_count += 1 # _index.md 파일이 이미 있는지 확인 if os.path.exists(index_file_path): # 이미 존재하는 경우 업데이트 try: with open(index_file_path, 'r', encoding='utf-8') as f: content = f.read() title = os.path.basename(folder_path) _, lastmod = get_file_times(index_file_path) updated_content, status = update_metadata(content, title, None, lastmod) if status == 'updated': with open(index_file_path, 'w', encoding='utf-8') as f: f.write(updated_content) index_updated_count += 1 print(f\"Updated _index.md in {folder_path}\") except Exception as e: print(f\"Error updating {index_file_path}: {e}\") else: # 없는 경우 새로 생성 try: title = os.path.basename(folder_path) current_time = datetime.datetime.now(datetime.timezone.utc).isoformat() new_metadata = metadata_template.copy() new_metadata[\"title\"] = title new_metadata[\"date\"] = current_time new_metadata[\"lastmod\"] = current_time new_metadata_str = dump_yaml(new_metadata) new_metadata_block = f\"---\\n{new_metadata_str}\\n---\\n\" with open(index_file_path, 'w', encoding='utf-8') as f: f.write(new_metadata_block) index_added_count += 1 print(f\"Created _index.md in {folder_path}\") except Exception as e: print(f\"Error creating {index_file_path}: {e}\") return total_index_files_count, index_added_count, index_updated_count def is_markdown_file(file): return file.endswith('.md') # 디렉토리 경로를 설정하세요 (예: \"D:/Obsidian/DocFlow\") directory_path = r\"D:\\Obsidian\\DocFlow\" total_index_files_count, index_added_count, index_updated_count = create_index_files(directory_path) # 로그 출력 print(f\"Add file : _index.md\") print(f\"Total index files processed: {total_index_files_count}\") print(f\"_index.md added: {index_added_count}\") print(f\"_index.md updated: {index_updated_count}\") print()\r스크립트 설명\r스크립트는 지정된 디렉토리(directory_path) 내의 모든 폴더를 검색합니다. 각 폴더에서 _index.md 파일과 서브디렉토리가 없고 파일이 한 개만 있는 경우, 메타데이터가 포함된 _index.md 파일을 생성합니다. 메타데이터 템플릿에서 title은 폴더 이름을 사용하며, date와 lastmod는 현재 날짜와 시간을 사용합니다. "},"title":"_index.md 파일 추가"},"/docflow/staticsite/guide/hugo/script/front-matter-%EC%A0%9C%EA%B1%B0/":{"data":{"":"","스크립트#스크립트":"","스크립트-설명#스크립트 설명":"스크립트\rimport os import re def remove_metadata_from_files(directory): total_files_count = 0 removed_count = 0 not_found_count = 0 for root, _, files in os.walk(directory): for file in files: if file.endswith(\".md\"): total_files_count += 1 file_path = os.path.join(root, file) try: with open(file_path, 'r', encoding='utf-8') as f: content = f.read() # 코드 블럭 패턴 code_block_pattern = re.compile(r'```[\\s\\S]+?```') metadata_pattern = re.compile(r'^---.*?^---\\s*', flags=re.DOTALL | re.MULTILINE) def replace_metadata(match): block = match.group(0) # 코드 블럭이 아닌 경우 메타데이터를 제거 if not code_block_pattern.search(block): return metadata_pattern.sub('', block) return block # 메타데이터 블록을 찾고 제거 new_content = re.sub(metadata_pattern, replace_metadata, content) if new_content != content: try: # 원본 파일 백업 backup_path = file_path + \".bak\" with open(backup_path, 'w', encoding='utf-8') as f: f.write(content) # 파일을 업데이트 with open(file_path, 'w', encoding='utf-8') as f: f.write(new_content) print(f\"Removed metadata from {file_path}, backup created at {backup_path}\") removed_count += 1 except Exception as e: print(f\"Error writing to {file_path}: {e}\") else: not_found_count += 1 except OSError as e: print(f\"Error reading {file_path}: {e}\") not_found_count += 1 return total_files_count, removed_count, not_found_count # 디렉토리 경로를 설정하세요 directory_path = r\"D:\\Obsidian\\DocFlow\" total_files_count, removed_count, not_found_count = remove_metadata_from_files(directory_path) # 로그 출력 print() print(f\"Total files processed: {total_files_count}\") print(f\"Metadata removed: {removed_count}\") print(f\"Metadata not found: {not_found_count}\")\r스크립트 설명\r메타데이터 블록(시작과 끝이 ---로 표시된 블록)을 찾아 제거합니다. 코드 블럭 안의 메타데이터는 제외합니다. 기존 데이터는 .bak 파일로 백업합니다. "},"title":"Front Matter 제거"},"/docflow/staticsite/guide/hugo/script/front-matter-%EC%B6%94%EA%B0%80/":{"data":{"":"","스크립트#스크립트":"","스크립트-설명#스크립트 설명":"스크립트\rimport os import datetime import re import yaml # 메타데이터 템플릿 metadata_template = { \"title\": \"{title}\", \"description\": \"\", \"summary\": \"\", \"date\": \"{date}\", \"lastmod\": \"{lastmod}\", \"draft\": False, \"weight\": 10, \"categories\": [], \"tags\": [], \"contributors\": [], \"toc\": True, \"sidebar\": { \"collapsed\": True, }, \"seo\": { \"title\": \"\", # custom title (optional) \"description\": \"\", # custom description (recommended) \"canonical\": \"\", # custom canonical URL (optional) \"noindex\": False # 일반 md 파일의 경우 False } } # YAML 로드 및 덤프 도우미 함수 def load_yaml(content): return yaml.safe_load(content) def dump_yaml(metadata): return yaml.dump(metadata, sort_keys=False, default_flow_style=False, allow_unicode=True) # 파일 경로로부터 카테고리와 태그를 추출하는 함수 def extract_categories_and_tags(file_path, base_dir): # base_dir을 기준으로 상대 경로를 얻음 relative_path = os.path.relpath(file_path, base_dir) # 상대 경로를 분할하여 폴더 구조를 얻음 parts = relative_path.split(os.sep) # 최상위 폴더를 카테고리로 설정 category = parts[0] # 모든 상위 폴더를 태그로 설정 tags = parts[:-1] # 파일 이름을 제외한 모든 폴더 return category, tags # 파일의 생성 시간과 수정 시간을 ISO 형식으로 반환하는 함수 def get_file_times(file_path): creation_time = os.path.getctime(file_path) modification_time = os.path.getmtime(file_path) creation_time_iso = datetime.datetime.utcfromtimestamp(creation_time).isoformat() modification_time_iso = datetime.datetime.utcfromtimestamp(modification_time).isoformat() return creation_time_iso, modification_time_iso # 메타데이터를 업데이트하거나 추가하는 함수 def update_metadata(content, title, category, tags, date, lastmod): new_metadata = metadata_template.copy() new_metadata[\"title\"] = title new_metadata[\"date\"] = date new_metadata[\"lastmod\"] = lastmod new_metadata[\"categories\"] = [category] new_metadata[\"tags\"] = tags # 기존 메타데이터가 있는지 확인 metadata_match = re.match(r\"---(.*?)---\", content, re.DOTALL) if metadata_match: existing_metadata_str = metadata_match.group(1) existing_metadata = load_yaml(existing_metadata_str) original_metadata = existing_metadata.copy() # 변경 전 메타데이터를 저장 # 필요한 필드가 없으면 추가, 있으면 유지 for key, value in metadata_template.items(): if key not in existing_metadata: existing_metadata[key] = value elif isinstance(value, dict): for subkey, subvalue in value.items(): if subkey not in existing_metadata[key]: existing_metadata[key][subkey] = subvalue # date 필드는 비어 있는 경우에만 업데이트 if \"date\" not in existing_metadata or not existing_metadata[\"date\"]: existing_metadata[\"date\"] = date # lastmod 필드 업데이트 if existing_metadata != original_metadata: # 다른 메타데이터가 변경된 경우에만 lastmod 업데이트 existing_metadata[\"lastmod\"] = lastmod else: return content, 'unchanged' # 새로운 메타데이터 YAML 생성 updated_metadata_str = dump_yaml(existing_metadata) new_metadata_block = f\"---\\n{updated_metadata_str}---\\n\" return content.replace(metadata_match.group(0), new_metadata_block).replace('\\n\\n', '\\n'), 'updated' else: # 메타데이터가 없는 경우 새 메타데이터 추가 new_metadata[\"date\"] = date new_metadata_str = dump_yaml(new_metadata) new_metadata_block = f\"---\\n{new_metadata_str}---\\n\" return new_metadata_block + content.lstrip(), 'added' # 특정 디렉토리 내의 모든 파일에 메타데이터 추가 또는 업데이트 def add_metadata_to_files(directory): total_files_count = 0 updated_count = 0 ignored_count = 0 added_count = 0 for root, dirs, files in os.walk(directory): for file in files: if file.endswith('.md') and file != \"_index.md\": total_files_count += 1 file_path = os.path.join(root, file) try: with open(file_path, 'r', encoding='utf-8') as f: content = f.read() # 파일 이름을 제목으로 사용 (확장자 제외) title = os.path.splitext(file)[0] # 카테고리와 태그 추출 category, tags = extract_categories_and_tags(file_path, directory) # 파일의 생성 시간과 수정 시간 추출 date, lastmod = get_file_times(file_path) updated_content, status = update_metadata(content, title, category, tags, date, lastmod) if status == 'updated': updated_count += 1 elif status == 'added': added_count += 1 if status in ('updated', 'added'): try: with open(file_path, 'w', encoding='utf-8') as f: f.write(updated_content) print(f\"Updated metadata in {file_path}\") except Exception as e: print(f\"Error writing to {file_path}: {e}\") except Exception as e: print(f\"Error reading {file_path}: {e}\") ignored_count += 1 return total_files_count, updated_count, ignored_count, added_count # 디렉토리 경로를 설정하세요 (예: \"D:/Obsidian/DocFlow\") directory_path = r\"D:\\Obsidian\\DocFlow\" total_files_count, updated_count, ignored_count, added_count = add_metadata_to_files(directory_path) # 로그 출력 print(f\"Add Metadata\") print(f\"Total files processed: {total_files_count}\") print(f\"Metadata updated: {updated_count}\") print(f\"Metadata ignored: {ignored_count}\") print(f\"Metadata added: {added_count}\") print()\r스크립트 설명\r스크립트는 지정된 디렉토리(directory_path) 내의 모든 .md 파일을 검색합니다. 각 파일을 읽고, 메타데이터가 이미 있는지 확인합니다. 메타데이터가 없는 파일의 경우, 파일의 시작 부분에 메타데이터를 추가합니다. 폴더에 _index.md 파일이 없으면 추가합니다. 메타데이터 템플릿에서 title은 파일 이름을 사용합니다.date와 lastmod는 파일의 생성시간과 마지막 수정시간으로 업데이트합니다. 최상위 폴더는 Categories 에 추가하고, 경로상 모든 폴더를 Tags 로 추가합니다. 기존에 내용이 있는 경우 유지하되 중복되지 않는 항목은 추가합니다. Contributors: 기존에 내용이 있는 경우 그대로 유지합니다. 메타데이터 필드: title, date, lastmod, categories, tags 필드 외의 항목은 기존에 있는 경우 그대로 유지하고, 없는 경우에만 추가합니다. 사이드바 접기 설정: 최상위 폴더는 collapsed: False, 나머지 폴더는 collapsed: True로 설정합니다. 빈 줄 제거: 메타데이터 블록과 내용 첫 줄 사이에 빈 줄이 없도록 합니다. "},"title":"Front Matter 추가"},"/docflow/staticsite/guide/hugo/section/":{"data":{"":"","개요#개요":"","기본-섹션-구조#기본 섹션 구조":"","레이아웃-및-템플릿#레이아웃 및 템플릿":"","메뉴-구성#메뉴 구성":"","섹션sections#섹션(Sections)":"","섹션의-역할#섹션의 역할":"","예제#예제":"개요\rHugo의 테마에서 섹션을 이해하는 것은 중요한 개념입니다. 섹션을 활용하여 사이트의 구조를 관리하고 콘텐츠를 조직화하며 사이트 내비게이션을 쉽게 구성할 수 있습니다. 섹션별로 레이아웃과 메뉴를 설정하여 사용자에게 일관된 경험을 제공할 수 있습니다.\n섹션(Sections)\rHugo에서는 콘텐츠 디렉토리의 하위 폴더를 섹션이라고 합니다. 예를 들어, content/docs, content/blog, content/projects와 같은 폴더들이 섹션입니다. Doks 테마는 이러한 섹션을 활용하여 다양한 페이지와 메뉴 항목을 생성합니다.\n기본 섹션 구조\rDoks 테마는 보통 다음과 같은 섹션 구조를 가집니다:\ncontent/ ├── docs/ │ ├── _index.md │ ├── guide/ │ │ ├── _index.md │ │ └── installation.md │ └── tutorial/ │ ├── _index.md │ └── getting-started.md ├── blog/ │ ├── _index.md │ └── my-first-post.md └── projects/ ├── _index.md └── my-project.md\r섹션의 역할\r각 섹션은 해당 섹션의 루트에 _index.md 파일을 가질 수 있으며, 이는 섹션의 메인 페이지 역할을 합니다. 예를 들어, content/docs/_index.md는 /docs/ URL에 해당하는 메인 페이지를 생성합니다. 섹션 내의 다른 파일들은 하위 페이지로 작동합니다.\n메뉴 구성\r일반적으로 config.toml 또는 config.yaml 파일을 통해 메뉴를 구성합니다. 메뉴 항목은 섹션과 매핑되어 사이트의 내비게이션을 구성합니다. 예를 들어, 다음과 같이 설정할 수 있습니다:\n[menu] [[menu.main]] name = \"Docs\" url = \"/docs/\" weight = 1 [[menu.main]] name = \"Blog\" url = \"/blog/\" weight = 2 [[menu.main]] name = \"Projects\" url = \"/projects/\" weight = 3\rdoks 테마에서는 /config/_default/menus 폴더에 언어별 별도 파일로 분리되어 있습니다.\n[[main]] name = \"Docs\" url = \"/docs/guides/example-guide/\" # url = \"/docs/1.0/prologue/introduction/\" weight = 10 [[main]] name = \"Blog\" url = \"/blog/\" weight = 30\r레이아웃 및 템플릿\r각 섹션은 특정 레이아웃과 템플릿을 사용할 수 있습니다. 예를 들어, layouts/blog/single.html은 content/blog/ 아래에 있는 Markdown 파일들이 사용할 템플릿입니다. 이를 통해 섹션별로 다른 디자인과 레이아웃을 적용할 수 있습니다.\n예제\rcontent/docs/guide/installation.md의 예제: # Installation Guide 이 문서는 Doks 테마를 설치하는 방법에 대해 설명합니다.\rconfig.toml에서 메뉴 항목 추가:\n[menu] [[menu.main]] name = \"Installation Guide\" url = \"/docs/guide/installation/\" weight = 4"},"title":"Section"},"/docflow/staticsite/guide/hugo/toml/":{"data":{"":"","#":"hugo.toml 파일은 Hugo static site generator를 설정하는 구성 파일입니다. 각 항목은 사이트의 동작과 모양새를 조절합니다.\nbaseURL = \"https://example.docsy.dev/\" title = \"Aprofl\" contentDir = \"content\" defaultContentLanguage = \"ko\" defaultContentLanguageInSubdir = true enableMissingTranslationPlaceholders = true enableRobotsTXT = true enableGitInfo = true [taxonomies] tag = \"tags\" category = \"categories\" [params.taxonomy] taxonomyCloud = [\"tags\", \"categories\"] taxonomyCloudTitle = [\"Tag Cloud\", \"Categories\"] taxonomyPageHeader = [\"tags\", \"categories\"] # Highlighting config pygmentsCodeFences = true pygmentsUseClasses = false pygmentsUseClassic = false pygmentsStyle = \"tango\" [permalinks] blog = \"/:section/:year/:month/:day/:slug/\" [imaging] resampleFilter = \"CatmullRom\" quality = 75 anchor = \"smart\" [languages] [languages.ko] languageName = \"한국어\" weight = 1 [languages.ko.params] title = \"Aprofl\" description = \"생산성을 위한 블로그\" [languages.en] languageName = \"English\" weight = 2 [languages.en.params] title = \"Aprofl\" description = \"Blog for Productivity\" [markup] [markup.goldmark] [markup.goldmark.parser.attribute] block = true [markup.goldmark.renderer] unsafe = true [markup.highlight] style = \"tango\" [outputs] section = [\"HTML\", \"print\", \"RSS\"] [params] privacy_policy = \"https://policies.google.com/privacy\" version_menu = \"Releases\" archived_version = false version = \"0.0\" url_latest_version = \"https://example.com\" github_repo = \"https://github.com/google/docsy-example\" github_project_repo = \"https://github.com/google/docsy\" github_branch = \"main\" gcs_engine_id = \"d72aa9b2712488cc3\" offlineSearch = false prism_syntax_highlighting = false [params.copyright] authors = \"Aprofl\" from_year = 2024 # User interface configuration [params.ui] breadcrumb_disable = false navbar_logo = true navbar_translucent_over_cover_disable = false sidebar_menu_compact = false sidebar_search_disable = false disable_search = false [params.ui.feedback] enable = false yes = 'Glad to hear it! Please \u003ca href=\"https://github.com/USERNAME/REPOSITORY/issues/new\"\u003etell us how we can improve\u003c/a\u003e.' no = 'Sorry to hear that. Please \u003ca href=\"https://github.com/USERNAME/REPOSITORY/issues/new\"\u003etell us how we can improve\u003c/a\u003e.' [params.ui.readingtime] enable = false [module] [module.hugoVersion] extended = true min = \"0.110.0\" [[module.imports]] path = \"github.com/google/docsy\" disable = false [menu] [[menu.main]] identifier = \"blog\" name = \"Blog\" url = \"/ko/blog/\" weight = 0 [[menu.main]] identifier = \"obsidian\" name = \"Obsidian\" url = \"/ko/obsidian/\" weight = 1\r기본 설정\rbaseURL = \"https://example.docsy.dev/\" 사이트의 기본 URL을 설정합니다. title = \"Aprofl\" 사이트의 제목을 설정합니다. contentDir = \"content\" 컨텐츠 디렉토리의 경로를 설정합니다. defaultContentLanguage = \"ko\" 기본 언어를 한국어로 설정합니다. `defaultContentLanguageInSubdir = true 기본 언어를 하위 디렉토리에 포함시킵니다. enableMissingTranslationPlaceholders = true 번역이 누락된 경우, 플레이스홀더를 표시합니다. enableRobotsTXT = true robots.txt 파일을 생성하여 검색 엔진에 사이트 인덱싱 방법을 알려줍니다. enableGitInfo = true 마지막 수정 시간 등의 Git 정보를 사용합니다. 분류 및 태그 설정\r[taxonomies]: 사이트의 분류 체계를 정의합니다. tag = \"tags\" category = \"categories\" [params.taxonomy]: 분류 관련 추가 설정입니다. taxonomyCloud = [\"tags\", \"categories\"] 분류 클라우드를 설정합니다. taxonomyCloudTitle = [\"Tag Cloud\", \"Categories\"] 분류 클라우드의 제목을 설정합니다. taxonomyPageHeader = [\"tags\", \"categories\"] 페이지 헤더에 분류를 표시합니다. 코드 하이라이팅 설정\rpygmentsCodeFences = true 코드 펜스를 사용할 때 Pygments를 사용하여 코드 블록을 하이라이팅합니다. Pygments는 다양한 프로그래밍 언어의 소스 코드를 구문 강조(문법 하이라이트)하기 위해 사용되는 오픈 소스 라이브러리입니다. pygmentsUseClasses = false Pygments에서 직접 스타일을 적용하는 대신, CSS 클래스를 사용하도록 설정합니다. false로 설정하면 스타일이 직접 HTML 요소에 적용됩니다. pygmentsUseClassic = false Pygments 대신 새로운 Chroma 하이라이터를 사용하도록 설정합니다. Chroma는 Go 언어로 작성된 하이라이팅 라이브러리로, 더 빠르고 간단한 설정을 제공합니다. pygmentsStyle = \"tango\" 하이라이팅 스타일을 지정합니다. “tango\"는 Pygments의 여러 스타일 중 하나입니다. 다른 스타일을 사용하고 싶다면 Pygments 스타일 목록을 참고하여 원하는 스타일을 설정할 수 있습니다. URL 형식 설정\r[permalinks]: 섹션별 URL 형식을 설정합니다. `blog = “/:section/:year/:month/:day/:slug/” 블로그 게시물의 URL 형식을 설정합니다. 이미지 처리 설정\r[imaging]: 이미지 처리 설정입니다. resampleFilter = \"CatmullRom\": 이미지 리샘플링 필터를 설정합니다. quality = 75: 이미지 품질을 설정합니다. anchor = \"smart\": 이미지 앵커를 스마트하게 설정합니다. 언어 설정\r[languages]: 다국어 지원을 설정합니다. [languages.ko]: 한국어 설정입니다. languageName = \"한국어\": 언어 이름을 설정합니다. weight = 1: 언어의 우선순위를 설정합니다. [languages.ko.params]: 한국어 페이지의 추가 매개변수입니다. title = \"Aprofl\": 한국어 페이지의 제목을 설정합니다. description = \"생산성을 위한 블로그\": 한국어 페이지의 설명을 설정합니다. [languages.en]: 영어 설정입니다. languageName = \"English\": 언어 이름을 설정합니다. weight = 2: 언어의 우선순위를 설정합니다. [languages.en.params]: 영어 페이지의 추가 매개변수입니다. title = \"Aprofl\": 영어 페이지의 제목을 설정합니다. description = \"Blog for Productivity\": 영어 페이지의 설명을 설정합니다. 마크업 설정\r[markup]: 마크업 관련 설정입니다. [markup.goldmark]: Goldmark 마크다운 렌더러 설정입니다. [markup.goldmark.parser.attribute]: Goldmark 파서 설정입니다. block = true: 블록 수준의 속성 파서를 활성화합니다. [markup.goldmark.renderer]: Goldmark 렌더러 설정입니다. unsafe = true: 안전하지 않은 HTML 렌더링을 허용합니다. [markup.highlight]: 코드 하이라이팅 설정입니다. style = \"tango\": 하이라이팅 스타일을 tango로 설정합니다. 사이트 매개변수\r[params]: 사이트의 다양한 매개변수 설정입니다. privacy_policy = \"https://policies.google.com/privacy\": 개인정보 보호정책 URL을 설정합니다. version_menu = \"Releases\": 버전 선택 메뉴 제목을 설정합니다. archived_version = false: 아카이브된 버전 배너 표시 여부를 설정합니다. version = \"0.0\": 현재 문서 세트의 버전 번호를 설정합니다. url_latest_version = \"https://example.com\": 최신 버전의 문서 링크를 설정합니다. github_repo = \"https://github.com/google/docsy-example\": GitHub 저장소 URL을 설정합니다. github_project_repo = \"https://github.com/google/docsy\": 관련 프로젝트 GitHub 저장소 URL을 설정합니다. github_branch= \"main\": GitHub 브랜치를 설정합니다. gcs_engine_id = \"d72aa9b2712488cc3\": Google Custom Search Engine ID를 설정합니다. offlineSearch = false: Lunr.js 오프라인 검색을 활성화합니다. prism_syntax_highlighting = false: Prism 구문 강조를 비활성화합니다. [params.copyright]: 저작권 정보를 설정합니다. - authors = \"Aprofl\": 저작권 소유자를 설정합니다. - from_year = 2024: 저작권 시작 연도를 설정합니다. [params.ui]: 사용자 인터페이스 설정입니다. breadcrumb_disable = false: 브레드크럼 내비게이션을 활성화합니다. navbar_logo = true: 네비게이션 바에 로고를 표시합니다. navbar_translucent_over_cover_disable = false: 커버 위의 네비게이션 바를 반투명하게 설정합니다. sidebar_menu_compact = false: 사이드바 메뉴를 컴팩트하게 설정합니다. sidebar_search_disable = false: 사이드바 검색을 비활성화합니다. disable_search = false: 검색 기능을 활성화합니다. [params.ui.feedback]: 피드백 설정입니다. - enable = false: 피드백 기능을 비활성화합니다. - yes = 'Glad to hear it! Please \u003ca href=\"https://github.com/USERNAME/REPOSITORY/issues/new\"\u003etell us how we can improve\u003c/a\u003e.': 긍정 피드백 메시지를 설정합니다. - no = 'Sorry to hear that. Please \u003ca href=\"https://github.com/USERNAME/REPOSITORY/issues/new\"\u003etell us how we can improve\u003c/a\u003e.': 부정 피드백 메시지를 설정합니다. [params.ui.readingtime]: 읽기 시간 설정입니다. - enable = false: 읽기 시간 표시를 비활성화합니다. 모듈 설정\r[module]: Hugo 모듈 설정입니다. [module.hugoVersion]: Hugo 버전 설정입니다. extended = true: Hugo Extended 버전을 사용합니다. min = \"0.110.0\": 최소 Hugo 버전을 설정합니다. [[module.imports]]: 모듈을 가져옵니다. path = \"github.com/google/docsy\": Docsy 테마를 가져옵니다. disable = false: 모듈을 비활성화합니다. [[module.imports]]: 모듈을 가져옵니다. path = \"../../Blog\": 로컬 Blog 모듈을 가져옵니다. disable = false: 모듈을 비활성화합니다. 메뉴 설정\r[menu]: 사이트 메뉴를 설정합니다. [[menu.main]]: 메인 메뉴 항목을 추가합니다. identifier = \"blog\": 블로그 메뉴 항목의 식별자를 설정합니다. name = \"Blog\": 블로그 메뉴 항목의 이름을 설정합니다. url = \"/ko/blog/\": 블로그 메뉴 항목의 URL을 설정합니다. weight = 0: 블로그 메뉴 항목의 정렬 가중치를 설정합니다. [[menu.main]]: 메인 메뉴 항목을 추가합니다. identifier = \"obsidian\": Obsidian 메뉴 항목의 식별자를 설정합니다. name = \"Obsidian\": Obsidian 메뉴 항목의 이름을 설정합니다. url = \"/ko/obsidian/\": Obsidian 메뉴 항목의 URL을 설정합니다. weight = 1: Obsidian 메뉴 항목의 정렬 가중치를 설정합니다. /blog_docsy/ /blog_docsy/content/ /blog_docsy/content/ko /blog_docsy/content/ko/Blog /blog_docsy/content/ko/Blog/folder1/ /blog_docsy/content/ko/Blog/folder2/ /blog_docsy/content/ko/Obsidian/ /blog_docsy/content/ko/Obsidian/index.md /blog_docsy/content/ko/Obsidian/folder1/ /blog_docsy/content/ko/Obsidian/folder2/ /blog_docsy/content/ko/StaticSite/ /blog_docsy/content/ko/StaticSite/folder1/ /blog_docsy/content/ko/StaticSite/folder2/ /blog_docsy/layouts/ /blog_docsy/layouts/section/ /blog_docsy/layouts/section/obsidian.html /blog_docsy/hugo.toml /blog_docsy/config.yaml "},"title":"toml"},"/docflow/staticsite/guide/mkdocs/%EB%8B%A4%EA%B5%AD%EC%96%B4-%EC%A7%80%EC%9B%90/":{"data":{"":"","1-플러그인-설치#1. 플러그인 설치":"","mkdocs-수정#MkDocs 수정":"","구성#구성":"1. 플러그인 설치\rmkdocs-static-i18n 플러그인 설치 `pip install mkdocs-static-i18n`\rMkDocs 수정\rtheme: name: material features: - i18n\rfeatures.i18n : 다국어 지원을 위한 기본적인 설정 제공 다국어 전환 메뉴 표시: 드롭다운 메뉴를 통해 사용자가 언어 전환 가능 이 기능은 기본적으로 제공되지만, i18n 설정을 통해 테마에서 더욱 정교하게 관리 가능 언어별 스타일 및 설정: 각 언어에 대한 특정 스타일이나 설정 적용 가능 텍스트 방향이나 언어별 폰트 설정 등. 내비게이션 및 UI 요소의 언어별 번역 Material for MkDocs는 내비게이션, 버튼 등 다양한 UI 요소를 다국어로 번역할 수 있는 기능 제공 i18n을 추가하면 이러한 번역 기능을 손쉽게 사용 가능 다국어 SEO: 다국어 지원을 통해 검색 엔진 최적화(SEO)에서 각 언어별로 최적화된 페이지를 제공 구성\r다국어 지원을 위해 각 언어별로 문서 정리 예를 들어, 영어(en), 한국어(ko), 일어(ja), 중국어(zh)를 지원 하는 경우 1. 문서구조 - folder\rMkDocs 설정 파일 수정 site_name: Manual theme: name: material features: - i18n plugins: - search - i18n: docs_structure: folder fallback_to_default: true reconfigure_material: true reconfigure_search: true languages: - locale: en name: English default: true build: true site_name: \"Manual\" nav: - Home: en/index.md - locale: ko name: 한국어 build: true site_name: \"매뉴얼\" nav: - 홈: ko/index.md - locale: zh name: 中文 build: true nav: - 主页: zh/index.md - locale: ja name: 日本語 build: true nav: - ホーム: ja/index.md\r폴더 및 파일 구조 docs/ │ ├── en/ │ ├── index.md │ ├── ko/ │ ├── index.md │ ├── ja/ │ ├── index.md │ └── zh/ ├── index.md\r각 언어 폴더 내에 문서를 작성 예를 들어, docs/en/index.md 파일에는 영어로 된 콘텐츠, docs/ko/index.md 파일에는 한국어로 된 콘텐츠 작성 2. 문서 구조 - suffix\rMkDocs 설정 파일 수정 site_name: Manual theme: name: material language: en features: - i18n plugins: - search - i18n: docs_structure: suffix fallback_to_default: true reconfigure_material: true reconfigure_search: true languages: - locale: en name: English default: true build: true site_name: \"Manual\" - locale: ko name: 한국어 build: true site_name: \"매뉴얼\" nav_translations: Home: 홈 - locale: zh name: 中文 build: true site_name: \"手册\" nav_translations: Home: 主页 - locale: ja name: 日本語 build: true site_name: \"マニュアル\" nav_translations: Home: ホーム\r폴더 및 파일 구조 docs/ ├── index.en.md ├── index.ko.md ├── index.zh.md ├── index.ja.md\r각각의 언어 파일에 접미사를 붙여 작성 예를 들어, docs/index.en.md 파일에는 영어로 된 콘텐츠, docs/index.ko.md 파일에는 한국어로 된 콘텐츠 작성 여기까지 하면 MkDocs 는 정상 동작 일렉트론으로 빌드하면 언어 설정은 안됨"},"title":"다국어 지원"},"/docflow/staticsite/guide/mkdocs/%EC%84%A4%EC%B9%98/":{"data":{"":"","#":"1. Python 설치\rMkDocs는 Python으로 작성되어 있으므로, 먼저 Python 설치\nPython 공식 사이트에서 최신 버전 다운로드 설치 프로그램을 실행하고, “Add Python to PATH” 옵션을 체크한 후 “Install Now\"클릭 2. MkDocs 설치\rPython이 설치된 후, MkDocs를 설치\n명령 프롬프트(CMD) 실행 다음 명령어를 입력하여 pip 업데이트 MkDocs 설치 python -m pip install --upgrade pip pip install mkdocs\r3. MkDocs 프로젝트 생성\r명령 프롬프트에서 작업하고자 하는 디렉터리로 이동 \u003e cd path\\to\\your\\directory\r새로운 MkDocs 프로젝트 생성 \u003e mkdocs new my-project\r생성된 프로젝트 디렉터리로 이동 \u003e cd my-project\r4. MkDocs 서버 시작\rMkDocs에는 내장된 개발 서버가 있어 로컬 환경에서 문서 확인 가능\n아래 명령어를 입력하여 개발 서버를 시작합니다. \u003e mkdocs serve\r브라우저에서 http://127.0.0.1:8000 로 이동하여 MkDocs 확인 "},"title":"설치"},"/docflow/staticsite/guide/mkdocs/%EC%9E%91%EC%84%B1/":{"data":{"":"","#":"1. MkDocs 설정 파일 수정\rMkDocs의 설정 파일인 mkdocs.yml을 수정하여 사이트 구성 가능\n편집기를 이용하여 프로젝트 디렉터리의 mkdocs.yml 파일 오픈 구성 예시 site_name: KCT Manual nav: - Home: index.md - User Guide: - Introduction: guide/introduction.md - EtherCAT: guide/ethercat.md - Object Dictionary: guide/dictionary.md theme: name: readthedocs\r개발 서버가 열려 있다면 변경 사항 즉시 확인 가능 6. 문서 작성\rdocs 폴더 내의 Markdown 파일을 수정하거나 새로운 파일을 추가하여 문서 작성\ndocs/index.md 파일을 텍스트 편집기로 열어 내용 수정 새 문서를 추가하려면 docs 폴더에 새로운 Markdown 파일 생성 폴더 구조인 경우, 폴더 생성 후 파일 생성 \u003e echo \"# Introduction\" \u003e docs/guide/introduction.md\r7. 사이트 배포\r문서를 모두 작성한 후 정적 사이트를 생성하여 배포\n다음 명령어를 입력하여 정적 사이트 파일 생성 \u003e mkdocs build\rsite 폴더 및 정적 파일 생성 확인 이 파일들을 웹 서버에 업로드하거나 GitHub Pages 등을 통해 배포 "},"title":"작성"},"/docflow/staticsite/guide/mkdocs/%EC%B0%B8%EC%A1%B0%EA%B2%BD%EB%A1%9C-%ED%99%95%EC%9D%B8/":{"data":{"":"","참조-경로-확인#참조 경로 확인":"참조 경로 확인\rsite 폴더의 index.html 을 실행하여, 다른 경로로 이동해보자 이동이 안될 수 있는데 MkDocs를 사용하여 정적 사이트를 빌드하고, 로컬 파일 시스템에서 index.html 파일을 직접 실행할 때 다른 페이지로 링크가 작동하지 않는 문제는 파일 시스템과 웹 서버의 차이에서 발생합니다. MkDocs는 상대 경로를 사용하여 링크를 생성하는데, 로컬 파일 시스템에서는 이러한 링크가 제대로 해석되지 않을 수 있음 site_name: Manual copyright: \"Copyright \u0026copy; 2000- \" docs_dir: docs/ use_directory_urls: false\ruse_directory_urls 옵션을 추가하고 이를 false로 설정 이렇게 하면 MkDocs가 각 페이지에 대해 index.html을 사용하지 않고, 전체 파일 경로를 사용하여 링크를 생성 "},"title":"참조경로 확인"},"/docflow/staticsite/guide/mkdocs/mkdocs-%ED%85%8C%EB%A7%88-%EB%B3%80%EA%B2%BD/":{"data":{"":"","기본테마#기본테마":"","커스텀-테마#커스텀 테마":"기본테마\r기본 테마는 mkdocs, readthedocs 등 ‘mkdocs.yml’ 파일 수정 site_name: KCT_Manual theme: name: readthedocs\r커스텀 테마\rMeterial 테마\r테마 설치 \u003e pip install mkdocs-material\r‘mkdocs.yml’ 파일 수정 site_name: My Docs theme: name: material\r추가 설정 site_name: My Docs theme: name: material palette: - scheme: default primary: indigo accent: indigo toggle: icon: material/brightness-7 name: Switch to dark mode - scheme: slate primary: indigo accent: indigo toggle: icon: material/brightness-4 name: Switch to light mode font: text: Roboto code: Roboto Mono features: - navigation.instant - navigation.top\rscheme: default는 라이트 모드, slate는 다크 모드 primary: 기본 색상 accent: 강조 색상 toggle: 테마 전환 버튼 설정 icon: 아이콘 설정. Material Icons 사용 name: 전환 버튼의 이름 features: Material 테마의 고급 기능 활성화 navigation.instant: 즉각적인 네비게이션 활성화 navigation.top: 사이드바(nav)를 상단에 고정. FindProcDLL 플러그인 다운로드 KillProcDLL 플러그인 다운로드 "},"title":"MkDocs 테마 변경"},"/docflow/staticsite/guide/mkdocs/tips/":{"data":{"":"다크모드를 기본으로 바꾸는 법\ntheme: name: material palette: - scheme: slate # 다크 모드를 기본으로 설정 primary: indigo accent: indigo toggle: icon: material/brightness-4 name: Switch to light mode - scheme: default primary: indigo accent: indigo toggle: icon: material/brightness-7 name: Switch to dark mode font: text: Roboto code: Roboto Mono extra_css: - css/custom.css"},"title":"Tips"},"/docflow/staticsite/tips/%EC%8B%AC%EB%B3%BC%EB%A6%AD%EB%A7%81%ED%81%AC-%EC%84%A4%EC%A0%95/":{"data":{"":"","심볼릭-링크#심볼릭 링크":"","심볼릭-링크-생성#심볼릭 링크 생성":"","심볼릭-링크-제거#심볼릭 링크 제거":"심볼릭 링크\r심볼릭 링크는 특정 디렉토리나 파일을 가리키는 특별한 파일로, 링크를 통해 원본 디렉토리나 파일에 접근할 수 있게 해줍니다. 예를 들어, obsidian/blog 폴더를 Hugo의 content/blog 폴더에 심볼릭 링크로 연결하면, Hugo는 content/blog를 통해 obsidian/blog에 저장된 파일들을 직접 읽을 수 있습니다. Obsidian에서 작성하거나 수정한 내용이 자동으로 Hugo 사이트 빌드에 반영됩니다. 파일을 중복으로 관리할 필요가 없으므로, 관리가 더 용이하고, 데이터 일관성을 유지할 수 있습니다. 심볼릭 링크 생성\rObsidian의 blog 폴더를 Hugo의 content 디렉토리로 참조하도록 심볼릭 링크를 생성합니다. 심볼릭 링크를 생성할 때, 링크를 생성하려는 위치에 이미 디렉토리나 파일이 존재하면 해당 위치에 심볼릭 링크를 추가할 수 없습니다. 심볼릭 링크를 생성하려면 링크를 생성하려는 경로가 비어 있어야 합니다. 명령 프롬프트에서 다음 명령어를 실행합니다. mklink /D \"D:\\obsidian\\blog_hugo\\content\\Blog\" \"D:\\obsidian\\Blog\"\r/D 옵션은 디렉토리에 대한 심볼릭 링크를 생성하는 것을 의미합니다. 심볼릭 링크 제거\r잘못된 경로로 심볼릭 링크가 연결되었다면, 제거하고 다시 연결합니다. 링크가 파일인 경우 del 명령어를 사용하여 심볼릭 링크를 삭제합니다. del \"D:obsidian\\content\\blog.md\"\r링크가 디렉토리인 경우 rmdir 명령어를 사용합니다. rmdir \"D:\\obsidian\\blog_hugo\\content\\blog\""},"title":"심볼릭링크 설정"},"/docflow/staticsite/tips/%ED%8F%B4%EB%8D%94-%EA%B5%AC%EC%A1%B0-%EB%B3%B4%EA%B8%B0/":{"data":{"":"","#":"명령 프롬프트에서 tree 명령은 디렉터리 구조를 트리 형식으로 시각화하는 데 사용됩니다. 이 명령은 파일과 폴더의 계층 구조를 보기 쉽게 표시하여, 시스템의 디렉터리 구조를 빠르게 파악하는 데 유용합니다.\n기본 사용법\rtree [드라이브:][경로] [/F] [/A]\r주요 옵션\r**/F : 파일을 포함하여 디렉터리 구조를 나열합니다. /A: ASCII 문자만 사용하여 트리를 그립니다(특수 문자가 깨지는 문제를 방지). D:\\Obsidian\u003etree /a 새 볼륨 볼륨에 대한 폴더 경로의 목록입니다. 볼륨 일련 번호는 ----입니다. D:. +---.obsidian +---.trash \\---Obsidian +---.makemd +---.obsidian | +---plugins | | +---codeblock-customizer | | +---d2-obsidian | | +---dataview | | +---obsidian-full-calendar | | +---obsidian-git | | +---obsidian-minimal-settings | | +---obsidian-pandoc | | +---obsidian-style-settings | | +---obsidian-tasks-plugin | | +---recent-files-obsidian | | +---table-editor-obsidian | | \\---templater-obsidian | \\---themes | \\---Minimal +---.space +---.trash | \\---BackData +---Blog | +---.obsidian"},"title":"폴더 구조 보기"}}